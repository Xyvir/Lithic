created: 20260211004759590
modified: 20260211010356664
module-type: startup
tags: 
title: $:/lithic/modules/startup/stamp-macro.js
type: application/javascript

/*\
title: $:/lithic/modules/startup/stamp-macro.js
type: application/javascript
module-type: startup

Stamp Macro Hook (v11 - Shielded Monkeypatch)
- Overrides addTiddler with aggressive null-checks.
- Prevents "undefined" crashes on state tiddlers.

\*/

(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "stamp-macro-monkeypatch";
exports.platforms = ["browser"];
exports.after = ["startup"];
exports.synchronous = true;

exports.startup = function() {

	var originalAddTiddler = $tw.wiki.addTiddler;

	function processStampLogic(tiddler) {
		// --- SAFETY SHIELD ---
		// If it's not a real object, or doesn't have fields: skip.
		if(!tiddler || !tiddler.fields) {
			return tiddler;
		}

		var fieldUpdates = {};
		var hasFieldUpdates = false;

		// Helper to process a single string for stamps
		function processString(text, fieldName) {
			if(typeof text !== "string" || text.indexOf("stamp") === -1) {
				return { text: text, updates: {} };
			}

			// Dormancy Check (Fence)
			var fenceRegex = /(?:^|\n)\s*---+\s*(?:\n|$)/;
			var fenceMatch = fenceRegex.exec(text);
			var fenceIndex = fenceMatch ? fenceMatch.index : Infinity;

			// Stamp Regex (Flexible spaces)
			var stampRegex = /<<stamp\s*(?:"""([\s\S]*?)"""|"([^"]*)"|'([^']*)')(?:(?:\s+)(?:"""([\s\S]*?)"""|"([^"]*)"|'([^']*)'))?\s*>>/g;

			if(!stampRegex.test(text)) {
				return { text: text, updates: {} };
			}

			var localUpdates = {};
			stampRegex.lastIndex = 0;
			
			var newText = text.replace(stampRegex, function(match, c3, c2, c1, f3, f2, f1, offset) {
				if (offset > fenceIndex) return match;

				var contentToStamp = c3 || c2 || c1;
				var targetField = f3 || f2 || f1;
				if (!contentToStamp) return match;

				var renderedResult = "";
				try {
					renderedResult = $tw.wiki.renderText(
						"text/plain", 
						"text/vnd.tiddlywiki", 
						contentToStamp, 
						{ variables: { currentTiddler: tiddler.fields.title } }
					);
				} catch (e) {
					return match;
				}

				if (targetField) {
					localUpdates[targetField] = renderedResult;
					return "";
				}
				return renderedResult;
			});

			return { text: newText, updates: localUpdates };
		}

		// Iterate over all fields
		Object.keys(tiddler.fields).forEach(function(fieldName) {
			var value = tiddler.fields[fieldName];
			var result = processString(value, fieldName);

			// If text changed (in-place replacement or removal due to side-effect stamp)
			if(result.text !== value) {
				fieldUpdates[fieldName] = result.text;
				hasFieldUpdates = true;
			}

			// Apply side-effect updates
			Object.keys(result.updates).forEach(function(target) {
				// Only update if value is different from original
				if (tiddler.fields[target] !== result.updates[target]) {
					fieldUpdates[target] = result.updates[target];
					hasFieldUpdates = true;
				}
			});
		});

		if(hasFieldUpdates) {
			return new $tw.Tiddler(tiddler, fieldUpdates);
		}

		return tiddler;
	}

	// Override core function
	$tw.wiki.addTiddler = function(tiddler) {
		// Ensure we are working with the tiddler object
		var processedTiddler = processStampLogic(tiddler);
		return originalAddTiddler.call($tw.wiki, processedTiddler);
	};
};

})();