"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/.pnpm/lodash.debounce@4.0.8/node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "node_modules/.pnpm/lodash.debounce@4.0.8/node_modules/lodash.debounce/index.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = debounce2;
  }
});

// node_modules/.pnpm/tw-react@0.4.6_react-dom@18.2.0_react@18.2.0/node_modules/tw-react/dist/plugins/linonetwo/tw-react/index.js
var require_tw_react = __commonJS({
  "node_modules/.pnpm/tw-react@0.4.6_react-dom@18.2.0_react@18.2.0/node_modules/tw-react/dist/plugins/linonetwo/tw-react/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      ParentWidgetContext: () => ParentWidgetContext2,
      useFilter: () => useFilter,
      useRenderTiddler: () => useRenderTiddler,
      useWidget: () => useWidget2
    });
    module2.exports = __toCommonJS(src_exports);
    var import_react43 = require("react");
    function useFilter(twFilter, widget = $tw.rootWidget, dependencies = []) {
      const [filterResult, setFilterResult] = (0, import_react43.useState)([]);
      const compiledFilter = (0, import_react43.useMemo)(() => $tw.wiki.compileFilter(twFilter), [twFilter]);
      (0, import_react43.useEffect)(() => {
        setFilterResult(compiledFilter(void 0, widget));
      }, [compiledFilter, widget, ...dependencies]);
      return filterResult;
    }
    var import_react310 = require("react");
    var import_react210 = require("react");
    var ParentWidgetContext2 = (0, import_react210.createContext)(void 0);
    function useRenderTiddler(tiddlerTitle, containerReference, options) {
      const parentWidget = (0, import_react310.useContext)(ParentWidgetContext2);
      (0, import_react310.useEffect)(() => {
        const domNode = containerReference.current;
        if (domNode === null) {
          return;
        }
        if (parentWidget === void 0) {
          throw new Error(
            "Your plugin have a bug: `parentWidget` is undefined, you should use `<ParentWidgetContext.Provider value={props.parentWidget}>`, see tw-react for document."
          );
        }
        if (options?.skip === true) {
          return;
        }
        const id = String(Math.random());
        const transcludeWidgetNode = $tw.wiki.makeTranscludeWidget(tiddlerTitle, {
          document,
          parentWidget,
          recursionMarker: "yes",
          mode: "block",
          importPageMacros: true,
          variables: { "use-widget-id": id }
        });
        const tiddlerContainer = document.createElement("div");
        domNode.append(tiddlerContainer);
        transcludeWidgetNode.render(tiddlerContainer, null);
        parentWidget.children.push(transcludeWidgetNode);
        return () => {
          parentWidget.children = parentWidget.children.filter((child) => child.getVariable("use-widget-id") !== id);
          if (domNode === null) {
            return;
          }
          domNode.textContent = "";
        };
      }, [tiddlerTitle, containerReference]);
    }
    var import_react44 = require("react");
    function useWidget2(parseTreeNode, containerReference, options) {
      const parentWidget = (0, import_react44.useContext)(ParentWidgetContext2);
      (0, import_react44.useEffect)(() => {
        const domNode = containerReference.current;
        if (domNode === null) {
          return;
        }
        if (parentWidget === void 0) {
          throw new Error(
            "Your plugin have a bug: `parentWidget` is undefined, you should use `<ParentWidgetContext.Provider value={props.parentWidget}>`, see tw-react for document."
          );
        }
        if (options?.skip === true) {
          return;
        }
        const id = String(Math.random());
        const newWidgetNode = parentWidget.makeChildWidget(parseTreeNode, { variables: { "use-widget-id": id } });
        newWidgetNode.render(domNode, null);
        parentWidget.children.push(newWidgetNode);
        return () => {
          parentWidget.children = parentWidget.children.filter((child) => child.getVariable("use-widget-id") !== id);
          if (domNode === null) {
            return;
          }
          domNode.textContent = "";
        };
      }, [parseTreeNode, containerReference, parentWidget, options?.skip]);
    }
  }
});

// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React50 = require("react");
        var ReactSharedInternals = React50.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x5, y6) {
          return x5 === y6 && (x5 !== 0 || 1 / x5 === 1 / y6) || x5 !== x5 && y6 !== y6;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState16 = React50.useState, useEffect24 = React50.useEffect, useLayoutEffect12 = React50.useLayoutEffect, useDebugValue2 = React50.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React50.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState16({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect12(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect24(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue2(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
        var useSyncExternalStore$2 = React50.useSyncExternalStore !== void 0 ? React50.useSyncExternalStore : shim;
        exports2.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React50 = require("react");
        var shim = require_shim();
        function is(x5, y6) {
          return x5 === y6 && (x5 !== 0 || 1 / x5 === 1 / y6) || x5 !== x5 && y6 !== y6;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useSyncExternalStore = shim.useSyncExternalStore;
        var useRef26 = React50.useRef, useEffect24 = React50.useEffect, useMemo14 = React50.useMemo, useDebugValue2 = React50.useDebugValue;
        function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
          var instRef = useRef26(null);
          var inst;
          if (instRef.current === null) {
            inst = {
              hasValue: false,
              value: null
            };
            instRef.current = inst;
          } else {
            inst = instRef.current;
          }
          var _useMemo = useMemo14(function() {
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                var _nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0) {
                  if (inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, _nextSelection)) {
                      memoizedSelection = currentSelection;
                      return currentSelection;
                    }
                  }
                }
                memoizedSelection = _nextSelection;
                return _nextSelection;
              }
              var prevSnapshot = memoizedSnapshot;
              var prevSelection = memoizedSelection;
              if (objectIs(prevSnapshot, nextSnapshot)) {
                return prevSelection;
              }
              var nextSelection = selector(nextSnapshot);
              if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                return prevSelection;
              }
              memoizedSnapshot = nextSnapshot;
              memoizedSelection = nextSelection;
              return nextSelection;
            };
            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
              return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            };
            return [getSnapshotWithSelector, getServerSnapshotWithSelector];
          }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
          var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
          useEffect24(function() {
            inst.hasValue = true;
            inst.value = value;
          }, [value]);
          useDebugValue2(value);
          return value;
        }
        exports2.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/with-selector.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_with_selector_development();
    }
  }
});

// node_modules/.pnpm/requestidlecallback-polyfill@1.0.2/node_modules/requestidlecallback-polyfill/index.js
window.requestIdleCallback = window.requestIdleCallback || function(cb) {
  var start = Date.now();
  return setTimeout(function() {
    cb({
      didTimeout: false,
      timeRemaining: function() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
};
window.cancelIdleCallback = window.cancelIdleCallback || function(id) {
  clearTimeout(id);
};

// node_modules/.pnpm/beautiful-react-hooks@4.3.0_react-dom@18.2.0_react-router-dom@6.11.2_react@18.2.0_rxjs@7.8.1/node_modules/beautiful-react-hooks/esm/useDebouncedCallback.js
var import_react3 = require("react");
var import_lodash = __toESM(require_lodash());

// node_modules/.pnpm/beautiful-react-hooks@4.3.0_react-dom@18.2.0_react-router-dom@6.11.2_react@18.2.0_rxjs@7.8.1/node_modules/beautiful-react-hooks/esm/useWillUnmount.js
var import_react2 = require("react");

// node_modules/.pnpm/beautiful-react-hooks@4.3.0_react-dom@18.2.0_react-router-dom@6.11.2_react@18.2.0_rxjs@7.8.1/node_modules/beautiful-react-hooks/esm/shared/isFunction.js
var isFunction = (functionToCheck) => typeof functionToCheck === "function" && !!functionToCheck.constructor && !!functionToCheck.call && !!functionToCheck.apply;
var isFunction_default = isFunction;

// node_modules/.pnpm/beautiful-react-hooks@4.3.0_react-dom@18.2.0_react-router-dom@6.11.2_react@18.2.0_rxjs@7.8.1/node_modules/beautiful-react-hooks/esm/factory/createHandlerSetter.js
var import_react = require("react");
var createHandlerSetter = (callback) => {
  const handlerRef = (0, import_react.useRef)(callback);
  const setHandler = (0, import_react.useRef)((nextCallback) => {
    if (typeof nextCallback !== "function") {
      throw new Error("the argument supplied to the 'setHandler' function should be of type function");
    }
    handlerRef.current = nextCallback;
  });
  return [handlerRef, setHandler.current];
};
var createHandlerSetter_default = createHandlerSetter;

// node_modules/.pnpm/beautiful-react-hooks@4.3.0_react-dom@18.2.0_react-router-dom@6.11.2_react@18.2.0_rxjs@7.8.1/node_modules/beautiful-react-hooks/esm/useWillUnmount.js
var useWillUnmount = (callback) => {
  const mountRef = (0, import_react2.useRef)(false);
  const [handler, setHandler] = createHandlerSetter_default(callback);
  (0, import_react2.useEffect)(() => {
    mountRef.current = true;
    return () => {
      if (isFunction_default(handler === null || handler === void 0 ? void 0 : handler.current) && mountRef.current) {
        handler.current();
      }
    };
  }, []);
  return setHandler;
};
var useWillUnmount_default = useWillUnmount;

// node_modules/.pnpm/beautiful-react-hooks@4.3.0_react-dom@18.2.0_react-router-dom@6.11.2_react@18.2.0_rxjs@7.8.1/node_modules/beautiful-react-hooks/esm/useDebouncedCallback.js
var defaultOptions = {
  leading: false,
  trailing: true
};
var useDebouncedCallback = (fn2, dependencies, wait = 600, options = defaultOptions) => {
  const debounced = (0, import_react3.useRef)((0, import_lodash.default)(fn2, wait, options));
  (0, import_react3.useEffect)(() => {
    debounced.current = (0, import_lodash.default)(fn2, wait, options);
  }, [fn2, wait, options]);
  useWillUnmount_default(() => {
    var _a;
    (_a = debounced.current) === null || _a === void 0 ? void 0 : _a.cancel();
  });
  return (0, import_react3.useCallback)(debounced.current, dependencies !== null && dependencies !== void 0 ? dependencies : []);
};
var useDebouncedCallback_default = useDebouncedCallback;

// src/components/App.tsx
var import_react42 = require("react");
var import_tw_react2 = __toESM(require_tw_react());

// src/components/Tldraw/Tldraw.tsx
var React49 = __toESM(require("react"));

// node_modules/.pnpm/@tldraw+core@1.23.2_react-dom@18.2.0_react@18.2.0/node_modules/@tldraw/core/dist/index.mjs
var N2 = __toESM(require("react"), 1);
var D2 = __toESM(require("react"), 1);
var z2 = __toESM(require("react"), 1);
var Ye = __toESM(require("react"), 1);
var Se2 = __toESM(require("react"), 1);

// node_modules/.pnpm/@tldraw+vec@1.9.2/node_modules/@tldraw/vec/dist/index.mjs
var h = Object.defineProperty;
var d = (s5, n5, r5) => n5 in s5 ? h(s5, n5, { enumerable: true, configurable: true, writable: true, value: r5 }) : s5[n5] = r5;
var m = (s5, n5, r5) => (d(s5, typeof n5 != "symbol" ? n5 + "" : n5, r5), r5);
var t = class {
  static clamp(n5, r5, u5) {
    return Math.max(r5, typeof u5 != "undefined" ? Math.min(n5, u5) : n5);
  }
  static clampV(n5, r5, u5) {
    return n5.map((b6) => u5 ? t.clamp(b6, r5, u5) : t.clamp(b6, r5));
  }
  static cross(n5, r5, u5) {
    return (r5[0] - n5[0]) * (u5[1] - n5[1]) - (u5[0] - n5[0]) * (r5[1] - n5[1]);
  }
  static snap(n5, r5 = 1) {
    return [Math.round(n5[0] / r5) * r5, Math.round(n5[1] / r5) * r5];
  }
};
var e = t;
m(e, "neg", (n5) => [-n5[0], -n5[1]]), m(e, "add", (n5, r5) => [n5[0] + r5[0], n5[1] + r5[1]]), m(e, "addScalar", (n5, r5) => [n5[0] + r5, n5[1] + r5]), m(e, "sub", (n5, r5) => [n5[0] - r5[0], n5[1] - r5[1]]), m(e, "subScalar", (n5, r5) => [n5[0] - r5, n5[1] - r5]), m(e, "vec", (n5, r5) => [r5[0] - n5[0], r5[1] - n5[1]]), m(e, "mul", (n5, r5) => [n5[0] * r5, n5[1] * r5]), m(e, "mulV", (n5, r5) => [n5[0] * r5[0], n5[1] * r5[1]]), m(e, "div", (n5, r5) => [n5[0] / r5, n5[1] / r5]), m(e, "divV", (n5, r5) => [n5[0] / r5[0], n5[1] / r5[1]]), m(e, "per", (n5) => [n5[1], -n5[0]]), m(e, "dpr", (n5, r5) => n5[0] * r5[0] + n5[1] * r5[1]), m(e, "cpr", (n5, r5) => n5[0] * r5[1] - r5[0] * n5[1]), m(e, "len2", (n5) => n5[0] * n5[0] + n5[1] * n5[1]), m(e, "len", (n5) => Math.hypot(n5[0], n5[1])), m(e, "pry", (n5, r5) => t.dpr(n5, r5) / t.len(r5)), m(e, "uni", (n5) => t.div(n5, t.len(n5))), m(e, "normalize", (n5) => t.uni(n5)), m(e, "tangent", (n5, r5) => t.uni(t.sub(n5, r5))), m(e, "dist2", (n5, r5) => t.len2(t.sub(n5, r5))), m(e, "dist", (n5, r5) => Math.hypot(n5[1] - r5[1], n5[0] - r5[0])), m(e, "fastDist", (n5, r5) => {
  let u5 = [r5[0] - n5[0], r5[1] - n5[1]], b6 = [Math.abs(u5[0]), Math.abs(u5[1])], a7 = 1 / Math.max(b6[0], b6[1]);
  return a7 = a7 * (1.29289 - (b6[0] + b6[1]) * a7 * 0.29289), [u5[0] * a7, u5[1] * a7];
}), m(e, "ang", (n5, r5) => Math.atan2(t.cpr(n5, r5), t.dpr(n5, r5))), m(e, "angle", (n5, r5) => Math.atan2(r5[1] - n5[1], r5[0] - n5[0])), m(e, "med", (n5, r5) => t.mul(t.add(n5, r5), 0.5)), m(e, "rot", (n5, r5 = 0) => [n5[0] * Math.cos(r5) - n5[1] * Math.sin(r5), n5[0] * Math.sin(r5) + n5[1] * Math.cos(r5)]), m(e, "rotWith", (n5, r5, u5 = 0) => {
  if (u5 === 0)
    return n5;
  let b6 = Math.sin(u5), a7 = Math.cos(u5), i4 = n5[0] - r5[0], o5 = n5[1] - r5[1], c5 = i4 * a7 - o5 * b6, l7 = i4 * b6 + o5 * a7;
  return [c5 + r5[0], l7 + r5[1]];
}), m(e, "isEqual", (n5, r5) => n5[0] === r5[0] && n5[1] === r5[1]), m(e, "lrp", (n5, r5, u5) => t.add(n5, t.mul(t.sub(r5, n5), u5))), m(e, "int", (n5, r5, u5, b6, a7 = 1) => {
  let i4 = (t.clamp(u5, b6) - u5) / (b6 - u5);
  return t.add(t.mul(n5, 1 - i4), t.mul(r5, a7));
}), m(e, "ang3", (n5, r5, u5) => {
  let b6 = t.vec(r5, n5), a7 = t.vec(r5, u5);
  return t.ang(b6, a7);
}), m(e, "abs", (n5) => [Math.abs(n5[0]), Math.abs(n5[1])]), m(e, "rescale", (n5, r5) => {
  let u5 = t.len(n5);
  return [r5 * n5[0] / u5, r5 * n5[1] / u5];
}), m(e, "isLeft", (n5, r5, u5) => (r5[0] - n5[0]) * (u5[1] - n5[1]) - (u5[0] - n5[0]) * (r5[1] - n5[1])), m(e, "clockwise", (n5, r5, u5) => t.isLeft(n5, r5, u5) > 0), m(e, "toFixed", (n5) => n5.map((r5) => Math.round(r5 * 100) / 100)), m(e, "nearestPointOnLineThroughPoint", (n5, r5, u5) => t.add(n5, t.mul(r5, t.pry(t.sub(u5, n5), r5)))), m(e, "distanceToLineThroughPoint", (n5, r5, u5) => t.dist(u5, t.nearestPointOnLineThroughPoint(n5, r5, u5))), m(e, "nearestPointOnLineSegment", (n5, r5, u5, b6 = true) => {
  let a7 = t.uni(t.sub(r5, n5)), i4 = t.add(n5, t.mul(a7, t.pry(t.sub(u5, n5), a7)));
  if (b6) {
    if (i4[0] < Math.min(n5[0], r5[0]))
      return n5[0] < r5[0] ? n5 : r5;
    if (i4[0] > Math.max(n5[0], r5[0]))
      return n5[0] > r5[0] ? n5 : r5;
    if (i4[1] < Math.min(n5[1], r5[1]))
      return n5[1] < r5[1] ? n5 : r5;
    if (i4[1] > Math.max(n5[1], r5[1]))
      return n5[1] > r5[1] ? n5 : r5;
  }
  return i4;
}), m(e, "distanceToLineSegment", (n5, r5, u5, b6 = true) => t.dist(u5, t.nearestPointOnLineSegment(n5, r5, u5, b6))), m(e, "nearestPointOnBounds", (n5, r5) => [t.clamp(r5[0], n5.minX, n5.maxX), t.clamp(r5[1], n5.minY, n5.maxY)]), m(e, "distanceToBounds", (n5, r5) => t.dist(r5, t.nearestPointOnBounds(n5, r5))), m(e, "nudge", (n5, r5, u5) => t.isEqual(n5, r5) ? n5 : t.add(n5, t.mul(t.uni(t.sub(r5, n5)), u5))), m(e, "nudgeAtAngle", (n5, r5, u5) => [Math.cos(r5) * u5 + n5[0], Math.sin(r5) * u5 + n5[1]]), m(e, "toPrecision", (n5, r5 = 4) => [+n5[0].toPrecision(r5), +n5[1].toPrecision(r5)]), m(e, "pointsBetween", (n5, r5, u5 = 6) => Array.from(Array(u5)).map((b6, a7) => {
  let i4 = a7 / (u5 - 1), o5 = Math.min(1, 0.5 + Math.abs(0.5 - i4));
  return [...t.lrp(n5, r5, i4), o5];
})), m(e, "slope", (n5, r5) => n5[0] === r5[0] ? NaN : (n5[1] - r5[1]) / (n5[0] - r5[0])), m(e, "max", (...n5) => [Math.max(...n5.map((r5) => r5[0])), Math.max(...n5.map((r5) => r5[1]))]), m(e, "min", (...n5) => [Math.min(...n5.map((r5) => r5[0])), Math.min(...n5.map((r5) => r5[1]))]);
var p = e;

// node_modules/.pnpm/@use-gesture+core@10.2.23/node_modules/@use-gesture/core/dist/maths-b28d9b98.esm.js
function clamp(v6, min, max) {
  return Math.max(min, Math.min(v6, max));
}
var V = {
  toVector(v6, fallback) {
    if (v6 === void 0)
      v6 = fallback;
    return Array.isArray(v6) ? v6 : [v6, v6];
  },
  add(v1, v22) {
    return [v1[0] + v22[0], v1[1] + v22[1]];
  },
  sub(v1, v22) {
    return [v1[0] - v22[0], v1[1] - v22[1]];
  },
  addTo(v1, v22) {
    v1[0] += v22[0];
    v1[1] += v22[1];
  },
  subTo(v1, v22) {
    v1[0] -= v22[0];
    v1[1] -= v22[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity)
    return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {
  if (constant === 0)
    return clamp(position, min, max);
  if (position < min)
    return -rubberband(min - position, max - min, constant) + min;
  if (position > max)
    return +rubberband(position - max, max - min, constant) + max;
  return position;
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
  const [[X0, X1], [Y0, Y1]] = bounds;
  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
}

// node_modules/.pnpm/@use-gesture+core@10.2.23/node_modules/@use-gesture/core/dist/actions-e3d93fde.esm.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = null != arguments[i4] ? arguments[i4] : {};
    i4 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var EVENT_TYPE_MAP = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function capitalize(string) {
  if (!string)
    return "";
  return string[0].toUpperCase() + string.slice(1);
}
var actionsWithoutCaptureSupported = ["enter", "leave"];
function hasCapture(capture = false, actionKey) {
  return capture && !actionsWithoutCaptureSupported.includes(actionKey);
}
function toHandlerProp(device, action = "", capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
}
var pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
function parseProp(prop) {
  let eventKey = prop.substring(2).toLowerCase();
  const passive = !!~eventKey.indexOf("passive");
  if (passive)
    eventKey = eventKey.replace("passive", "");
  const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
  const capture = !!~eventKey.indexOf(captureKey);
  if (capture)
    eventKey = eventKey.replace("capture", "");
  return {
    device: eventKey,
    capture,
    passive
  };
}
function toDomEventType(device, action = "") {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return device + actionKey;
}
function isTouch(event) {
  return "touches" in event;
}
function getPointerType(event) {
  if (isTouch(event))
    return "touch";
  if ("pointerType" in event)
    return event.pointerType;
  return "mouse";
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter((e5) => {
    var _event$currentTarget, _event$currentTarget$;
    return e5.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e5.target));
  });
}
function getTouchList(event) {
  return event.type === "touchend" || event.type === "touchcancel" ? event.changedTouches : event.targetTouches;
}
function getValueEvent(event) {
  return isTouch(event) ? getTouchList(event)[0] : event;
}
function distanceAngle(P1, P22) {
  const dx = P22.clientX - P1.clientX;
  const dy = P22.clientY - P1.clientY;
  const cx = (P22.clientX + P1.clientX) / 2;
  const cy = (P22.clientY + P1.clientY) / 2;
  const distance = Math.hypot(dx, dy);
  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
  const origin = [cx, cy];
  return {
    angle,
    distance,
    origin
  };
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P1, P22] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
  return distanceAngle(P1, P22);
}
function pointerId(event) {
  const valueEvent = getValueEvent(event);
  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
}
function pointerValues(event) {
  const valueEvent = getValueEvent(event);
  return [valueEvent.clientX, valueEvent.clientY];
}
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function wheelValues(event) {
  let {
    deltaX,
    deltaY,
    deltaMode
  } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function scrollValues(event) {
  var _ref, _ref2;
  const {
    scrollX,
    scrollY,
    scrollLeft,
    scrollTop
  } = event.currentTarget;
  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];
}
function getEventDetails(event) {
  const payload = {};
  if ("buttons" in event)
    payload.buttons = event.buttons;
  if ("shiftKey" in event) {
    const {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    } = event;
    Object.assign(payload, {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    });
  }
  return payload;
}
function call(v6, ...args) {
  if (typeof v6 === "function") {
    return v6(...args);
  } else {
    return v6;
  }
}
function noop() {
}
function chain(...fns) {
  if (fns.length === 0)
    return noop;
  if (fns.length === 1)
    return fns[0];
  return function() {
    let result;
    for (const fn2 of fns) {
      result = fn2.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}
var BEFORE_LAST_KINEMATICS_DELAY = 32;
var Engine = class {
  constructor(ctrl, args, key) {
    this.ctrl = ctrl;
    this.args = args;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init)
        this.init();
      this.reset();
    }
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state,
      shared,
      ingKey,
      args
    } = this;
    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._direction = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args;
    state.axis = void 0;
    state.memo = void 0;
    state.elapsedTime = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.overflow = [0, 0];
    state._movementBound = [false, false];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  start(event) {
    const state = this.state;
    const config = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config.from ? call(config.from, state) : state.offset;
      state.offset = state.lastOffset;
    }
    state.startTime = state.timeStamp = event.timeStamp;
  }
  computeValues(values) {
    const state = this.state;
    state._values = values;
    state.values = this.config.transform(values);
  }
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  compute(event) {
    const {
      state,
      config,
      shared
    } = this;
    state.args = this.args;
    let dt2 = 0;
    if (event) {
      state.event = event;
      if (config.preventDefault && event.cancelable)
        state.event.preventDefault();
      state.type = event.type;
      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared.locked = !!document.pointerLockElement;
      Object.assign(shared, getEventDetails(event));
      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
      dt2 = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      V.addTo(state._distance, _absoluteDelta);
    }
    if (this.axisIntent)
      this.axisIntent(event);
    const [_m0, _m1] = state._movement;
    const [t0, t1] = config.threshold;
    const {
      _step,
      values
    } = state;
    if (config.hasCustomTransform) {
      if (_step[0] === false)
        _step[0] = Math.abs(_m0) >= t0 && values[0];
      if (_step[1] === false)
        _step[1] = Math.abs(_m1) >= t1 && values[1];
    } else {
      if (_step[0] === false)
        _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
      if (_step[1] === false)
        _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
    }
    state.intentional = _step[0] !== false || _step[1] !== false;
    if (!state.intentional)
      return;
    const movement = [0, 0];
    if (config.hasCustomTransform) {
      const [v0, v1] = values;
      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.restrictToAxis && !state._blocked)
      this.restrictToAxis(movement);
    const previousOffset = state.offset;
    const gestureIsActive = state._active && !state._blocked || state.active;
    if (gestureIsActive) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ("bounds" in config)
            state._bounds = call(config.bounds, state);
          if (this.setup)
            this.setup();
        }
        state.movement = movement;
        this.computeOffset();
      }
    }
    const [ox, oy] = state.offset;
    const [[x0, x1], [y0, y1]] = state._bounds;
    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
    const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0];
    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
    state.delta = V.sub(state.offset, previousOffset);
    this.computeMovement();
    if (gestureIsActive && (!state.last || dt2 > BEFORE_LAST_KINEMATICS_DELAY)) {
      state.delta = V.sub(state.offset, previousOffset);
      const absoluteDelta = state.delta.map(Math.abs);
      V.addTo(state.distance, absoluteDelta);
      state.direction = state.delta.map(Math.sign);
      state._direction = state._delta.map(Math.sign);
      if (!state.first && dt2 > 0) {
        state.velocity = [absoluteDelta[0] / dt2, absoluteDelta[1] / dt2];
      }
    }
  }
  emit() {
    const state = this.state;
    const shared = this.shared;
    const config = this.config;
    if (!state._active)
      this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents)
      return;
    const memo45 = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
      [this.aliasKey]: state.values
    }));
    if (memo45 !== void 0)
      state.memo = memo45;
  }
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
};
function selectAxis([dx, dy], threshold) {
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  if (absDx > absDy && absDx > threshold) {
    return "x";
  }
  if (absDy > absDx && absDy > threshold) {
    return "y";
  }
  return void 0;
}
var CoordinatesEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "aliasKey", "xy");
  }
  reset() {
    super.reset();
    this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = V.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(event) {
    const state = this.state;
    const config = this.config;
    if (!state.axis && event) {
      const threshold = typeof config.axisThreshold === "object" ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;
      state.axis = selectAxis(state._movement, threshold);
    }
    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;
  }
  restrictToAxis(v6) {
    if (this.config.axis || this.config.lockDirection) {
      switch (this.state.axis) {
        case "x":
          v6[1] = 0;
          break;
        case "y":
          v6[0] = 0;
          break;
      }
    }
  }
};
var identity = (v6) => v6;
var DEFAULT_RUBBERBAND = 0.15;
var commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  eventOptions(value, _k, config) {
    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return V.toVector(value);
    }
  },
  from(value) {
    if (typeof value === "function")
      return value;
    if (value != null)
      return V.toVector(value);
  },
  transform(value, _k, config) {
    const transform = value || config.shared.transform;
    this.hasCustomTransform = !!transform;
    if (true) {
      const originalTransform = transform || identity;
      return (v6) => {
        const r5 = originalTransform(v6);
        if (!isFinite(r5[0]) || !isFinite(r5[1])) {
          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r5[0]},${[1]}]`);
        }
        return r5;
      };
    }
    return transform || identity;
  },
  threshold(value) {
    return V.toVector(value, 0);
  }
};
if (true) {
  Object.assign(commonConfigResolver, {
    domTarget(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
      }
      return NaN;
    },
    lockDirection(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
      }
      return NaN;
    },
    initial(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
      }
      return NaN;
    }
  });
}
var DEFAULT_AXIS_THRESHOLD = 0;
var coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  axis(_v, _k, {
    axis
  }) {
    this.lockDirection = axis === "lock";
    if (!this.lockDirection)
      return axis;
  },
  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
    return value;
  },
  bounds(value = {}) {
    if (typeof value === "function") {
      return (state) => coordinatesConfigResolver.bounds(value(state));
    }
    if ("current" in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return value;
    }
    const {
      left = -Infinity,
      right = Infinity,
      top: top2 = -Infinity,
      bottom = Infinity
    } = value;
    return [[left, right], [top2, bottom]];
  }
});
var DISPLACEMENT = 10;
var KEYS_DELTA_MAP = {
  ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],
  ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],
  ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],
  ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]
};
var DragEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const state = this.state;
    state._pointerId = void 0;
    state._pointerActive = false;
    state._keyboardActive = false;
    state._preventScroll = false;
    state._delayed = false;
    state.swipe = [0, 0];
    state.tap = false;
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
  }
  setup() {
    const state = this.state;
    if (state._bounds instanceof HTMLElement) {
      const boundRect = state._bounds.getBoundingClientRect();
      const targetRect = state.currentTarget.getBoundingClientRect();
      const _bounds = {
        left: boundRect.left - targetRect.left + state.offset[0],
        right: boundRect.right - targetRect.right + state.offset[0],
        top: boundRect.top - targetRect.top + state.offset[1],
        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
      };
      state._bounds = coordinatesConfigResolver.bounds(_bounds);
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled)
      return;
    state.canceled = true;
    state._active = false;
    setTimeout(() => {
      this.compute();
      this.emit();
    }, 0);
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean();
    this.state._pointerActive = false;
    this.state._keyboardActive = false;
    super.clean();
  }
  pointerDown(event) {
    const config = this.config;
    const state = this.state;
    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons))
      return;
    const ctrlIds = this.ctrl.setEventIds(event);
    if (config.pointerCapture) {
      event.target.setPointerCapture(event.pointerId);
    }
    if (ctrlIds && ctrlIds.size > 1 && state._pointerActive)
      return;
    this.start(event);
    this.setupPointer(event);
    state._pointerId = pointerId(event);
    state._pointerActive = true;
    this.computeValues(pointerValues(event));
    this.computeInitial();
    if (config.preventScrollAxis && getPointerType(event) !== "mouse") {
      state._active = false;
      this.setupScrollPrevention(event);
    } else if (config.delay > 0) {
      this.setupDelayTrigger(event);
      if (config.triggerAllEvents) {
        this.compute(event);
        this.emit();
      }
    } else {
      this.startPointerDrag(event);
    }
  }
  startPointerDrag(event) {
    const state = this.state;
    state._active = true;
    state._preventScroll = true;
    state._delayed = false;
    this.compute(event);
    this.emit();
  }
  pointerMove(event) {
    const state = this.state;
    const config = this.config;
    if (!state._pointerActive)
      return;
    if (state.type === event.type && event.timeStamp === state.timeStamp)
      return;
    const id = pointerId(event);
    if (state._pointerId !== void 0 && id !== state._pointerId)
      return;
    const _values = pointerValues(event);
    if (document.pointerLockElement === event.target) {
      state._delta = [event.movementX, event.movementY];
    } else {
      state._delta = V.sub(_values, state._values);
      this.computeValues(_values);
    }
    V.addTo(state._movement, state._delta);
    this.compute(event);
    if (state._delayed && state.intentional) {
      this.timeoutStore.remove("dragDelay");
      state.active = false;
      this.startPointerDrag(event);
      return;
    }
    if (config.preventScrollAxis && !state._preventScroll) {
      if (state.axis) {
        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === "xy") {
          state._active = false;
          this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag");
          this.startPointerDrag(event);
          return;
        }
      } else {
        return;
      }
    }
    this.emit();
  }
  pointerUp(event) {
    this.ctrl.setEventIds(event);
    try {
      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
        ;
        event.target.releasePointerCapture(event.pointerId);
      }
    } catch (_unused) {
      if (true) {
        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \`@react-three/fiber\`. 

Please upgrade to the latest version.`);
      }
    }
    const state = this.state;
    const config = this.config;
    if (!state._active || !state._pointerActive)
      return;
    const id = pointerId(event);
    if (state._pointerId !== void 0 && id !== state._pointerId)
      return;
    this.state._pointerActive = false;
    this.setActive();
    this.compute(event);
    const [dx, dy] = state._distance;
    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;
    if (state.tap && config.filterTaps) {
      state._force = true;
    } else {
      const [dirx, diry] = state.direction;
      const [vx, vy] = state.velocity;
      const [mx, my] = state.movement;
      const [svx, svy] = config.swipe.velocity;
      const [sx, sy] = config.swipe.distance;
      const sdt = config.swipe.duration;
      if (state.elapsedTime < sdt) {
        if (Math.abs(vx) > svx && Math.abs(mx) > sx)
          state.swipe[0] = dirx;
        if (Math.abs(vy) > svy && Math.abs(my) > sy)
          state.swipe[1] = diry;
      }
    }
    this.emit();
  }
  pointerClick(event) {
    if (!this.state.tap && event.detail > 0) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  setupPointer(event) {
    const config = this.config;
    const device = config.device;
    if (true) {
      try {
        if (device === "pointer" && config.preventScrollDelay === void 0) {
          const currentTarget = "uv" in event ? event.sourceEvent.currentTarget : event.currentTarget;
          const style = window.getComputedStyle(currentTarget);
          if (style.touchAction === "auto") {
            console.warn(`[@use-gesture]: The drag target has its \`touch-action\` style property set to \`auto\`. It is recommended to add \`touch-action: 'none'\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.

This message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);
          }
        }
      } catch (_unused2) {
      }
    }
    if (config.pointerLock) {
      event.currentTarget.requestPointerLock();
    }
    if (!config.pointerCapture) {
      this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "cancel", this.pointerUp.bind(this));
    }
  }
  pointerClean() {
    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
      document.exitPointerLock();
    }
  }
  preventScroll(event) {
    if (this.state._preventScroll && event.cancelable) {
      event.preventDefault();
    }
  }
  setupScrollPrevention(event) {
    this.state._preventScroll = false;
    persistEvent(event);
    const remove = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: false
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", remove);
    this.eventStore.add(this.sharedConfig.window, "touch", "cancel", remove);
    this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);
  }
  setupDelayTrigger(event) {
    this.state._delayed = true;
    this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0];
      this.startPointerDrag(event);
    }, this.config.delay);
  }
  keyDown(event) {
    const deltaFn = KEYS_DELTA_MAP[event.key];
    if (deltaFn) {
      const state = this.state;
      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
      this.start(event);
      state._delta = deltaFn(factor);
      state._keyboardActive = true;
      V.addTo(state._movement, state._delta);
      this.compute(event);
      this.emit();
    }
  }
  keyUp(event) {
    if (!(event.key in KEYS_DELTA_MAP))
      return;
    this.state._keyboardActive = false;
    this.setActive();
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    bindFunction(device, "start", this.pointerDown.bind(this));
    if (this.config.pointerCapture) {
      bindFunction(device, "change", this.pointerMove.bind(this));
      bindFunction(device, "end", this.pointerUp.bind(this));
      bindFunction(device, "cancel", this.pointerUp.bind(this));
      bindFunction("lostPointerCapture", "", this.pointerUp.bind(this));
    }
    if (this.config.keys) {
      bindFunction("key", "down", this.keyDown.bind(this));
      bindFunction("key", "up", this.keyUp.bind(this));
    }
    if (this.config.filterTaps) {
      bindFunction("click", "", this.pointerClick.bind(this), {
        capture: true,
        passive: false
      });
    }
  }
};
function persistEvent(event) {
  "persist" in event && typeof event.persist === "function" && event.persist();
}
var isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
  return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e5) {
    return false;
  }
}
var SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  touch: isTouchScreen(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};
var DEFAULT_PREVENT_SCROLL_DELAY = 250;
var DEFAULT_DRAG_DELAY = 180;
var DEFAULT_SWIPE_VELOCITY = 0.5;
var DEFAULT_SWIPE_DISTANCE = 50;
var DEFAULT_SWIPE_DURATION = 250;
var DEFAULT_DRAG_AXIS_THRESHOLD = {
  mouse: 0,
  touch: 0,
  pen: 8
};
var dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  device(_v, _k, {
    pointer: {
      touch = false,
      lock = false,
      mouse = false
    } = {}
  }) {
    this.pointerLock = lock && SUPPORT.pointerLock;
    if (SUPPORT.touch && touch)
      return "touch";
    if (this.pointerLock)
      return "mouse";
    if (SUPPORT.pointer && !mouse)
      return "pointer";
    if (SUPPORT.touch)
      return "touch";
    return "mouse";
  },
  preventScrollAxis(value, _k, {
    preventScroll
  }) {
    this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
    if (!SUPPORT.touchscreen || preventScroll === false)
      return void 0;
    return value ? value : preventScroll !== void 0 ? "y" : void 0;
  },
  pointerCapture(_v, _k, {
    pointer: {
      capture = true,
      buttons = 1,
      keys = true
    } = {}
  }) {
    this.pointerButtons = buttons;
    this.keys = keys;
    return !this.pointerLock && this.device === "pointer" && capture;
  },
  threshold(value, _k, {
    filterTaps = false,
    tapsThreshold = 3,
    axis = void 0
  }) {
    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    this.tapsThreshold = tapsThreshold;
    return threshold;
  },
  swipe({
    velocity = DEFAULT_SWIPE_VELOCITY,
    distance = DEFAULT_SWIPE_DISTANCE,
    duration = DEFAULT_SWIPE_DURATION
  } = {}) {
    return {
      velocity: this.transform(V.toVector(velocity)),
      distance: this.transform(V.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  },
  axisThreshold(value) {
    if (!value)
      return DEFAULT_DRAG_AXIS_THRESHOLD;
    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
  }
});
if (true) {
  Object.assign(dragConfigResolver, {
    useTouch(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
      }
      return NaN;
    },
    experimental_preventWindowScrollY(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
      }
      return NaN;
    },
    swipeVelocity(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
      }
      return NaN;
    },
    swipeDistance(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
      }
      return NaN;
    },
    swipeDuration(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
      }
      return NaN;
    }
  });
}
function clampStateInternalMovementToBounds(state) {
  const [ox, oy] = state.overflow;
  const [dx, dy] = state._delta;
  const [dirx, diry] = state._direction;
  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
    state._movement[0] = state._movementBound[0];
  }
  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
    state._movement[1] = state._movementBound[1];
  }
}
var SCALE_ANGLE_RATIO_INTENT_DEG = 30;
var PINCH_WHEEL_RATIO = 100;
var PinchEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "pinching");
    _defineProperty(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const {
      type,
      movement,
      lastOffset
    } = this.state;
    if (type === "wheel") {
      this.state.offset = V.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const {
      offset,
      lastOffset
    } = this.state;
    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];
  }
  axisIntent() {
    const state = this.state;
    const [_m0, _m1] = state._movement;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
      if (axisMovementDifference < 0)
        state.axis = "angle";
      else if (axisMovementDifference > 0)
        state.axis = "scale";
    }
  }
  restrictToAxis(v6) {
    if (this.config.lockDirection) {
      if (this.state.axis === "scale")
        v6[1] = 0;
      else if (this.state.axis === "angle")
        v6[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled)
      return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every((id) => ctrlTouchIds.has(id)))
        return;
    }
    if (ctrlTouchIds.size < 2)
      return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1)
      return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id)))
        return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2)
      return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active)
      return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active)
      return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270)
      delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active)
      return;
    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch (_unused) {
    }
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active)
      return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable)
      event.preventDefault();
    const state = this.state;
    if (state._active)
      return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable)
      event.preventDefault();
    if (!this.state._active)
      return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = V.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    const modifierKey = this.config.modifierKey;
    if (modifierKey && !event[modifierKey])
      return;
    if (!this.state._active)
      this.wheelStart(event);
    else
      this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = "uv" in event;
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
      if (!event.defaultPrevented) {
        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.

This message will only appear in development mode.`);
      }
    }
    const state = this.state;
    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, "start", this[device + "Start"].bind(this));
      bindFunction(device, "change", this[device + "Move"].bind(this));
      bindFunction(device, "end", this[device + "End"].bind(this));
      bindFunction(device, "cancel", this[device + "End"].bind(this));
    }
    if (this.config.pinchOnWheel) {
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
};
var pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  device(_v, _k, {
    shared,
    pointer: {
      touch = false
    } = {}
  }) {
    const sharedConfig = shared;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture)
      return "gesture";
    if (SUPPORT.touch && touch)
      return "touch";
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer)
        return "pointer";
      if (SUPPORT.touch)
        return "touch";
    }
  },
  bounds(_v, _k, {
    scaleBounds = {},
    angleBounds = {}
  }) {
    const _scaleBounds = (state) => {
      const D6 = assignDefault(call(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D6.min, D6.max];
    };
    const _angleBounds = (state) => {
      const A6 = assignDefault(call(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A6.min, A6.max];
    };
    if (typeof scaleBounds !== "function" && typeof angleBounds !== "function")
      return [_scaleBounds(), _angleBounds()];
    return (state) => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k, config) {
    this.lockDirection = config.axis === "lock";
    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  },
  modifierKey(value) {
    if (value === void 0)
      return "ctrlKey";
    return value;
  },
  pinchOnWheel(value = true) {
    return value;
  }
});
var MoveEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "moving");
  }
  move(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    if (!this.state._active)
      this.moveStart(event);
    else
      this.moveChange(event);
    this.timeoutStore.add("moveEnd", this.moveEnd.bind(this));
  }
  moveStart(event) {
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.computeInitial();
    this.emit();
  }
  moveChange(event) {
    if (!this.state._active)
      return;
    const values = pointerValues(event);
    const state = this.state;
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  moveEnd(event) {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "change", this.move.bind(this));
    bindFunction("pointer", "leave", this.moveEnd.bind(this));
  }
};
var moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var ScrollEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "scrolling");
  }
  scroll(event) {
    if (!this.state._active)
      this.start(event);
    this.scrollChange(event);
    this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this));
  }
  scrollChange(event) {
    if (event.cancelable)
      event.preventDefault();
    const state = this.state;
    const values = scrollValues(event);
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  scrollEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("scroll", "", this.scroll.bind(this));
  }
};
var scrollConfigResolver = coordinatesConfigResolver;
var WheelEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "wheeling");
  }
  wheel(event) {
    if (!this.state._active)
      this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("wheel", "", this.wheel.bind(this));
  }
};
var wheelConfigResolver = coordinatesConfigResolver;
var HoverEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "hovering");
  }
  enter(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.emit();
  }
  leave(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    const state = this.state;
    if (!state._active)
      return;
    state._active = false;
    const values = pointerValues(event);
    state._movement = state._delta = V.sub(values, state._values);
    this.computeValues(values);
    this.compute(event);
    state.delta = state.movement;
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "enter", this.enter.bind(this));
    bindFunction("pointer", "leave", this.leave.bind(this));
  }
};
var hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var EngineMap = /* @__PURE__ */ new Map();
var ConfigResolverMap = /* @__PURE__ */ new Map();
function registerAction(action) {
  EngineMap.set(action.key, action.engine);
  ConfigResolverMap.set(action.key, action.resolver);
}
var dragAction = {
  key: "drag",
  engine: DragEngine,
  resolver: dragConfigResolver
};
var hoverAction = {
  key: "hover",
  engine: HoverEngine,
  resolver: hoverConfigResolver
};
var moveAction = {
  key: "move",
  engine: MoveEngine,
  resolver: moveConfigResolver
};
var pinchAction = {
  key: "pinch",
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
var scrollAction = {
  key: "scroll",
  engine: ScrollEngine,
  resolver: scrollConfigResolver
};
var wheelAction = {
  key: "wheel",
  engine: WheelEngine,
  resolver: wheelConfigResolver
};

// node_modules/.pnpm/@use-gesture+react@10.2.23_react@18.2.0/node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
var import_react4 = __toESM(require("react"));

// node_modules/.pnpm/@use-gesture+core@10.2.23/node_modules/@use-gesture/core/dist/use-gesture-core.esm.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i4;
  for (i4 = 0; i4 < sourceKeys.length; i4++) {
    key = sourceKeys[i4];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i4;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i4 = 0; i4 < sourceSymbolKeys.length; i4++) {
      key = sourceSymbolKeys[i4];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => "current" in value ? value.current : value;
    }
    return void 0;
  },
  enabled(value = true) {
    return value;
  },
  window(value = SUPPORT.isBrowser ? window : void 0) {
    return value;
  },
  eventOptions({
    passive = true,
    capture = false
  } = {}) {
    return {
      passive,
      capture
    };
  },
  transform(value) {
    return value;
  }
};
var _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(config = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    switch (typeof resolver) {
      case "function":
        if (true) {
          const r5 = resolver.call(result, config[key], key, config);
          if (!Number.isNaN(r5))
            result[key] = r5;
        } else {
          result[key] = resolver.call(result, config[key], key, config);
        }
        break;
      case "object":
        result[key] = resolveWith(config[key], resolver);
        break;
      case "boolean":
        if (resolver)
          result[key] = config[key];
        break;
    }
  }
  return result;
}
function parse(newConfig, gestureKey, _config = {}) {
  const _ref = newConfig, {
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  } = _ref, rest = _objectWithoutProperties(_ref, _excluded);
  _config.shared = resolveWith({
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  }, sharedConfigResolver);
  if (gestureKey) {
    const resolver = ConfigResolverMap.get(gestureKey);
    _config[gestureKey] = resolveWith(_objectSpread2({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (const key in rest) {
      const resolver = ConfigResolverMap.get(key);
      if (resolver) {
        _config[key] = resolveWith(_objectSpread2({
          shared: _config.shared
        }, rest[key]), resolver);
      } else if (true) {
        if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key)) {
          if (key === "domTarget") {
            throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
          }
          console.warn(`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`);
        }
      }
    }
  }
  return _config;
}
var EventStore = class {
  constructor(ctrl, gestureKey) {
    _defineProperty(this, "_listeners", /* @__PURE__ */ new Set());
    this._ctrl = ctrl;
    this._gestureKey = gestureKey;
  }
  add(element, device, action, handler, options) {
    const listeners = this._listeners;
    const type = toDomEventType(device, action);
    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
    const eventOptions = _objectSpread2(_objectSpread2({}, _options), options);
    element.addEventListener(type, handler, eventOptions);
    const remove = () => {
      element.removeEventListener(type, handler, eventOptions);
      listeners.delete(remove);
    };
    listeners.add(remove);
    return remove;
  }
  clean() {
    this._listeners.forEach((remove) => remove());
    this._listeners.clear();
  }
};
var TimeoutStore = class {
  constructor() {
    _defineProperty(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(key, callback, ms = 140, ...args) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
  }
  remove(key) {
    const timeout = this._timeouts.get(key);
    if (timeout)
      window.clearTimeout(timeout);
  }
  clean() {
    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
    this._timeouts.clear();
  }
};
var Controller = class {
  constructor(handlers) {
    _defineProperty(this, "gestures", /* @__PURE__ */ new Set());
    _defineProperty(this, "_targetEventStore", new EventStore(this));
    _defineProperty(this, "gestureEventStores", {});
    _defineProperty(this, "gestureTimeoutStores", {});
    _defineProperty(this, "handlers", {});
    _defineProperty(this, "config", {});
    _defineProperty(this, "pointerIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "touchIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });
    resolveGestures(this, handlers);
  }
  setEventIds(event) {
    if (isTouch(event)) {
      this.touchIds = new Set(touchIds(event));
      return this.touchIds;
    } else if ("pointerId" in event) {
      if (event.type === "pointerup" || event.type === "pointercancel")
        this.pointerIds.delete(event.pointerId);
      else if (event.type === "pointerdown")
        this.pointerIds.add(event.pointerId);
      return this.pointerIds;
    }
  }
  applyHandlers(handlers, nativeHandlers) {
    this.handlers = handlers;
    this.nativeHandlers = nativeHandlers;
  }
  applyConfig(config, gestureKey) {
    this.config = parse(config, gestureKey, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  effect() {
    if (this.config.shared.target)
      this.bind();
    return () => this._targetEventStore.clean();
  }
  bind(...args) {
    const sharedConfig = this.config.shared;
    const props = {};
    let target;
    if (sharedConfig.target) {
      target = sharedConfig.target();
      if (!target)
        return;
    }
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        const gestureConfig = this.config[gestureKey];
        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
        if (gestureConfig.enabled) {
          const Engine2 = EngineMap.get(gestureKey);
          new Engine2(this, args, gestureKey).bind(bindFunction);
        }
      }
      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
      for (const eventKey in this.nativeHandlers) {
        nativeBindFunction(
          eventKey,
          "",
          (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
            event,
            args
          })),
          void 0,
          true
        );
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = chain(...props[handlerProp]);
    }
    if (!target)
      return props;
    for (const handlerProp in props) {
      const {
        device,
        capture,
        passive
      } = parseProp(handlerProp);
      this._targetEventStore.add(target, device, "", props[handlerProp], {
        capture,
        passive
      });
    }
  }
};
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag)
    setupGesture(ctrl, "drag");
  if (internalHandlers.wheel)
    setupGesture(ctrl, "wheel");
  if (internalHandlers.scroll)
    setupGesture(ctrl, "scroll");
  if (internalHandlers.move)
    setupGesture(ctrl, "move");
  if (internalHandlers.pinch)
    setupGesture(ctrl, "pinch");
  if (internalHandlers.hover)
    setupGesture(ctrl, "hover");
}
var bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
  var _options$capture, _options$passive;
  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
  if (withPassiveOption && passive)
    handlerProp += "Passive";
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};
var RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers) {
  const native = {};
  const handlers = {};
  const actions = /* @__PURE__ */ new Set();
  for (let key in _handlers) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers[key] = _handlers[key];
    } else {
      native[key] = _handlers[key];
    }
  }
  return [handlers, native, actions];
}
function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {
  if (!actions.has(handlerKey))
    return;
  if (!EngineMap.has(key)) {
    if (true) {
      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.

Please add \`${key}Action\` when creating your handler.`);
    }
    return;
  }
  const startKey = handlerKey + "Start";
  const endKey = handlerKey + "End";
  const fn2 = (state) => {
    let memo45 = void 0;
    if (state.first && startKey in handlers)
      handlers[startKey](state);
    if (handlerKey in handlers)
      memo45 = handlers[handlerKey](state);
    if (state.last && endKey in handlers)
      handlers[endKey](state);
    return memo45;
  };
  internalHandlers[key] = fn2;
  config[key] = config[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers, "onDrag", "drag", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onWheel", "wheel", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onScroll", "scroll", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onPinch", "pinch", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onMove", "move", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onHover", "hover", internalHandlers, mergedConfig);
  return {
    handlers: internalHandlers,
    config: mergedConfig,
    nativeHandlers
  };
}

// node_modules/.pnpm/@use-gesture+react@10.2.23_react@18.2.0/node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
function useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {
  const ctrl = import_react4.default.useMemo(() => new Controller(handlers), []);
  ctrl.applyHandlers(handlers, nativeHandlers);
  ctrl.applyConfig(config, gestureKey);
  import_react4.default.useEffect(ctrl.effect.bind(ctrl));
  import_react4.default.useEffect(() => {
    return ctrl.clean.bind(ctrl);
  }, []);
  if (config.target === void 0) {
    return ctrl.bind.bind(ctrl);
  }
  return void 0;
}
function createUseGesture(actions) {
  actions.forEach(registerAction);
  return function useGesture2(_handlers, _config) {
    const {
      handlers,
      nativeHandlers,
      config
    } = parseMergedHandlers(_handlers, _config || {});
    return useRecognizers(handlers, config, void 0, nativeHandlers);
  };
}
function useGesture(handlers, config) {
  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);
  return hook(handlers, config || {});
}

// node_modules/.pnpm/@tldraw+core@1.23.2_react-dom@18.2.0_react@18.2.0/node_modules/@tldraw/core/dist/index.mjs
var V4 = __toESM(require("react"), 1);
var import_react6 = require("react");
var ot = __toESM(require("react"), 1);
var Me = __toESM(require("react"), 1);
var ye2 = __toESM(require("react"), 1);
var ve = __toESM(require("react"), 1);
var pe3 = __toESM(require("react"), 1);
var xe2 = __toESM(require("react"), 1);
var ut = __toESM(require("react"), 1);
var pt = __toESM(require("react"), 1);
var ft = __toESM(require("react"), 1);
var gt = __toESM(require("react"), 1);
var Ke = __toESM(require("react"), 1);
var yt = __toESM(require("react"), 1);
var xt = __toESM(require("react"), 1);
var W2 = __toESM(require("react"), 1);

// node_modules/.pnpm/perfect-freehand@1.2.0/node_modules/perfect-freehand/dist/esm/index.js
function $(e5, t5, u5, x5 = (h6) => h6) {
  return e5 * x5(0.5 - t5 * (0.5 - u5));
}
function se(e5) {
  return [-e5[0], -e5[1]];
}
function l(e5, t5) {
  return [e5[0] + t5[0], e5[1] + t5[1]];
}
function a(e5, t5) {
  return [e5[0] - t5[0], e5[1] - t5[1]];
}
function b(e5, t5) {
  return [e5[0] * t5, e5[1] * t5];
}
function he(e5, t5) {
  return [e5[0] / t5, e5[1] / t5];
}
function R(e5) {
  return [e5[1], -e5[0]];
}
function B(e5, t5) {
  return e5[0] * t5[0] + e5[1] * t5[1];
}
function ue(e5, t5) {
  return e5[0] === t5[0] && e5[1] === t5[1];
}
function ge(e5) {
  return Math.hypot(e5[0], e5[1]);
}
function de(e5) {
  return e5[0] * e5[0] + e5[1] * e5[1];
}
function A(e5, t5) {
  return de(a(e5, t5));
}
function G(e5) {
  return he(e5, ge(e5));
}
function ie(e5, t5) {
  return Math.hypot(e5[1] - t5[1], e5[0] - t5[0]);
}
function L(e5, t5, u5) {
  let x5 = Math.sin(u5), h6 = Math.cos(u5), y6 = e5[0] - t5[0], n5 = e5[1] - t5[1], f5 = y6 * h6 - n5 * x5, d6 = y6 * x5 + n5 * h6;
  return [f5 + t5[0], d6 + t5[1]];
}
function K(e5, t5, u5) {
  return l(e5, b(a(t5, e5), u5));
}
function ee(e5, t5, u5) {
  return l(e5, b(t5, u5));
}
var { min: C, PI: xe } = Math;
var pe = 0.275;
var V2 = xe + 1e-4;
function ce(e5, t5 = {}) {
  let { size: u5 = 16, smoothing: x5 = 0.5, thinning: h6 = 0.5, simulatePressure: y6 = true, easing: n5 = (r5) => r5, start: f5 = {}, end: d6 = {}, last: D6 = false } = t5, { cap: S4 = true, easing: j4 = (r5) => r5 * (2 - r5) } = f5, { cap: q4 = true, easing: c5 = (r5) => --r5 * r5 * r5 + 1 } = d6;
  if (e5.length === 0 || u5 <= 0)
    return [];
  let p6 = e5[e5.length - 1].runningLength, g6 = f5.taper === false ? 0 : f5.taper === true ? Math.max(u5, p6) : f5.taper, T5 = d6.taper === false ? 0 : d6.taper === true ? Math.max(u5, p6) : d6.taper, te2 = Math.pow(u5 * x5, 2), _3 = [], M3 = [], H5 = e5.slice(0, 10).reduce((r5, i4) => {
    let o5 = i4.pressure;
    if (y6) {
      let s5 = C(1, i4.distance / u5), W5 = C(1, 1 - s5);
      o5 = C(1, r5 + (W5 - r5) * (s5 * pe));
    }
    return (r5 + o5) / 2;
  }, e5[0].pressure), m6 = $(u5, h6, e5[e5.length - 1].pressure, n5), U4, X3 = e5[0].vector, z5 = e5[0].point, F5 = z5, O6 = z5, E5 = F5, J3 = false;
  for (let r5 = 0; r5 < e5.length; r5++) {
    let { pressure: i4 } = e5[r5], { point: o5, vector: s5, distance: W5, runningLength: I3 } = e5[r5];
    if (r5 < e5.length - 1 && p6 - I3 < 3)
      continue;
    if (h6) {
      if (y6) {
        let v6 = C(1, W5 / u5), Z3 = C(1, 1 - v6);
        i4 = C(1, H5 + (Z3 - H5) * (v6 * pe));
      }
      m6 = $(u5, h6, i4, n5);
    } else
      m6 = u5 / 2;
    U4 === void 0 && (U4 = m6);
    let le3 = I3 < g6 ? j4(I3 / g6) : 1, fe2 = p6 - I3 < T5 ? c5((p6 - I3) / T5) : 1;
    m6 = Math.max(0.01, m6 * Math.min(le3, fe2));
    let re3 = (r5 < e5.length - 1 ? e5[r5 + 1] : e5[r5]).vector, Y3 = r5 < e5.length - 1 ? B(s5, re3) : 1, be3 = B(s5, X3) < 0 && !J3, ne2 = Y3 !== null && Y3 < 0;
    if (be3 || ne2) {
      let v6 = b(R(X3), m6);
      for (let Z3 = 1 / 13, w7 = 0; w7 <= 1; w7 += Z3)
        O6 = L(a(o5, v6), o5, V2 * w7), _3.push(O6), E5 = L(l(o5, v6), o5, V2 * -w7), M3.push(E5);
      z5 = O6, F5 = E5, ne2 && (J3 = true);
      continue;
    }
    if (J3 = false, r5 === e5.length - 1) {
      let v6 = b(R(s5), m6);
      _3.push(a(o5, v6)), M3.push(l(o5, v6));
      continue;
    }
    let oe2 = b(R(K(re3, s5, Y3)), m6);
    O6 = a(o5, oe2), (r5 <= 1 || A(z5, O6) > te2) && (_3.push(O6), z5 = O6), E5 = l(o5, oe2), (r5 <= 1 || A(F5, E5) > te2) && (M3.push(E5), F5 = E5), H5 = i4, X3 = s5;
  }
  let P5 = e5[0].point.slice(0, 2), k7 = e5.length > 1 ? e5[e5.length - 1].point.slice(0, 2) : l(e5[0].point, [1, 1]), Q3 = [], N4 = [];
  if (e5.length === 1) {
    if (!(g6 || T5) || D6) {
      let r5 = ee(P5, G(R(a(P5, k7))), -(U4 || m6)), i4 = [];
      for (let o5 = 1 / 13, s5 = o5; s5 <= 1; s5 += o5)
        i4.push(L(r5, P5, V2 * 2 * s5));
      return i4;
    }
  } else {
    if (!(g6 || T5 && e5.length === 1))
      if (S4)
        for (let i4 = 1 / 13, o5 = i4; o5 <= 1; o5 += i4) {
          let s5 = L(M3[0], P5, V2 * o5);
          Q3.push(s5);
        }
      else {
        let i4 = a(_3[0], M3[0]), o5 = b(i4, 0.5), s5 = b(i4, 0.51);
        Q3.push(a(P5, o5), a(P5, s5), l(P5, s5), l(P5, o5));
      }
    let r5 = R(se(e5[e5.length - 1].vector));
    if (T5 || g6 && e5.length === 1)
      N4.push(k7);
    else if (q4) {
      let i4 = ee(k7, r5, m6);
      for (let o5 = 1 / 29, s5 = o5; s5 < 1; s5 += o5)
        N4.push(L(i4, k7, V2 * 3 * s5));
    } else
      N4.push(l(k7, b(r5, m6)), l(k7, b(r5, m6 * 0.99)), a(k7, b(r5, m6 * 0.99)), a(k7, b(r5, m6)));
  }
  return _3.concat(N4, M3.reverse(), Q3);
}
function me(e5, t5 = {}) {
  var q4;
  let { streamline: u5 = 0.5, size: x5 = 16, last: h6 = false } = t5;
  if (e5.length === 0)
    return [];
  let y6 = 0.15 + (1 - u5) * 0.85, n5 = Array.isArray(e5[0]) ? e5 : e5.map(({ x: c5, y: p6, pressure: g6 = 0.5 }) => [c5, p6, g6]);
  if (n5.length === 2) {
    let c5 = n5[1];
    n5 = n5.slice(0, -1);
    for (let p6 = 1; p6 < 5; p6++)
      n5.push(K(n5[0], c5, p6 / 4));
  }
  n5.length === 1 && (n5 = [...n5, [...l(n5[0], [1, 1]), ...n5[0].slice(2)]]);
  let f5 = [{ point: [n5[0][0], n5[0][1]], pressure: n5[0][2] >= 0 ? n5[0][2] : 0.25, vector: [1, 1], distance: 0, runningLength: 0 }], d6 = false, D6 = 0, S4 = f5[0], j4 = n5.length - 1;
  for (let c5 = 1; c5 < n5.length; c5++) {
    let p6 = h6 && c5 === j4 ? n5[c5].slice(0, 2) : K(S4.point, n5[c5], y6);
    if (ue(S4.point, p6))
      continue;
    let g6 = ie(p6, S4.point);
    if (D6 += g6, c5 < j4 && !d6) {
      if (D6 < x5)
        continue;
      d6 = true;
    }
    S4 = { point: p6, pressure: n5[c5][2] >= 0 ? n5[c5][2] : 0.5, vector: G(a(S4.point, p6)), distance: g6, runningLength: D6 }, f5.push(S4);
  }
  return f5[0].vector = ((q4 = f5[1]) == null ? void 0 : q4.vector) || [0, 0], f5;
}
function ae(e5, t5 = {}) {
  return ce(me(e5, t5), t5);
}
var _e = ae;

// node_modules/.pnpm/@tldraw+core@1.23.2_react-dom@18.2.0_react@18.2.0/node_modules/@tldraw/core/dist/index.mjs
var Ue = __toESM(require("react"), 1);
var he2 = __toESM(require("react"), 1);
var ne = __toESM(require("react"), 1);
var G3 = __toESM(require("react"), 1);
var K3 = __toESM(require("react"), 1);
var ae2 = __toESM(require("react"), 1);
var $e = __toESM(require("react"), 1);
var $3 = __toESM(require("react"), 1);
var q2 = __toESM(require("react"), 1);
var fe = __toESM(require("react"), 1);
var Ne = __toESM(require("react"), 1);
var F2 = __toESM(require("react"), 1);
var Te2 = __toESM(require("react"), 1);
var ge2 = __toESM(require("react"), 1);
var de3 = __toESM(require("react"), 1);
var oe = __toESM(require("react"), 1);
var re = __toESM(require("react"), 1);
var Re = __toESM(require("react"), 1);
var We = __toESM(require("react"), 1);
var le2 = __toESM(require("react"), 1);
var j2 = __toESM(require("react"), 1);
var Be = __toESM(require("react"), 1);
var ce3 = __toESM(require("react"), 1);
var ie3 = __toESM(require("react"), 1);
var se3 = __toESM(require("react"), 1);
var me2 = __toESM(require("react"), 1);

// node_modules/.pnpm/@tldraw+intersect@1.9.2/node_modules/@tldraw/intersect/dist/index.mjs
var A2 = Object.defineProperty;
var M = Object.defineProperties;
var q = Object.getOwnPropertyDescriptors;
var X = Object.getOwnPropertySymbols;
var V3 = Object.prototype.hasOwnProperty;
var $2 = Object.prototype.propertyIsEnumerable;
var Y = (e5, n5, t5) => n5 in e5 ? A2(e5, n5, { enumerable: true, configurable: true, writable: true, value: t5 }) : e5[n5] = t5;
var g = (e5, n5) => {
  for (var t5 in n5 || (n5 = {}))
    V3.call(n5, t5) && Y(e5, t5, n5[t5]);
  if (X)
    for (var t5 of X(n5))
      $2.call(n5, t5) && Y(e5, t5, n5[t5]);
  return e5;
};
var T = (e5, n5) => M(e5, q(n5));
function l2(e5, ...n5) {
  return { didIntersect: n5.length > 0, message: e5, points: n5 };
}
function I(e5, n5, t5 = 0) {
  let r5 = [e5[0] + n5[0] / 2, e5[1] + n5[1] / 2], i4 = e.rotWith(e5, r5, t5), u5 = e.rotWith(e.add(e5, [n5[0], 0]), r5, t5), s5 = e.rotWith(e.add(e5, n5), r5, t5), o5 = e.rotWith(e.add(e5, [0, n5[1]]), r5, t5);
  return [["top", [i4, u5]], ["right", [u5, s5]], ["bottom", [s5, o5]], ["left", [o5, i4]]];
}
function v(e5, n5, t5) {
  if (t5 === e5 || t5 === n5)
    return true;
  let r5 = Math.PI * 2, i4 = (n5 - e5 + r5) % r5, u5 = (t5 - e5 + r5) % r5;
  return i4 <= Math.PI != u5 > i4;
}
function ie2(e5, n5) {
  let t5 = e.slope(e5[0], e5[1]), r5 = e.slope(n5[0], n5[1]);
  if (t5 === r5)
    return;
  if (Number.isNaN(t5) && !Number.isNaN(r5))
    return [e5[0][0], (e5[0][0] - n5[0][0]) * r5 + n5[0][1]];
  if (Number.isNaN(r5) && !Number.isNaN(t5))
    return [n5[0][0], (n5[0][0] - e5[0][0]) * t5 + e5[0][1]];
  let i4 = (t5 * e5[0][0] - r5 * n5[0][0] + n5[0][1] - e5[0][1]) / (t5 - r5), u5 = r5 * (i4 - n5[0][0]) + n5[0][1];
  return [i4, u5];
}
function x(e5, n5, t5, r5) {
  let [i4, u5] = e5, [s5, o5] = n5, [c5, m6] = t5, [b6, f5] = r5;
  if (o5 / s5 !== (f5 - m6) / (b6 - c5)) {
    let p6 = s5 * (f5 - m6) - o5 * (b6 - c5);
    if (p6 !== 0) {
      let L5 = ((u5 - m6) * (b6 - c5) - (i4 - c5) * (f5 - m6)) / p6, h6 = ((u5 - m6) * s5 - (i4 - c5) * o5) / p6;
      if (L5 >= 0 && h6 >= 0 && h6 <= 1)
        return l2("intersection", [i4 + L5 * s5, u5 + L5 * o5]);
    }
  }
  return l2("no intersection");
}
function N(e5, n5, t5, r5, i4 = 0) {
  return G2(t5, r5, i4, e5, n5);
}
function F(e5, n5, t5, r5, i4, u5) {
  let s5 = e5, o5 = e.mul(n5, 999999999);
  return y(s5, o5, t5, r5, i4, u5);
}
function se2(e5, n5, t5, r5 = 0) {
  let { minX: i4, minY: u5, width: s5, height: o5 } = t5;
  return N(e5, n5, [i4, u5], [s5, o5], r5);
}
function B2(e5, n5, t5, r5) {
  let i4 = e.sub(e5, t5), u5 = e.sub(r5, t5), s5 = e.sub(n5, e5), o5 = u5[0] * i4[1] - u5[1] * i4[0], c5 = s5[0] * i4[1] - s5[1] * i4[0], m6 = u5[1] * s5[0] - u5[0] * s5[1];
  if (o5 === 0 || c5 === 0)
    return l2("coincident");
  if (m6 === 0)
    return l2("parallel");
  if (m6 !== 0) {
    let b6 = o5 / m6, f5 = c5 / m6;
    if (0 <= b6 && b6 <= 1 && 0 <= f5 && f5 <= 1)
      return l2("intersection", e.add(e5, e.mul(s5, b6)));
  }
  return l2("no intersection");
}
function j(e5, n5, t5, r5) {
  return E(t5, r5, e5, n5);
}
function k(e5, n5, t5, r5, i4, u5) {
  let s5 = e.angle(t5, i4), o5 = e.angle(t5, u5), c5 = U(t5, r5, r5, 0, e5, n5);
  if (!c5.didIntersect)
    return l2("no intersection");
  let m6 = c5.points.filter((b6) => v(s5, o5, e.angle(t5, b6)));
  return m6.length === 0 ? l2("no intersection") : l2("intersection", ...m6);
}
function R2(e5, n5, t5, r5) {
  let i4 = (n5[0] - e5[0]) * (n5[0] - e5[0]) + (n5[1] - e5[1]) * (n5[1] - e5[1]), u5 = 2 * ((n5[0] - e5[0]) * (e5[0] - t5[0]) + (n5[1] - e5[1]) * (e5[1] - t5[1])), s5 = t5[0] * t5[0] + t5[1] * t5[1] + e5[0] * e5[0] + e5[1] * e5[1] - 2 * (t5[0] * e5[0] + t5[1] * e5[1]) - r5 * r5, o5 = u5 * u5 - 4 * i4 * s5;
  if (o5 < 0)
    return l2("outside");
  if (o5 === 0)
    return l2("tangent");
  let c5 = Math.sqrt(o5), m6 = (-u5 + c5) / (2 * i4), b6 = (-u5 - c5) / (2 * i4);
  if ((m6 < 0 || m6 > 1) && (b6 < 0 || b6 > 1))
    return m6 < 0 && b6 < 0 || m6 > 1 && b6 > 1 ? l2("outside") : l2("inside");
  let f5 = [];
  return 0 <= m6 && m6 <= 1 && f5.push(e.lrp(e5, n5, m6)), 0 <= b6 && b6 <= 1 && f5.push(e.lrp(e5, n5, b6)), l2("intersection", ...f5);
}
function y(e5, n5, t5, r5, i4, u5 = 0) {
  if (r5 === 0 || i4 === 0 || e.isEqual(e5, n5))
    return l2("no intersection");
  r5 = r5 < 0 ? r5 : -r5, i4 = i4 < 0 ? i4 : -i4, e5 = e.sub(e.rotWith(e5, t5, -u5), t5), n5 = e.sub(e.rotWith(n5, t5, -u5), t5);
  let s5 = e.sub(n5, e5), o5 = s5[0] * s5[0] / r5 / r5 + s5[1] * s5[1] / i4 / i4, c5 = 2 * e5[0] * s5[0] / r5 / r5 + 2 * e5[1] * s5[1] / i4 / i4, m6 = e5[0] * e5[0] / r5 / r5 + e5[1] * e5[1] / i4 / i4 - 1, b6 = [], f5 = c5 * c5 - 4 * o5 * m6;
  if (f5 === 0)
    b6.push(-c5 / 2 / o5);
  else if (f5 > 0) {
    let L5 = Math.sqrt(f5);
    b6.push((-c5 + L5) / 2 / o5), b6.push((-c5 - L5) / 2 / o5);
  }
  let p6 = b6.filter((L5) => L5 >= 0 && L5 <= 1).map((L5) => e.add(t5, e.add(e5, e.mul(e.sub(n5, e5), L5)))).map((L5) => e.rotWith(L5, t5, u5));
  return l2("intersection", ...p6);
}
function ce2(e5, n5, t5) {
  return z(t5, e5, n5);
}
function S(e5, n5, t5) {
  let r5 = [];
  for (let i4 = 1; i4 < t5.length; i4++) {
    let u5 = B2(e5, n5, t5[i4 - 1], t5[i4]);
    u5 && r5.push(...u5.points);
  }
  return r5.length === 0 ? l2("no intersection") : l2("intersection", ...t5);
}
function D(e5, n5, t5) {
  let r5 = [];
  for (let i4 = 1; i4 < t5.length + 1; i4++) {
    let u5 = B2(e5, n5, t5[i4 - 1], t5[i4 % t5.length]);
    u5 && r5.push(...u5.points);
  }
  return r5.length === 0 ? l2("no intersection") : l2("intersection", ...t5);
}
function G2(e5, n5, t5, r5, i4) {
  return I(e5, n5, t5).reduce((s5, [o5, [c5, m6]]) => {
    let b6 = x(r5, i4, c5, m6);
    return b6 && s5.push(l2(o5, ...b6.points)), s5;
  }, []).filter((s5) => s5.didIntersect);
}
function E(e5, n5, t5, r5) {
  return I(e5, n5).reduce((u5, [s5, [o5, c5]]) => {
    let m6 = B2(t5, r5, o5, c5);
    return m6 && u5.push(l2(s5, ...m6.points)), u5;
  }, []).filter((u5) => u5.didIntersect);
}
function a2(e5, n5, t5, r5) {
  return I(e5, n5).reduce((u5, [s5, [o5, c5]]) => {
    let m6 = E(t5, r5, o5, c5);
    return u5.push(...m6.map((b6) => l2(`${s5} ${b6.message}`, ...b6.points))), u5;
  }, []).filter((u5) => u5.didIntersect);
}
function H(e5, n5, t5, r5, i4, u5) {
  return I(e5, n5).reduce((o5, [c5, [m6, b6]]) => {
    let f5 = O(t5, r5, i4, u5, m6, b6);
    return f5 && o5.push(T(g({}, f5), { message: c5 })), o5;
  }, []).filter((o5) => o5.didIntersect);
}
function C2(e5, n5, t5, r5) {
  return I(e5, n5).reduce((u5, [s5, [o5, c5]]) => {
    let m6 = R2(o5, c5, t5, r5);
    return m6 && u5.push(T(g({}, m6), { message: s5 })), u5;
  }, []).filter((u5) => u5.didIntersect);
}
function J(e5, n5, t5, r5, i4, u5 = 0) {
  return I(e5, n5).reduce((o5, [c5, [m6, b6]]) => {
    let f5 = y(m6, b6, t5, r5, i4, u5);
    return f5 && o5.push(T(g({}, f5), { message: c5 })), o5;
  }, []).filter((o5) => o5.didIntersect);
}
function w(e5, n5, t5) {
  return I(e5, n5).reduce((i4, [u5, [s5, o5]]) => {
    let c5 = S(s5, o5, t5);
    return c5.didIntersect && i4.push(l2(u5, ...c5.points)), i4;
  }, []).filter((i4) => i4.didIntersect);
}
function K2(e5, n5, t5) {
  return I(e5, n5).reduce((i4, [u5, [s5, o5]]) => {
    let c5 = D(s5, o5, t5);
    return c5.didIntersect && i4.push(l2(u5, ...c5.points)), i4;
  }, []).filter((i4) => i4.didIntersect);
}
function O(e5, n5, t5, r5, i4, u5) {
  return k(i4, u5, e5, n5, t5, r5);
}
function _(e5, n5, t5, r5, i4, u5) {
  return H(i4, u5, e5, n5, t5, r5);
}
function be(e5, n5, t5, r5, i4) {
  let { minX: u5, minY: s5, width: o5, height: c5 } = i4;
  return _(e5, n5, t5, r5, [u5, s5], [o5, c5]);
}
function de2(e5, n5, t5, r5) {
  return R2(t5, r5, e5, n5);
}
function le(e5, n5, t5, r5) {
  let i4 = t5[0] - e5[0], u5 = t5[1] - e5[1], s5 = Math.sqrt(i4 * i4 + u5 * u5), o5 = (s5 * s5 - r5 * r5 + n5 * n5) / (2 * s5), c5 = Math.sqrt(n5 * n5 - o5 * o5);
  return i4 /= s5, u5 /= s5, l2("intersection", [e5[0] + i4 * o5 - u5 * c5, e5[1] + u5 * o5 + i4 * c5], [e5[0] + i4 * o5 + u5 * c5, e5[1] + u5 * o5 - i4 * c5]);
}
function U(e5, n5, t5, r5 = 0, i4, u5) {
  return n5 === t5 ? R2(i4, u5, e5, n5) : y(i4, u5, e5, n5, t5, r5);
}
function W(e5, n5, t5, r5 = 0, i4, u5) {
  return n5 === t5 ? C2(i4, u5, e5, n5) : J(i4, u5, e5, n5, t5, r5);
}
function pe2(e5, n5, t5, r5, i4) {
  let { minX: u5, minY: s5, width: o5, height: c5 } = i4;
  return W(e5, n5, t5, r5, [u5, s5], [o5, c5]);
}
function z(e5, n5, t5) {
  let { minX: r5, minY: i4, width: u5, height: s5 } = e5;
  return j(n5, t5, [r5, i4], [u5, s5]);
}
function Te(e5, n5) {
  return a2([e5.minX, e5.minY], [e5.width, e5.height], [n5.minX, n5.minY], [n5.width, n5.height]);
}
function ye(e5, n5) {
  return Q(n5, e5);
}
function Se(e5, n5) {
  return ee2(n5, e5);
}
function Q(e5, n5) {
  return w([n5.minX, n5.minY], [n5.width, n5.height], e5);
}
function ee2(e5, n5) {
  return K2([n5.minX, n5.minY], [n5.width, n5.height], e5);
}

// node_modules/.pnpm/@tldraw+core@1.23.2_react-dom@18.2.0_react@18.2.0/node_modules/@tldraw/core/dist/index.mjs
var Ae = __toESM(require("react"), 1);
var qt = Object.defineProperty;
var Qt = Object.defineProperties;
var Jt = Object.getOwnPropertyDescriptors;
var Ce = Object.getOwnPropertySymbols;
var Ze = Object.prototype.hasOwnProperty;
var qe = Object.prototype.propertyIsEnumerable;
var Oe = (r5, e5, t5) => e5 in r5 ? qt(r5, e5, { enumerable: true, configurable: true, writable: true, value: t5 }) : r5[e5] = t5;
var g2 = (r5, e5) => {
  for (var t5 in e5 || (e5 = {}))
    Ze.call(e5, t5) && Oe(r5, t5, e5[t5]);
  if (Ce)
    for (var t5 of Ce(e5))
      qe.call(e5, t5) && Oe(r5, t5, e5[t5]);
  return r5;
};
var U2 = (r5, e5) => Qt(r5, Jt(e5));
var O2 = (r5, e5) => {
  var t5 = {};
  for (var n5 in r5)
    Ze.call(r5, n5) && e5.indexOf(n5) < 0 && (t5[n5] = r5[n5]);
  if (r5 != null && Ce)
    for (var n5 of Ce(r5))
      e5.indexOf(n5) < 0 && qe.call(r5, n5) && (t5[n5] = r5[n5]);
  return t5;
};
var E2 = (r5, e5, t5) => (Oe(r5, typeof e5 != "symbol" ? e5 + "" : e5, t5), t5);
var Le = Se2.createContext({});
function R3() {
  return Se2.useContext(Le);
}
var Qe = ((o5) => (o5.TransformSelected = "transform_selected", o5.TranslateSelected = "translate_selected", o5.TransformAll = "transform_all", o5.TranslateAll = "translate_all", o5))(Qe || {});
var we = ((o5) => (o5.Top = "top_edge", o5.Right = "right_edge", o5.Bottom = "bottom_edge", o5.Left = "left_edge", o5))(we || {});
var He = ((o5) => (o5.TopLeft = "top_left_corner", o5.TopRight = "top_right_corner", o5.BottomRight = "bottom_right_corner", o5.BottomLeft = "bottom_left_corner", o5))(He || {});
var Je = ((s5) => (s5.minX = "minX", s5.midX = "midX", s5.maxX = "maxX", s5.minY = "minY", s5.midY = "midY", s5.maxY = "maxY", s5))(Je || {});
String.prototype.replaceAll || (String.prototype.replaceAll = function(r5, e5) {
  return Object.prototype.toString.call(r5).toLowerCase() === "[object regexp]" ? this.replace(r5, e5) : this.replace(new RegExp(r5, "g"), e5);
});
var Ie = Math.PI * 2;
var k2 = class {
  static lerp(e5, t5, n5) {
    return n5 = k2.clamp(n5, 0, 1), e5 * (1 - n5) + t5 * n5;
  }
  static lerpColor(e5, t5, n5 = 0.5) {
    function o5(l7) {
      let c5 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(l7);
      return [parseInt(c5[1], 16), parseInt(c5[2], 16), parseInt(c5[3], 16)];
    }
    function i4(l7) {
      return "#" + ((1 << 24) + (l7[0] << 16) + (l7[1] << 8) + l7[2]).toString(16).slice(1);
    }
    let s5 = o5(e5) || [0, 0, 0], a7 = o5(t5) || [0, 0, 0], d6 = s5.slice();
    for (let l7 = 0; l7 < 3; l7++)
      d6[l7] = Math.round(d6[l7] + n5 * (a7[l7] - s5[l7]));
    return i4(d6);
  }
  static modulate(e5, t5, n5, o5 = false) {
    let [i4, s5] = t5, [a7, d6] = n5, l7 = a7 + (e5 - i4) / (s5 - i4) * (d6 - a7);
    return o5 ? a7 < d6 ? Math.max(Math.min(l7, d6), a7) : Math.max(Math.min(l7, a7), d6) : l7;
  }
  static clamp(e5, t5, n5) {
    return Math.max(t5, typeof n5 != "undefined" ? Math.min(e5, n5) : e5);
  }
  static deepClone(e5) {
    if (e5 === null)
      return e5;
    if (Array.isArray(e5))
      return [...e5];
    if (typeof e5 == "object") {
      let t5 = g2({}, e5);
      return Object.keys(t5).forEach((n5) => t5[n5] = typeof e5[n5] == "object" ? k2.deepClone(e5[n5]) : e5[n5]), t5;
    }
    return e5;
  }
  static rng(e5 = "") {
    let t5 = 0, n5 = 0, o5 = 0, i4 = 0;
    function s5() {
      let a7 = t5 ^ t5 << 11;
      return t5 = n5, n5 = o5, o5 = i4, i4 ^= (i4 >>> 19 ^ a7 ^ a7 >>> 8) >>> 0, i4 / 4294967296;
    }
    for (let a7 = 0; a7 < e5.length + 64; a7++)
      t5 ^= e5.charCodeAt(a7) | 0, s5();
    return s5;
  }
  static pointsToLineSegments(e5, t5 = false) {
    let n5 = [];
    for (let o5 = 1; o5 < e5.length; o5++)
      n5.push([e5[o5 - 1], e5[o5]]);
    return t5 && n5.push([e5[e5.length - 1], e5[0]]), n5;
  }
  static getRectangleSides(e5, t5, n5 = 0) {
    let o5 = [e5[0] + t5[0] / 2, e5[1] + t5[1] / 2], i4 = e.rotWith(e5, o5, n5), s5 = e.rotWith(e.add(e5, [t5[0], 0]), o5, n5), a7 = e.rotWith(e.add(e5, t5), o5, n5), d6 = e.rotWith(e.add(e5, [0, t5[1]]), o5, n5);
    return [["top", [i4, s5]], ["right", [s5, a7]], ["bottom", [a7, d6]], ["left", [d6, i4]]];
  }
  static circleFromThreePoints(e5, t5, n5) {
    let [o5, i4] = e5, [s5, a7] = t5, [d6, l7] = n5, c5 = o5 * (a7 - l7) - i4 * (s5 - d6) + s5 * l7 - d6 * a7, m6 = (o5 * o5 + i4 * i4) * (l7 - a7) + (s5 * s5 + a7 * a7) * (i4 - l7) + (d6 * d6 + l7 * l7) * (a7 - i4), p6 = (o5 * o5 + i4 * i4) * (s5 - d6) + (s5 * s5 + a7 * a7) * (d6 - o5) + (d6 * d6 + l7 * l7) * (o5 - s5), u5 = -m6 / (2 * c5), y6 = -p6 / (2 * c5);
    return [u5, y6, Math.hypot(u5 - o5, y6 - i4)];
  }
  static perimeterOfEllipse(e5, t5) {
    let n5 = Math.pow(e5 - t5, 2) / Math.pow(e5 + t5, 2);
    return Math.PI * (e5 + t5) * (1 + 3 * n5 / (10 + Math.sqrt(4 - 3 * n5)));
  }
  static shortAngleDist(e5, t5) {
    let n5 = Math.PI * 2, o5 = (t5 - e5) % n5;
    return 2 * o5 % n5 - o5;
  }
  static longAngleDist(e5, t5) {
    return Math.PI * 2 - k2.shortAngleDist(e5, t5);
  }
  static lerpAngles(e5, t5, n5) {
    return e5 + k2.shortAngleDist(e5, t5) * n5;
  }
  static angleDelta(e5, t5) {
    return k2.shortAngleDist(e5, t5);
  }
  static getSweep(e5, t5, n5) {
    return k2.angleDelta(e.angle(e5, t5), e.angle(e5, n5));
  }
  static clampRadians(e5) {
    return (Math.PI * 2 + e5) % (Math.PI * 2);
  }
  static snapAngleToSegments(e5, t5) {
    let n5 = Math.PI * 2 / t5;
    return Math.floor((k2.clampRadians(e5) + n5 / 2) / n5) * n5;
  }
  static isAngleBetween(e5, t5, n5) {
    if (n5 === e5 || n5 === t5)
      return true;
    let o5 = (t5 - e5 + Ie) % Ie, i4 = (n5 - e5 + Ie) % Ie;
    return o5 <= Math.PI != i4 > o5;
  }
  static degreesToRadians(e5) {
    return e5 * Math.PI / 180;
  }
  static radiansToDegrees(e5) {
    return e5 * 180 / Math.PI;
  }
  static getArcLength(e5, t5, n5, o5) {
    let i4 = k2.getSweep(e5, n5, o5);
    return t5 * (2 * Math.PI) * (i4 / (2 * Math.PI));
  }
  static getSweepFlag(e5, t5, n5) {
    let o5 = e.angle(e5, n5);
    return (e.angle(e5, t5) - o5 + 3 * Math.PI) % (2 * Math.PI) - Math.PI > 0 ? 0 : 1;
  }
  static getLargeArcFlag(e5, t5, n5) {
    let o5 = e.angle(n5, e5), s5 = (e.angle(n5, t5) - o5 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
    return Math.abs(s5) > Math.PI / 2 ? 0 : 1;
  }
  static getArcDashOffset(e5, t5, n5, o5, i4) {
    let s5 = k2.getSweepFlag(e5, n5, o5), a7 = k2.getArcLength(e5, t5, n5, o5);
    return -(s5 < 0 ? a7 : 2 * Math.PI * e5[2] - a7) / 2 + i4;
  }
  static getEllipseDashOffset(e5, t5) {
    return -(2 * Math.PI * e5[2]) / 2 + -t5;
  }
  static pointInCircle(e5, t5, n5) {
    return e.dist(e5, t5) <= n5;
  }
  static pointInEllipse(e5, t5, n5, o5, i4 = 0) {
    i4 = i4 || 0;
    let s5 = Math.cos(i4), a7 = Math.sin(i4), d6 = e.sub(e5, t5), l7 = s5 * d6[0] + a7 * d6[1], c5 = a7 * d6[0] - s5 * d6[1];
    return l7 * l7 / (n5 * n5) + c5 * c5 / (o5 * o5) <= 1;
  }
  static pointInRect(e5, t5) {
    return !(e5[0] < t5[0] || e5[0] > e5[0] + t5[0] || e5[1] < t5[1] || e5[1] > e5[1] + t5[1]);
  }
  static pointInPolygon(e5, t5) {
    let n5 = 0;
    return t5.forEach((o5, i4) => {
      let s5 = t5[(i4 + 1) % t5.length];
      o5[1] <= e5[1] ? s5[1] > e5[1] && e.cross(o5, s5, e5) > 0 && (n5 += 1) : s5[1] <= e5[1] && e.cross(o5, s5, e5) < 0 && (n5 -= 1);
    }), n5 !== 0;
  }
  static pointInBounds(e5, t5) {
    return !(e5[0] < t5.minX || e5[0] > t5.maxX || e5[1] < t5.minY || e5[1] > t5.maxY);
  }
  static pointInPolyline(e5, t5, n5 = 3) {
    for (let o5 = 1; o5 < t5.length; o5++)
      if (e.distanceToLineSegment(t5[o5 - 1], t5[o5], e5) < n5)
        return true;
    return false;
  }
  static getBoundsSides(e5) {
    return this.getRectangleSides([e5.minX, e5.minY], [e5.width, e5.height]);
  }
  static expandBounds(e5, t5) {
    return { minX: e5.minX - t5, minY: e5.minY - t5, maxX: e5.maxX + t5, maxY: e5.maxY + t5, width: e5.width + t5 * 2, height: e5.height + t5 * 2 };
  }
  static boundsCollide(e5, t5) {
    return !(e5.maxX < t5.minX || e5.minX > t5.maxX || e5.maxY < t5.minY || e5.minY > t5.maxY);
  }
  static boundsContain(e5, t5) {
    return e5.minX < t5.minX && e5.minY < t5.minY && e5.maxY > t5.maxY && e5.maxX > t5.maxX;
  }
  static boundsContained(e5, t5) {
    return k2.boundsContain(t5, e5);
  }
  static boundsAreEqual(e5, t5) {
    return !(t5.maxX !== e5.maxX || t5.minX !== e5.minX || t5.maxY !== e5.maxY || t5.minY !== e5.minY);
  }
  static getBoundsFromPoints(e5, t5 = 0) {
    let n5 = 1 / 0, o5 = 1 / 0, i4 = -1 / 0, s5 = -1 / 0;
    if (e5.length < 2)
      n5 = 0, o5 = 0, i4 = 1, s5 = 1;
    else
      for (let [a7, d6] of e5)
        n5 = Math.min(a7, n5), o5 = Math.min(d6, o5), i4 = Math.max(a7, i4), s5 = Math.max(d6, s5);
    return t5 !== 0 ? k2.getBoundsFromPoints(e5.map((a7) => e.rotWith(a7, [(n5 + i4) / 2, (o5 + s5) / 2], t5))) : { minX: n5, minY: o5, maxX: i4, maxY: s5, width: Math.max(1, i4 - n5), height: Math.max(1, s5 - o5) };
  }
  static centerBounds(e5, t5) {
    let n5 = this.getBoundsCenter(e5), o5 = t5[0] - n5[0], i4 = t5[1] - n5[1];
    return this.translateBounds(e5, [o5, i4]);
  }
  static snapBoundsToGrid(e5, t5) {
    let n5 = Math.round(e5.minX / t5) * t5, o5 = Math.round(e5.minY / t5) * t5, i4 = Math.round(e5.maxX / t5) * t5, s5 = Math.round(e5.maxY / t5) * t5;
    return { minX: n5, minY: o5, maxX: i4, maxY: s5, width: Math.max(1, i4 - n5), height: Math.max(1, s5 - o5) };
  }
  static translateBounds(e5, t5) {
    return { minX: e5.minX + t5[0], minY: e5.minY + t5[1], maxX: e5.maxX + t5[0], maxY: e5.maxY + t5[1], width: e5.width, height: e5.height };
  }
  static rotateBounds(e5, t5, n5) {
    let [o5, i4] = e.rotWith([e5.minX, e5.minY], t5, n5), [s5, a7] = e.rotWith([e5.maxX, e5.maxY], t5, n5);
    return { minX: o5, minY: i4, maxX: s5, maxY: a7, width: e5.width, height: e5.height };
  }
  static getRotatedEllipseBounds(e5, t5, n5, o5, i4 = 0) {
    let s5 = Math.cos(i4), a7 = Math.sin(i4), d6 = Math.hypot(n5 * s5, o5 * a7), l7 = Math.hypot(n5 * a7, o5 * s5);
    return { minX: e5 + n5 - d6, minY: t5 + o5 - l7, maxX: e5 + n5 + d6, maxY: t5 + o5 + l7, width: d6 * 2, height: l7 * 2 };
  }
  static getExpandedBounds(e5, t5) {
    let n5 = Math.min(e5.minX, t5.minX), o5 = Math.min(e5.minY, t5.minY), i4 = Math.max(e5.maxX, t5.maxX), s5 = Math.max(e5.maxY, t5.maxY), a7 = Math.abs(i4 - n5), d6 = Math.abs(s5 - o5);
    return { minX: n5, minY: o5, maxX: i4, maxY: s5, width: a7, height: d6 };
  }
  static getCommonBounds(e5) {
    if (e5.length < 2)
      return e5[0];
    let t5 = e5[0];
    for (let n5 = 1; n5 < e5.length; n5++)
      t5 = k2.getExpandedBounds(t5, e5[n5]);
    return t5;
  }
  static getRotatedCorners(e5, t5 = 0) {
    let n5 = [e5.minX + e5.width / 2, e5.minY + e5.height / 2];
    return [[e5.minX, e5.minY], [e5.maxX, e5.minY], [e5.maxX, e5.maxY], [e5.minX, e5.maxY]].map((o5) => e.rotWith(o5, n5, t5));
  }
  static getTransformedBoundingBox(e5, t5, n5, o5 = 0, i4 = false) {
    let [s5, a7] = [e5.minX, e5.minY], [d6, l7] = [e5.maxX, e5.maxY], [c5, m6] = [e5.minX, e5.minY], [p6, u5] = [e5.maxX, e5.maxY];
    if (t5 === "center")
      return { minX: c5 + n5[0], minY: m6 + n5[1], maxX: p6 + n5[0], maxY: u5 + n5[1], width: p6 - c5, height: u5 - m6, scaleX: 1, scaleY: 1 };
    let [y6, T5] = e.rot(n5, -o5);
    switch (t5) {
      case "top_edge":
      case "top_left_corner":
      case "top_right_corner": {
        m6 += T5;
        break;
      }
      case "bottom_edge":
      case "bottom_left_corner":
      case "bottom_right_corner": {
        u5 += T5;
        break;
      }
    }
    switch (t5) {
      case "left_edge":
      case "top_left_corner":
      case "bottom_left_corner": {
        c5 += y6;
        break;
      }
      case "right_edge":
      case "top_right_corner":
      case "bottom_right_corner": {
        p6 += y6;
        break;
      }
    }
    let v6 = d6 - s5, x5 = l7 - a7, f5 = (p6 - c5) / v6, L5 = (u5 - m6) / x5, Y3 = f5 < 0, X3 = L5 < 0, S4 = Math.abs(p6 - c5), b6 = Math.abs(u5 - m6);
    if (i4) {
      let P5 = v6 / x5, B5 = P5 < S4 / b6, M3 = S4 * (L5 < 0 ? 1 : -1) * (1 / P5), I3 = b6 * (f5 < 0 ? 1 : -1) * P5;
      switch (t5) {
        case "top_left_corner": {
          B5 ? m6 = u5 + M3 : c5 = p6 + I3;
          break;
        }
        case "top_right_corner": {
          B5 ? m6 = u5 + M3 : p6 = c5 - I3;
          break;
        }
        case "bottom_right_corner": {
          B5 ? u5 = m6 - M3 : p6 = c5 - I3;
          break;
        }
        case "bottom_left_corner": {
          B5 ? u5 = m6 - M3 : c5 = p6 + I3;
          break;
        }
        case "bottom_edge":
        case "top_edge": {
          let A6 = (c5 + p6) / 2, J3 = b6 * P5;
          c5 = A6 - J3 / 2, p6 = A6 + J3 / 2;
          break;
        }
        case "left_edge":
        case "right_edge": {
          let A6 = (m6 + u5) / 2, J3 = S4 / P5;
          m6 = A6 - J3 / 2, u5 = A6 + J3 / 2;
          break;
        }
      }
    }
    if (o5 % (Math.PI * 2) !== 0) {
      let P5 = [0, 0], B5 = e.med([s5, a7], [d6, l7]), M3 = e.med([c5, m6], [p6, u5]);
      switch (t5) {
        case "top_left_corner": {
          P5 = e.sub(e.rotWith([p6, u5], M3, o5), e.rotWith([d6, l7], B5, o5));
          break;
        }
        case "top_right_corner": {
          P5 = e.sub(e.rotWith([c5, u5], M3, o5), e.rotWith([s5, l7], B5, o5));
          break;
        }
        case "bottom_right_corner": {
          P5 = e.sub(e.rotWith([c5, m6], M3, o5), e.rotWith([s5, a7], B5, o5));
          break;
        }
        case "bottom_left_corner": {
          P5 = e.sub(e.rotWith([p6, m6], M3, o5), e.rotWith([d6, a7], B5, o5));
          break;
        }
        case "top_edge": {
          P5 = e.sub(e.rotWith(e.med([c5, u5], [p6, u5]), M3, o5), e.rotWith(e.med([s5, l7], [d6, l7]), B5, o5));
          break;
        }
        case "left_edge": {
          P5 = e.sub(e.rotWith(e.med([p6, m6], [p6, u5]), M3, o5), e.rotWith(e.med([d6, a7], [d6, l7]), B5, o5));
          break;
        }
        case "bottom_edge": {
          P5 = e.sub(e.rotWith(e.med([c5, m6], [p6, m6]), M3, o5), e.rotWith(e.med([s5, a7], [d6, a7]), B5, o5));
          break;
        }
        case "right_edge": {
          P5 = e.sub(e.rotWith(e.med([c5, m6], [c5, u5]), M3, o5), e.rotWith(e.med([s5, a7], [s5, l7]), B5, o5));
          break;
        }
      }
      [c5, m6] = e.sub([c5, m6], P5), [p6, u5] = e.sub([p6, u5], P5);
    }
    return p6 < c5 && ([p6, c5] = [c5, p6]), u5 < m6 && ([u5, m6] = [m6, u5]), { minX: c5, minY: m6, maxX: p6, maxY: u5, width: p6 - c5, height: u5 - m6, scaleX: (p6 - c5) / (d6 - s5 || 1) * (Y3 ? -1 : 1), scaleY: (u5 - m6) / (l7 - a7 || 1) * (X3 ? -1 : 1) };
  }
  static getTransformAnchor(e5, t5, n5) {
    let o5 = e5;
    switch (e5) {
      case "top_left_corner": {
        t5 && n5 ? o5 = "bottom_right_corner" : t5 ? o5 = "top_right_corner" : n5 ? o5 = "bottom_left_corner" : o5 = "bottom_right_corner";
        break;
      }
      case "top_right_corner": {
        t5 && n5 ? o5 = "bottom_left_corner" : t5 ? o5 = "top_left_corner" : n5 ? o5 = "bottom_right_corner" : o5 = "bottom_left_corner";
        break;
      }
      case "bottom_right_corner": {
        t5 && n5 ? o5 = "top_left_corner" : t5 ? o5 = "bottom_left_corner" : n5 ? o5 = "top_right_corner" : o5 = "top_left_corner";
        break;
      }
      case "bottom_left_corner": {
        t5 && n5 ? o5 = "top_right_corner" : t5 ? o5 = "bottom_right_corner" : n5 ? o5 = "top_left_corner" : o5 = "top_right_corner";
        break;
      }
    }
    return o5;
  }
  static getRelativeTransformedBoundingBox(e5, t5, n5, o5, i4) {
    let s5 = (o5 ? t5.maxX - n5.maxX : n5.minX - t5.minX) / t5.width, a7 = (i4 ? t5.maxY - n5.maxY : n5.minY - t5.minY) / t5.height, d6 = n5.width / t5.width, l7 = n5.height / t5.height, c5 = e5.minX + e5.width * s5, m6 = e5.minY + e5.height * a7, p6 = e5.width * d6, u5 = e5.height * l7;
    return { minX: c5, minY: m6, maxX: c5 + p6, maxY: m6 + u5, width: p6, height: u5 };
  }
  static getRotatedSize(e5, t5) {
    let n5 = e.div(e5, 2), o5 = [[0, 0], [e5[0], 0], e5, [0, e5[1]]].map((s5) => e.rotWith(s5, n5, t5)), i4 = k2.getBoundsFromPoints(o5);
    return [i4.width, i4.height];
  }
  static getBoundsCenter(e5) {
    return [e5.minX + e5.width / 2, e5.minY + e5.height / 2];
  }
  static getBoundsWithCenter(e5) {
    let t5 = k2.getBoundsCenter(e5);
    return U2(g2({}, e5), { midX: t5[0], midY: t5[1] });
  }
  static getCommonTopLeft(e5) {
    let t5 = [1 / 0, 1 / 0];
    return e5.forEach((n5) => {
      t5[0] = Math.min(t5[0], n5[0]), t5[1] = Math.min(t5[1], n5[1]);
    }), t5;
  }
  static getFromCache(e5, t5, n5) {
    let o5 = e5.get(t5);
    if (o5 === void 0 && (e5.set(t5, n5()), o5 = e5.get(t5), o5 === void 0))
      throw Error("Cache did not include item!");
    return o5;
  }
  static uniqueId(e5 = "") {
    return e5 ? ((Number(e5) ^ Math.random() * 16) >> Number(e5) / 4).toString(16) : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, k2.uniqueId);
  }
  static rotateArray(e5, t5) {
    return e5.map((n5, o5) => e5[(o5 + t5) % e5.length]);
  }
  static debounce(e5, t5 = 0) {
    let n5;
    return function(...o5) {
      clearTimeout(n5), n5 = setTimeout(() => e5.apply(o5), t5);
    };
  }
  static getSvgPathFromStroke(e5, t5 = true) {
    let n5 = e5.length;
    if (n5 < 4)
      return "";
    let o5 = e5[0], i4 = e5[1], s5 = e5[2], a7 = `M${o5[0].toFixed(2)},${o5[1].toFixed(2)} Q${i4[0].toFixed(2)},${i4[1].toFixed(2)} ${ee3(i4[0], s5[0]).toFixed(2)},${ee3(i4[1], s5[1]).toFixed(2)} T`;
    for (let d6 = 2, l7 = n5 - 1; d6 < l7; d6++)
      o5 = e5[d6], i4 = e5[d6 + 1], a7 += `${ee3(o5[0], i4[0]).toFixed(2)},${ee3(o5[1], i4[1]).toFixed(2)} `;
    return t5 && (a7 += "Z"), a7;
  }
  static getSvgPathFromStrokePoints(e5, t5 = false) {
    let n5 = e5.length;
    if (n5 < 4)
      return "";
    let o5 = e5[0].point, i4 = e5[1].point, s5 = e5[2].point, a7 = `M${o5[0].toFixed(2)},${o5[1].toFixed(2)} Q${i4[0].toFixed(2)},${i4[1].toFixed(2)} ${ee3(i4[0], s5[0]).toFixed(2)},${ee3(i4[1], s5[1]).toFixed(2)} T`;
    for (let d6 = 2, l7 = n5 - 1; d6 < l7; d6++)
      o5 = e5[d6].point, i4 = e5[d6 + 1].point, a7 += `${ee3(o5[0], i4[0]).toFixed(2)},${ee3(o5[1], i4[1]).toFixed(2)} `;
    return t5 && (a7 += "Z"), a7;
  }
  static getPerfectDashProps(e5, t5, n5, o5 = 1, i4 = true, s5 = 2) {
    let a7, d6, l7;
    if (n5.toLowerCase() === "dashed")
      a7 = t5 * s5, l7 = 1, d6 = i4 ? (a7 / 2).toString() : "0";
    else if (n5.toLowerCase() === "dotted")
      a7 = t5 / 100, l7 = 100, d6 = "0";
    else
      return { strokeDasharray: "none", strokeDashoffset: "none" };
    let c5 = Math.floor(e5 / a7 / (2 * l7));
    c5 -= c5 % o5, c5 = Math.max(c5, 4);
    let m6 = Math.max(a7, (e5 - c5 * a7) / (i4 ? c5 : c5 - 1));
    return { strokeDasharray: [a7, m6].join(" "), strokeDashoffset: d6 };
  }
  static isMobileSafari() {
    if (typeof window == "undefined")
      return false;
    let e5 = window.navigator.userAgent, t5 = !!e5.match(/iPad/i) || !!e5.match(/iPhone/i), n5 = !!e5.match(/WebKit/i);
    return t5 && n5 && !e5.match(/CriOS/i);
  }
  static throttle(e5, t5) {
    let n5, o5;
    return function(...i4) {
      return n5 || (n5 = true, setTimeout(() => n5 = false, t5), o5 = e5(...i4)), o5;
    };
  }
  static isDarwin() {
    return /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  }
  static metaKey(e5) {
    return k2.isDarwin() ? e5.metaKey : e5.ctrlKey;
  }
  static lns(e5) {
    let t5 = e5.split("");
    return t5.push(...t5.splice(0, Math.round(t5.length / 5))), t5.push(...t5.splice(0, Math.round(t5.length / 4))), t5.push(...t5.splice(0, Math.round(t5.length / 3))), t5.push(...t5.splice(0, Math.round(t5.length / 2))), t5.reverse().map((n5) => +n5 ? +n5 < 5 ? 5 + +n5 : +n5 > 5 ? +n5 - 5 : n5 : n5).join("");
  }
};
var C3 = k2;
E2(C3, "getSnapPoints", (e5, t5, n5) => {
  let o5 = g2({}, e5), i4 = [0, 0], s5 = [], a7 = { ["minX"]: { id: "minX", isSnapped: false }, ["midX"]: { id: "midX", isSnapped: false }, ["maxX"]: { id: "maxX", isSnapped: false }, ["minY"]: { id: "minY", isSnapped: false }, ["midY"]: { id: "midY", isSnapped: false }, ["maxY"]: { id: "maxY", isSnapped: false } }, d6 = ["midX", "minX", "maxX"], l7 = ["midY", "minY", "maxY"], c5 = t5.map((T5) => {
    let v6 = d6.flatMap((f5, L5) => d6.map((Y3, X3) => {
      let S4 = o5[f5] - T5[Y3], b6 = Math.abs(S4);
      return { f: f5, t: Y3, gap: S4, distance: b6, isCareful: L5 === 0 || L5 + X3 === 3 };
    })), x5 = l7.flatMap((f5, L5) => l7.map((Y3, X3) => {
      let S4 = o5[f5] - T5[Y3], b6 = Math.abs(S4);
      return { f: f5, t: Y3, gap: S4, distance: b6, isCareful: L5 === 0 || L5 + X3 === 3 };
    }));
    return [T5, v6, x5];
  }), m6 = 1 / 0, p6 = 1 / 0, u5 = 1 / 0, y6 = 1 / 0;
  return c5.forEach(([T5, v6, x5]) => {
    v6.forEach((f5) => {
      f5.distance < n5 && f5.distance < u5 && (u5 = f5.distance, m6 = f5.gap);
    }), x5.forEach((f5) => {
      f5.distance < n5 && f5.distance < y6 && (y6 = f5.distance, p6 = f5.gap);
    });
  }), c5.forEach(([T5, v6, x5]) => {
    m6 !== 1 / 0 && v6.forEach((f5) => {
      Math.abs(f5.gap - m6) < 2 && (a7[f5.f] = U2(g2({}, a7[f5.f]), { isSnapped: true, to: T5[f5.t], B: T5, distance: f5.distance }));
    }), p6 !== 1 / 0 && x5.forEach((f5) => {
      Math.abs(f5.gap - p6) < 2 && (a7[f5.f] = U2(g2({}, a7[f5.f]), { isSnapped: true, to: T5[f5.t], B: T5, distance: f5.distance }));
    });
  }), i4[0] = m6 === 1 / 0 ? 0 : m6, i4[1] = p6 === 1 / 0 ? 0 : p6, o5.minX -= i4[0], o5.midX -= i4[0], o5.maxX -= i4[0], o5.minY -= i4[1], o5.midY -= i4[1], o5.maxY -= i4[1], d6.forEach((T5) => {
    let v6 = a7[T5];
    if (!v6.isSnapped)
      return;
    let { id: x5, B: f5 } = v6, L5 = o5[x5];
    s5.push(x5 === "minX" ? [[L5, o5.midY], [L5, f5.minY], [L5, f5.maxY]] : [[L5, o5.minY], [L5, o5.maxY], [L5, f5.minY], [L5, f5.maxY]]);
  }), l7.forEach((T5) => {
    let v6 = a7[T5];
    if (!v6.isSnapped)
      return;
    let { id: x5, B: f5 } = v6, L5 = o5[x5];
    s5.push(x5 === "midY" ? [[o5.midX, L5], [f5.minX, L5], [f5.maxX, L5]] : [[o5.minX, L5], [o5.maxX, L5], [f5.minX, L5], [f5.maxX, L5]]);
  }), { offset: i4, snapLines: s5 };
}), E2(C3, "deepMerge", (e5, t5) => {
  let n5 = g2({}, e5), o5 = Object.entries(t5);
  for (let [i4, s5] of o5)
    n5[i4] = s5 === Object(s5) && !Array.isArray(s5) ? k2.deepMerge(n5[i4], s5) : s5;
  return n5;
});
function ee3(r5, e5) {
  return (r5 + e5) / 2;
}
var w2 = C3;
function tt(r5, e5) {
  let t5 = V4.useRef(void 0), n5 = V4.useRef(void 0), o5 = V4.useRef([0, 0]), i4 = V4.useRef(0), { inputs: s5, bounds: a7, callbacks: d6 } = R3();
  V4.useEffect(() => {
    let u5 = (y6) => y6.preventDefault();
    return document.addEventListener("gesturestart", u5), document.addEventListener("gesturechange", u5), () => {
      document.removeEventListener("gesturestart", u5), document.removeEventListener("gesturechange", u5);
    };
  }, []);
  let l7 = V4.useCallback(({ event: u5 }) => {
    var L5, Y3, X3, S4;
    if (u5.preventDefault(), s5.isPinching || u5.timeStamp <= i4.current)
      return;
    i4.current = u5.timeStamp;
    let [y6, T5, v6] = tn(u5);
    if ((u5.altKey || u5.ctrlKey || u5.metaKey) && u5.buttons === 0) {
      let P5 = [...(Y3 = (L5 = s5.pointer) == null ? void 0 : L5.point) != null ? Y3 : [a7.width / 2, a7.height / 2], v6 * 0.618], B5 = s5.pan(P5, u5);
      (X3 = d6.onZoom) == null || X3.call(d6, U2(g2({}, B5), { delta: P5 }), u5);
      return;
    }
    let x5 = e.mul(u5.shiftKey && !w2.isDarwin() ? [T5, 0] : [y6, T5], 0.5);
    if (e.isEqual(x5, [0, 0]))
      return;
    let f5 = s5.pan(x5, u5);
    (S4 = d6.onPan) == null || S4.call(d6, f5, u5);
  }, [d6, s5, a7]), c5 = V4.useCallback(({ origin: u5, event: y6 }) => {
    var x5;
    if (y6 instanceof WheelEvent)
      return;
    let T5 = e5.current;
    if (!T5 || !(y6.target === T5 || T5.contains(y6.target)))
      return;
    let v6 = s5.pinch(u5, u5);
    s5.isPinching = true, (x5 = d6.onPinchStart) == null || x5.call(d6, v6, y6), n5.current = v6.point, t5.current = v6.origin, o5.current = [0, 0];
  }, [d6, s5, a7]), m6 = V4.useCallback(({ origin: u5, offset: y6, event: T5 }) => {
    var L5;
    if (T5 instanceof WheelEvent)
      return;
    let v6 = e5.current;
    if (!(T5.target === v6 || (v6 == null ? void 0 : v6.contains(T5.target))) || !t5.current)
      return;
    let x5 = s5.pinch(u5, t5.current), f5 = e.sub(x5.delta, o5.current);
    o5.current = x5.delta, (L5 = d6.onPinch) == null || L5.call(d6, U2(g2({}, x5), { point: x5.point, origin: t5.current, delta: [...f5, y6[0]] }), T5), n5.current = u5;
  }, [d6, s5, a7]), p6 = V4.useCallback(({ origin: u5, event: y6 }) => {
    var x5;
    let T5 = e5.current;
    if (!(y6.target === T5 || (T5 == null ? void 0 : T5.contains(y6.target))))
      return;
    let v6 = s5.pinch(u5, u5);
    s5.isPinching = false, (x5 = d6.onPinchEnd) == null || x5.call(d6, v6, y6), n5.current = void 0, t5.current = void 0, o5.current = [0, 0];
  }, []);
  useGesture({ onWheel: l7, onPinchStart: c5, onPinch: m6, onPinchEnd: p6 }, { target: e5, eventOptions: { passive: false }, pinch: { from: [r5.current, 0], scaleBounds: () => ({ from: r5.current, max: 5, min: 0.1 }) } });
}
var et = 10;
function tn(r5) {
  let { deltaY: e5, deltaX: t5 } = r5, n5 = 0;
  if (r5.ctrlKey || r5.metaKey) {
    let o5 = Math.sign(r5.deltaY), i4 = Math.abs(r5.deltaY), s5 = e5;
    i4 > et && (s5 = et * o5), n5 = s5;
  }
  return [t5, e5, n5];
}
function nt() {
  let { callbacks: r5 } = R3();
  (0, import_react6.useEffect)(() => {
    function e5() {
      var t5;
      (t5 = r5.onShapeBlur) == null || t5.call(r5);
    }
    return w2.isMobileSafari() ? (document.addEventListener("focusout", e5), () => document.removeEventListener("focusout", e5)) : () => null;
  }, [r5]);
}
function rt() {
  let { callbacks: r5, inputs: e5 } = R3();
  return ot.useMemo(() => ({ onPointerDown: (t5) => {
    var o5, i4, s5;
    if (t5.dead || (t5.dead = true, !e5.pointerIsValid(t5)))
      return;
    if (t5.currentTarget.setPointerCapture(t5.pointerId), t5.button === 2) {
      (o5 = r5.onRightPointCanvas) == null || o5.call(r5, e5.pointerDown(t5, "canvas"), t5);
      return;
    }
    let n5 = e5.pointerDown(t5, "canvas");
    t5.button === 0 && ((i4 = r5.onPointCanvas) == null || i4.call(r5, n5, t5)), (s5 = r5.onPointerDown) == null || s5.call(r5, n5, t5);
  }, onPointerMove: (t5) => {
    var o5, i4;
    if (t5.dead || (t5.dead = true, !e5.pointerIsValid(t5)))
      return;
    let n5 = e5.pointerMove(t5, "canvas");
    t5.buttons === 1 && t5.currentTarget.hasPointerCapture(t5.pointerId) && ((o5 = r5.onDragCanvas) == null || o5.call(r5, n5, t5)), (i4 = r5.onPointerMove) == null || i4.call(r5, n5, t5);
  }, onPointerUp: (t5) => {
    var i4, s5, a7, d6, l7;
    if (t5.dead || (t5.dead = true, e5.activePointer = void 0, !e5.pointerIsValid(t5)))
      return;
    let n5 = e5.isDoubleClick(), o5 = e5.pointerUp(t5, "canvas");
    if (t5.button === 2) {
      (i4 = r5.onPointerUp) == null || i4.call(r5, o5, t5);
      return;
    }
    t5.currentTarget.hasPointerCapture(t5.pointerId) && ((s5 = t5.currentTarget) == null || s5.releasePointerCapture(t5.pointerId)), t5.button === 0 && (n5 && !(o5.altKey || o5.metaKey) && ((a7 = r5.onDoubleClickCanvas) == null || a7.call(r5, o5, t5)), (d6 = r5.onReleaseCanvas) == null || d6.call(r5, o5, t5)), (l7 = r5.onPointerUp) == null || l7.call(r5, o5, t5);
  }, onDrop: r5.onDrop, onDragOver: r5.onDragOver }), [r5, e5]);
}
function it(r5) {
  let { rPageState: e5, rSelectionBounds: t5, callbacks: n5, inputs: o5 } = Me.useContext(Le);
  return Me.useMemo(() => ({ onPointerDown: (i4) => {
    var a7, d6, l7, c5, m6, p6, u5;
    if (i4.dead || (i4.dead = true, !o5.pointerIsValid(i4)))
      return;
    if (i4.button === 2) {
      (a7 = n5.onRightPointShape) == null || a7.call(n5, o5.pointerDown(i4, r5), i4);
      return;
    }
    let s5 = o5.pointerDown(i4, r5);
    if ((d6 = i4.currentTarget) == null || d6.setPointerCapture(i4.pointerId), t5.current && C3.pointInBounds(s5.point, t5.current) && !e5.current.selectedIds.includes(r5)) {
      i4.button === 0 && ((l7 = n5.onPointBounds) == null || l7.call(n5, o5.pointerDown(i4, "bounds"), i4), (c5 = n5.onPointShape) == null || c5.call(n5, s5, i4)), (m6 = n5.onPointerDown) == null || m6.call(n5, s5, i4);
      return;
    }
    i4.button === 0 && ((p6 = n5.onPointShape) == null || p6.call(n5, s5, i4)), (u5 = n5.onPointerDown) == null || u5.call(n5, s5, i4);
  }, onPointerUp: (i4) => {
    var d6, l7, c5, m6;
    if (i4.dead || (i4.dead = true, !o5.pointerIsValid(i4)) || i4.button === 2)
      return;
    o5.activePointer = void 0;
    let s5 = o5.isDoubleClick(), a7 = o5.pointerUp(i4, r5);
    i4.pointerId && i4.currentTarget.hasPointerCapture(i4.pointerId) && ((d6 = i4.currentTarget) == null || d6.releasePointerCapture(i4.pointerId)), i4.button === 0 && (s5 && !(a7.altKey || a7.metaKey) && ((l7 = n5.onDoubleClickShape) == null || l7.call(n5, a7, i4)), (c5 = n5.onReleaseShape) == null || c5.call(n5, a7, i4)), (m6 = n5.onPointerUp) == null || m6.call(n5, a7, i4);
  }, onPointerMove: (i4) => {
    var a7, d6;
    if (i4.dead || (i4.dead = true, i4.buttons === 2 || !o5.pointerIsValid(i4) || o5.pointer && i4.pointerId !== o5.pointer.pointerId))
      return;
    let s5 = o5.pointerMove(i4, r5);
    i4.buttons === 1 && i4.currentTarget.hasPointerCapture(i4.pointerId) && ((a7 = n5.onDragShape) == null || a7.call(n5, s5, i4)), (d6 = n5.onPointerMove) == null || d6.call(n5, s5, i4);
  }, onPointerEnter: (i4) => {
    var a7;
    if (!o5.pointerIsValid(i4))
      return;
    let s5 = o5.pointerEnter(i4, r5);
    (a7 = n5.onHoverShape) == null || a7.call(n5, s5, i4);
  }, onPointerLeave: (i4) => {
    var a7;
    if (!o5.pointerIsValid(i4))
      return;
    let s5 = o5.pointerEnter(i4, r5);
    (a7 = n5.onUnhoverShape) == null || a7.call(n5, s5, i4);
  } }), [o5, n5, r5]);
}
function st(r5, e5, t5, n5, o5, i4 = false, s5 = false, a7, d6) {
  let l7 = { shape: r5, asset: r5.assetId ? o5[r5.assetId] : void 0, meta: a7, isChildOfSelected: s5, isGhost: r5.isGhost || i4, isEditing: n5.editingId === r5.id, isBinding: d6 === r5.id, isSelected: n5.selectedIds.includes(r5.id), isHovered: n5.hoveredId === r5.id || r5.children !== void 0 && (n5.hoveredId && r5.children.includes(n5.hoveredId) || r5.children.some((c5) => n5.selectedIds.includes(c5))) };
  e5.push(l7), r5.children && (l7.children = [], r5.children.map((c5) => t5[c5]).filter((c5) => t5[c5.id]).sort((c5, m6) => c5.childIndex - m6.childIndex).forEach((c5) => st(c5, l7.children, t5, n5, o5, l7.isGhost, l7.isSelected || l7.isChildOfSelected, a7)));
}
function on(r5, e5) {
  return C3.boundsContain(e5, r5) || C3.boundsCollide(e5, r5);
}
function at(r5, e5, t5, n5) {
  let { callbacks: o5, shapeUtils: i4, bounds: s5 } = R3(), a7 = ye2.useRef(), d6 = ye2.useRef(-1), l7 = ye2.useRef(/* @__PURE__ */ new Set()), c5 = ye2.useRef(/* @__PURE__ */ new Set()), { selectedIds: m6, camera: p6 } = e5, [u5, y6] = e.sub(e.div([0, 0], p6.zoom), p6.point), [T5, v6] = e.sub(e.div([s5.width, s5.height], p6.zoom), p6.point), x5 = { minX: u5, minY: y6, maxX: T5, maxY: v6, height: T5 - u5, width: v6 - y6 }, f5 = c5.current, L5 = l7.current;
  f5.clear(), L5.clear(), Object.values(r5.shapes).filter((b6) => i4[b6.type].isStateful || m6.includes(b6.id) || on(i4[b6.type].getBounds(b6), x5)).forEach((b6) => {
    if (b6.parentId === r5.id) {
      L5.add(b6.id), f5.add(b6);
      return;
    }
    let P5 = r5.shapes[b6.parentId];
    if (P5 === void 0)
      throw Error(`A shape (${b6.id}) has a parent (${b6.parentId}) that does not exist!`);
    L5.add(P5.id), f5.add(P5);
  }), f5.size !== d6.current && (a7.current && clearTimeout(a7.current), a7.current = requestAnimationFrame(() => {
    var b6;
    (b6 = o5.onRenderCountChange) == null || b6.call(o5, Array.from(L5.values()));
  }), d6.current = f5.size);
  let X3 = e5.bindingId ? r5.bindings[e5.bindingId].toId : void 0, S4 = [];
  return f5.forEach((b6) => {
    if (b6 === void 0)
      throw Error("Rendered shapes included a missing shape");
    st(b6, S4, r5.shapes, e5, t5, b6.isGhost, false, n5, X3);
  }), S4.sort((b6, P5) => b6.shape.childIndex - P5.shape.childIndex), S4;
}
var ze = /* @__PURE__ */ new Map();
function rn(r5, e5) {
  return Object.keys(e5).reduce((t5, n5) => {
    let o5 = e5[n5];
    return o5 ? t5 + `${`--${r5}-${n5}`}: ${o5};
` : t5;
  }, "");
}
function sn(r5, e5, t5 = ":root") {
  ve.useLayoutEffect(() => {
    let n5 = document.createElement("style"), o5 = rn(r5, e5);
    return n5.setAttribute("id", `${r5}-theme`), n5.setAttribute("data-selector", t5), n5.innerHTML = `
        ${t5} {
          ${o5}
        }
      `, document.head.appendChild(n5), () => {
      n5 && document.head.contains(n5) && document.head.removeChild(n5);
    };
  }, [r5, e5, t5]);
}
function an(r5, e5) {
  ve.useLayoutEffect(() => {
    if (ze.get(r5))
      return () => {
      };
    let t5 = document.createElement("style");
    return t5.innerHTML = e5, t5.setAttribute("id", r5), document.head.appendChild(t5), ze.set(r5, t5), () => {
      t5 && document.head.contains(t5) && (document.head.removeChild(t5), ze.delete(r5));
    };
  }, [r5, e5]);
}
var dn = (r5, ...e5) => r5.reduce((t5, n5, o5) => t5 + n5 + (o5 < e5.length ? e5[o5] : ""), "");
var ln = { accent: "rgb(255, 0, 0)", brushFill: "rgba(0,0,0,.05)", brushStroke: "rgba(0,0,0,.25)", brushDashStroke: "rgba(0,0,0,.6)", selectStroke: "rgb(66, 133, 244)", selectFill: "rgba(65, 132, 244, 0.05)", binding: "rgba(65, 132, 244, 0.12)", background: "rgb(248, 249, 250)", foreground: "rgb(51, 51, 51)", grid: "rgba(144, 144, 144, 1)" };
var cn = dn`
  .tl-container {
    --tl-zoom: 1;
    --tl-scale: calc(1 / var(--tl-zoom));
    --tl-padding: calc(64px * max(1, var(--tl-scale)));
    --tl-performance-all: auto;
    --tl-performance-selected: auto;
    position: relative;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
    max-width: 100%;
    max-height: 100%;
    box-sizing: border-box;
    padding: 0px;
    margin: 0px;
    z-index: 100;
    overflow: hidden;
    touch-action: none;
    overscroll-behavior: none;
    background-color: var(--tl-background);
  }
  .tl-container * {
    box-sizing: border-box;
  }
  .tl-overlay {
    position: absolute;
    width: 100%;
    height: 100%;
    touch-action: none;
    pointer-events: none;
  }
  .tl-grid {
    position: absolute;
    width: 100%;
    height: 100%;
    touch-action: none;
    pointer-events: none;
    user-select: none;
  }
  .tl-snap-line {
    stroke: var(--tl-accent);
    stroke-width: calc(1px * var(--tl-scale));
  }
  .tl-snap-point {
    stroke: var(--tl-accent);
    stroke-width: calc(1px * var(--tl-scale));
  }
  .tl-canvas {
    position: absolute;
    width: 100%;
    height: 100%;
    touch-action: none;
    pointer-events: all;
    overflow: clip;
  }
  .tl-layer {
    position: absolute;
    top: 0px;
    left: 0px;
    height: 0px;
    width: 0px;
    contain: layout style size;
  }
  .tl-absolute {
    position: absolute;
    top: 0px;
    left: 0px;
    transform-origin: center center;
    contain: layout style size;
  }
  .tl-positioned {
    position: absolute;
    top: 0px;
    left: 0px;
    transform-origin: center center;
    pointer-events: none;
    display: flex;
    align-items: center;
    justify-content: center;
    contain: layout style size;
    will-change: var(--tl-performance-all);
  }
  .tl-positioned-svg {
    width: 100%;
    height: 100%;
    overflow: hidden;
    contain: layout style size;
  }
  .tl-positioned-div {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    padding: var(--tl-padding);
    overflow: hidden;
    contain: layout style size;
  }
  .tl-positioned-selected {
    will-change: var(--tl-performance-selected);
  }
  .tl-inner-div {
    position: relative;
    width: 100%;
    height: 100%;
  }
  .tl-stroke-hitarea {
    fill: none;
    stroke: transparent;
    stroke-width: calc(24px * var(--tl-scale));
    pointer-events: stroke;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .tl-fill-hitarea {
    fill: transparent;
    stroke: transparent;
    stroke-width: calc(24px * var(--tl-scale));
    pointer-events: all;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .tl-counter-scaled {
    transform: scale(var(--tl-scale));
  }
  .tl-dashed {
    stroke-dasharray: calc(2px * var(--tl-scale)), calc(2px * var(--tl-scale));
  }
  .tl-transparent {
    fill: transparent;
    stroke: transparent;
  }
  .tl-cursor-ns {
    cursor: ns-resize;
  }
  .tl-cursor-ew {
    cursor: ew-resize;
  }
  .tl-cursor-nesw {
    cursor: nesw-resize;
  }
  .tl-cursor-nwse {
    cursor: nwse-resize;
  }
  .tl-corner-handle {
    stroke: var(--tl-selectStroke);
    fill: var(--tl-background);
    stroke-width: calc(1.5px * var(--tl-scale));
  }
  .tl-rotate-handle {
    stroke: var(--tl-selectStroke);
    fill: var(--tl-background);
    stroke-width: calc(1.5px * var(--tl-scale));
    cursor: grab;
  }
  .tl-binding {
    fill: var(--tl-selectFill);
    stroke: var(--tl-selectStroke);
    stroke-width: calc(1px * var(--tl-scale));
    pointer-events: none;
  }
  .tl-user {
    left: calc(-15px * var(--tl-scale));
    top: calc(-15px * var(--tl-scale));
    height: calc(35px * var(--tl-scale));
    width: calc(35px * var(--tl-scale));
    transform: scale(var(--tl-scale));
    pointer-events: none;
    will-change: transform;
  }
  .tl-animated {
    transition: transform 200ms linear;
  }
  .tl-indicator {
    fill: transparent;
    stroke-width: calc(1.5px * var(--tl-scale));
    pointer-events: none;
  }
  .tl-user-indicator-bounds {
    border-style: solid;
    border-width: calc(1px * var(--tl-scale));
  }
  .tl-hovered {
    stroke: var(--tl-selectStroke);
  }
  .tl-selected {
    stroke: var(--tl-selectStroke);
  }
  .tl-locked {
    stroke-dasharray: calc(3px * var(--tl-scale)) calc(3px * var(--tl-scale));
  }
  .tl-editing {
    stroke-width: calc(2.5px * min(5, var(--tl-scale)));
  }
  .tl-performance {
    will-change: transform, contents;
  }
  .tl-clone-target {
    pointer-events: all;
  }
  .tl-clone-target:hover .tl-clone-button {
    opacity: 1;
  }
  .tl-clone-button-target {
    cursor: pointer;
    pointer-events: all;
  }
  .tl-clone-button-target:hover .tl-clone-button {
    fill: var(--tl-selectStroke);
  }
  .tl-clone-button {
    opacity: 0;
    r: calc(8px * var(--tl-scale));
    stroke-width: calc(1.5px * var(--tl-scale));
    stroke: var(--tl-selectStroke);
    fill: var(--tl-background);
  }
  .tl-bounds {
    pointer-events: none;
    contain: layout style size;
  }
  .tl-bounds-bg {
    stroke: none;
    fill: var(--tl-selectFill);
    pointer-events: all;
    contain: layout style size;
  }
  .tl-bounds-center {
    fill: transparent;
    stroke: var(--tl-selectStroke);
    stroke-width: calc(1.5px * var(--tl-scale));
  }
  .tl-brush {
    fill: var(--tl-brushFill);
    stroke: var(--tl-brushStroke);
    stroke-width: calc(1px * var(--tl-scale));
    pointer-events: none;
    contain: layout style size;
  }
  .tl-dashed-brush-line {
    fill: none;
    stroke: var(--tl-brushDashStroke);
    stroke-width: calc(1px * var(--tl-scale));
    pointer-events: none;
  }
  .tl-brush.dashed {
    stroke: none;
  }
  .tl-handle {
    pointer-events: all;
    cursor: grab;
  }
  .tl-handle:hover .tl-handle-bg {
    fill: var(--tl-selectFill);
  }
  .tl-handle:hover .tl-handle-bg > * {
    stroke: var(--tl-selectFill);
  }
  .tl-handle:active .tl-handle-bg {
    cursor: grabbing;
    fill: var(--tl-selectFill);
  }
  .tl-handle:active .tl-handle-bg > * {
    stroke: var(--tl-selectFill);
  }
  .tl-handle {
    fill: var(--tl-background);
    stroke: var(--tl-selectStroke);
    stroke-width: 1.5px;
  }
  .tl-handle-bg {
    fill: transparent;
    stroke: none;
    pointer-events: all;
    r: calc(16px / max(1, var(--tl-zoom)));
  }
  .tl-binding-indicator {
    fill: transparent;
    stroke: var(--tl-binding);
  }
  .tl-centered-g {
    transform: translate(var(--tl-padding), var(--tl-padding));
  }
  .tl-current-parent > *[data-shy='true'] {
    opacity: 1;
  }
  .tl-binding {
    fill: none;
    stroke: var(--tl-selectStroke);
    stroke-width: calc(2px * var(--tl-scale));
  }
  .tl-grid-dot {
    fill: var(--tl-grid);
  }
  .tl-erase-line {
    stroke-linejoin: round;
    stroke-linecap: round;
    pointer-events: none;
    fill: var(--tl-grid);
    opacity: 0.32;
  }
`;
function dt(r5, e5) {
  let t5 = ve.useMemo(() => g2(g2({}, ln), r5), [r5]);
  sn("tl", t5, e5), an("tl-canvas", cn);
}
function _2(r5) {
  let { callbacks: e5, inputs: t5 } = R3(), n5 = pe3.useCallback((d6) => {
    var c5, m6, p6, u5;
    if (d6.dead || (d6.dead = true, !t5.pointerIsValid(d6)))
      return;
    (c5 = d6.currentTarget) == null || c5.setPointerCapture(d6.pointerId);
    let l7 = t5.pointerDown(d6, r5);
    if (d6.button === 2) {
      (m6 = e5.onRightPointBoundsHandle) == null || m6.call(e5, l7, d6);
      return;
    }
    d6.button === 0 && ((p6 = e5.onPointBoundsHandle) == null || p6.call(e5, l7, d6)), (u5 = e5.onPointerDown) == null || u5.call(e5, l7, d6);
  }, [t5, e5, r5]), o5 = pe3.useCallback((d6) => {
    var m6, p6, u5;
    if (d6.dead || (d6.dead = true, d6.button === 2 || !t5.pointerIsValid(d6)))
      return;
    let l7 = t5.pointerUp(d6, r5), c5 = t5.isDoubleClick();
    d6.button === 0 && (c5 && !(l7.altKey || l7.metaKey) && ((m6 = e5.onDoubleClickBoundsHandle) == null || m6.call(e5, l7, d6)), (p6 = e5.onReleaseBoundsHandle) == null || p6.call(e5, l7, d6)), (u5 = e5.onPointerUp) == null || u5.call(e5, l7, d6);
  }, [t5, e5, r5]), i4 = pe3.useCallback((d6) => {
    var c5, m6;
    if (d6.dead || (d6.dead = true, !t5.pointerIsValid(d6)) || d6.buttons === 2)
      return;
    let l7 = t5.pointerMove(d6, r5);
    d6.buttons === 1 && d6.currentTarget.hasPointerCapture(d6.pointerId) && ((c5 = e5.onDragBoundsHandle) == null || c5.call(e5, l7, d6)), (m6 = e5.onPointerMove) == null || m6.call(e5, l7, d6);
  }, [t5, e5, r5]), s5 = pe3.useCallback((d6) => {
    var l7;
    !t5.pointerIsValid(d6) || (l7 = e5.onHoverBoundsHandle) == null || l7.call(e5, t5.pointerEnter(d6, r5), d6);
  }, [t5, e5, r5]), a7 = pe3.useCallback((d6) => {
    var l7;
    !t5.pointerIsValid(d6) || (l7 = e5.onUnhoverBoundsHandle) == null || l7.call(e5, t5.pointerEnter(d6, r5), d6);
  }, [t5, e5, r5]);
  return { onPointerDown: n5, onPointerUp: o5, onPointerEnter: s5, onPointerMove: i4, onPointerLeave: a7 };
}
function lt(r5, e5, t5) {
  let n5 = xe2.useRef(), o5 = xe2.useRef();
  xe2.useLayoutEffect(() => {
    let { zoom: i4, point: s5 } = t5.camera, a7 = i4 !== n5.current, d6 = s5 !== o5.current;
    if (n5.current = i4, o5.current = s5, a7 || d6) {
      let l7 = r5.current;
      if (e5 && "current" in e5) {
        let c5 = e5.current;
        a7 && c5 && c5.style.setProperty("--tl-zoom", i4.toString()), l7 && l7.style.setProperty("transform", `scale(${i4}) translateX(${s5[0]}px) translateY(${s5[1]}px)`);
      }
    }
  }, [t5.camera.zoom, t5.camera.point]);
}
function ct(r5, e5) {
  return [(r5[0] + e5.point[0]) * e5.zoom, (r5[1] + e5.point[1]) * e5.zoom];
}
function Fe(r5, e5) {
  return r5[e5.type];
}
function mt(r5, e5, t5) {
  let { rSelectionBounds: n5 } = R3(), { selectedIds: o5 } = e5, i4 = ut.useRef(), s5, a7 = 0, d6 = false, l7 = false;
  if (o5.length === 1) {
    let m6 = o5[0], p6 = r5.shapes[m6];
    if (!p6)
      throw Error(`selectedIds is set to the id of a shape that doesn't exist: ${m6}`);
    a7 = p6.rotation || 0, d6 = p6.isLocked || false;
    let u5 = Fe(t5, p6);
    s5 = u5.hideBounds ? void 0 : u5.getBounds(p6);
  } else if (o5.length > 1) {
    let m6 = o5.map((p6) => r5.shapes[p6]);
    a7 = 0, d6 = m6.every((p6) => p6.isLocked), s5 = m6.reduce((p6, u5, y6) => y6 === 0 ? Fe(t5, u5).getRotatedBounds(u5) : w2.getExpandedBounds(p6, Fe(t5, u5).getRotatedBounds(u5)), {});
  }
  if (s5) {
    let [m6, p6] = ct([s5.minX, s5.minY], e5.camera), [u5, y6] = ct([s5.maxX, s5.maxY], e5.camera);
    l7 = !!Object.values(r5.bindings).find((T5) => o5.includes(T5.toId) || o5.includes(T5.fromId)), n5.current = { minX: m6, minY: p6, maxX: u5, maxY: y6, width: u5 - m6, height: y6 - p6 };
  } else
    n5.current = null;
  let c5 = i4.current;
  return !c5 || !s5 ? i4.current = s5 : s5 && c5.minX === s5.minX && c5.minY === s5.minY && c5.maxX === s5.maxX && c5.maxY === s5.maxY && (s5 = i4.current), { bounds: s5, rotation: a7, isLocked: d6, isLinked: l7 };
}
function ht(r5) {
  let { inputs: e5, callbacks: t5 } = R3();
  return pt.useMemo(() => ({ onPointerDown: (n5) => {
    var i4, s5, a7;
    if (n5.dead || (n5.dead = true, !e5.pointerIsValid(n5)) || n5.button === 2)
      return;
    (i4 = n5.currentTarget) == null || i4.setPointerCapture(n5.pointerId);
    let o5 = e5.pointerDown(n5, r5);
    n5.button === 0 && ((s5 = t5.onPointHandle) == null || s5.call(t5, o5, n5)), (a7 = t5.onPointerDown) == null || a7.call(t5, o5, n5);
  }, onPointerUp: (n5) => {
    var s5, a7, d6, l7;
    if (n5.dead || (n5.dead = true, !e5.pointerIsValid(n5)) || n5.button === 2)
      return;
    let o5 = e5.isDoubleClick(), i4 = e5.pointerUp(n5, r5);
    n5.currentTarget.hasPointerCapture(n5.pointerId) && ((s5 = n5.currentTarget) == null || s5.releasePointerCapture(n5.pointerId), n5.button === 0 && (o5 && !(i4.altKey || i4.metaKey) && ((a7 = t5.onDoubleClickHandle) == null || a7.call(t5, i4, n5)), (d6 = t5.onReleaseHandle) == null || d6.call(t5, i4, n5))), (l7 = t5.onPointerUp) == null || l7.call(t5, i4, n5);
  }, onPointerMove: (n5) => {
    var i4, s5;
    if (n5.dead || (n5.dead = true, !e5.pointerIsValid(n5)) || n5.buttons === 2)
      return;
    let o5 = e5.pointerMove(n5, r5);
    n5.buttons === 1 && n5.currentTarget.hasPointerCapture(n5.pointerId) && ((i4 = t5.onDragHandle) == null || i4.call(t5, o5, n5)), (s5 = t5.onPointerMove) == null || s5.call(t5, o5, n5);
  }, onPointerEnter: (n5) => {
    var i4;
    if (!e5.pointerIsValid(n5))
      return;
    let o5 = e5.pointerEnter(n5, r5);
    (i4 = t5.onHoverHandle) == null || i4.call(t5, o5, n5);
  }, onPointerLeave: (n5) => {
    var i4;
    if (!e5.pointerIsValid(n5))
      return;
    let o5 = e5.pointerEnter(n5, r5);
    (i4 = t5.onUnhoverHandle) == null || i4.call(t5, o5, n5);
  } }), [e5, t5, r5]);
}
function Tt(r5) {
  let { bounds: e5 } = R3();
  ft.useEffect(() => {
    let t5 = (i4) => {
      i4.preventDefault();
    }, n5 = (i4) => {
      let s5 = i4.touches[0].pageX, a7 = i4.touches[0].radiusX || 0;
      (s5 - a7 < 10 || s5 + a7 > e5.width - 10) && i4.preventDefault();
    }, o5 = r5.current;
    return o5 ? (o5.addEventListener("gestureend", t5), o5.addEventListener("gesturechange", t5), o5.addEventListener("gesturestart", t5), o5.addEventListener("touchstart", n5), () => {
      o5 && (o5.removeEventListener("gestureend", t5), o5.removeEventListener("gesturechange", t5), o5.removeEventListener("gesturestart", t5), o5.removeEventListener("touchstart", n5));
    }) : () => {
    };
  }, [r5, e5.width]);
}
function Lt() {
  let { callbacks: r5, inputs: e5 } = R3();
  return gt.useMemo(() => ({ onPointerDown: (t5) => {
    var o5, i4, s5, a7;
    if (t5.dead || (t5.dead = true, !e5.pointerIsValid(t5)))
      return;
    if (t5.button === 2) {
      (o5 = r5.onRightPointBounds) == null || o5.call(r5, e5.pointerDown(t5, "bounds"), t5);
      return;
    }
    let n5 = e5.pointerDown(t5, "bounds");
    (i4 = t5.currentTarget) == null || i4.setPointerCapture(t5.pointerId), t5.button === 0 && ((s5 = r5.onPointBounds) == null || s5.call(r5, n5, t5)), (a7 = r5.onPointerDown) == null || a7.call(r5, n5, t5);
  }, onPointerUp: (t5) => {
    var i4, s5, a7, d6;
    if (t5.dead || (t5.dead = true, t5.button === 2) || (e5.activePointer = void 0, !e5.pointerIsValid(t5)))
      return;
    let n5 = e5.isDoubleClick(), o5 = e5.pointerUp(t5, "bounds");
    t5.currentTarget.hasPointerCapture(t5.pointerId) && ((i4 = t5.currentTarget) == null || i4.releasePointerCapture(t5.pointerId)), t5.button === 0 && (n5 && !(o5.altKey || o5.metaKey) && ((s5 = r5.onDoubleClickBounds) == null || s5.call(r5, o5, t5)), (a7 = r5.onReleaseBounds) == null || a7.call(r5, o5, t5)), (d6 = r5.onPointerUp) == null || d6.call(r5, o5, t5);
  }, onPointerMove: (t5) => {
    var o5, i4;
    if (t5.dead || (t5.dead = true, !e5.pointerIsValid(t5)))
      return;
    t5.buttons === 1 && t5.currentTarget.hasPointerCapture(t5.pointerId) && ((o5 = r5.onDragBounds) == null || o5.call(r5, e5.pointerMove(t5, "bounds"), t5));
    let n5 = e5.pointerMove(t5, "bounds");
    (i4 = r5.onPointerMove) == null || i4.call(r5, n5, t5);
  }, onPointerEnter: (t5) => {
    var n5;
    !e5.pointerIsValid(t5) || (n5 = r5.onHoverBounds) == null || n5.call(r5, e5.pointerEnter(t5, "bounds"), t5);
  }, onPointerLeave: (t5) => {
    var n5;
    !e5.pointerIsValid(t5) || (n5 = r5.onUnhoverBounds) == null || n5.call(r5, e5.pointerEnter(t5, "bounds"), t5);
  } }), [e5, r5]);
}
function De(r5, e5 = 0) {
  let t5 = Ke.useRef(null);
  return Ke.useLayoutEffect(() => {
    let n5 = t5.current, o5 = `
    translate(
      calc(${r5.minX}px - var(--tl-padding)),
      calc(${r5.minY}px - var(--tl-padding))
    )
    rotate(${e5 + (r5.rotation || 0)}rad)`;
    n5.style.setProperty("transform", o5), n5.style.setProperty("width", `calc(${Math.floor(r5.width)}px + (var(--tl-padding) * 2))`), n5.style.setProperty("height", `calc(${Math.floor(r5.height)}px + (var(--tl-padding) * 2))`);
  }, [r5, e5]), t5;
}
function vt() {
  let { inputs: r5, callbacks: e5 } = R3();
  yt.useEffect(() => {
    let t5 = (o5) => {
      var i4;
      (i4 = e5.onKeyDown) == null || i4.call(e5, o5.key, r5.keydown(o5), o5);
    }, n5 = (o5) => {
      var i4;
      r5.keyup(o5), (i4 = e5.onKeyUp) == null || i4.call(e5, o5.key, r5.keyup(o5), o5);
    };
    return window.addEventListener("keydown", t5), window.addEventListener("keyup", n5), () => {
      window.removeEventListener("keydown", t5), window.removeEventListener("keyup", n5);
    };
  }, [r5, e5]);
}
function bt(r5, e5) {
  xt.useLayoutEffect(() => {
    if (e5 && "current" in e5) {
      let t5 = e5 == null ? void 0 : e5.current;
      if (!t5)
        return;
      switch (r5) {
        case "transform_selected": {
          t5.style.setProperty("--tl-performance-all", "auto"), t5.style.setProperty("--tl-performance-selected", "transform, contents");
          break;
        }
        case "transform_all": {
          t5.style.setProperty("--tl-performance-all", "transform, contents"), t5.style.setProperty("--tl-performance-selected", "transform, contents");
          break;
        }
        case "translate_selected": {
          t5.style.setProperty("--tl-performance-all", "auto"), t5.style.setProperty("--tl-performance-selected", "transform");
          break;
        }
        case "translate_all": {
          t5.style.setProperty("--tl-performance-all", "transform"), t5.style.setProperty("--tl-performance-selected", "transform");
          break;
        }
        default:
          t5.style.setProperty("--tl-performance-all", "auto"), t5.style.setProperty("--tl-performance-selected", "auto");
      }
    }
  }, [r5]);
}
function un(a7) {
  var d6 = a7, { id: r5, bounds: e5, rotation: t5 = 0, isGhost: n5 = false, isSelected: o5 = false, children: i4 } = d6, s5 = O2(d6, ["id", "bounds", "rotation", "isGhost", "isSelected", "children"]);
  let l7 = De(e5, t5);
  return Ye.createElement("div", g2({ id: r5, ref: l7, className: `tl-positioned${n5 ? " tl-ghost" : ""}${o5 ? " tl-positioned-selected" : ""}`, "aria-label": "container", "data-testid": "container" }, s5), i4);
}
var Z = Ye.memo(un);
function mn({ brush: r5, zoom: e5, dashed: t5 }) {
  return z2.createElement(Z, { bounds: r5, rotation: 0 }, z2.createElement(te, null, z2.createElement("rect", { className: "tl-brush" + (t5 ? " dashed" : ""), opacity: 1, x: 0, y: 0, width: r5.width, height: r5.height, "aria-label": "brush" }), t5 && z2.createElement("g", { className: "tl-dashed-brush-line" }, z2.createElement(Xe, { x1: 0, y1: 0, x2: r5.width, y2: 0, zoom: e5 }), z2.createElement(Xe, { x1: r5.width, y1: 0, x2: r5.width, y2: r5.height, zoom: e5 }), z2.createElement(Xe, { x1: 0, y1: r5.height, x2: r5.width, y2: r5.height, zoom: e5 }), z2.createElement(Xe, { x1: 0, y1: 0, x2: 0, y2: r5.height, zoom: e5 }))));
}
var Pt = z2.memo(mn);
function Xe({ x1: r5, y1: e5, x2: t5, y2: n5, zoom: o5 }) {
  let i4 = w2.getPerfectDashProps(Math.hypot(t5 - r5, n5 - e5), 1 / o5, "dashed", 1, true, 3);
  return z2.createElement("line", { x1: r5, y1: e5, x2: t5, y2: n5, strokeWidth: 1 / o5, strokeDasharray: i4.strokeDasharray, strokeDashoffset: i4.strokeDashoffset });
}
var Rt = W2.memo(({ color: r5 }) => W2.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 35 35", fill: "none", fillRule: "evenodd" }, W2.createElement("g", { fill: "rgba(0,0,0,.2)", transform: "translate(1,1)" }, W2.createElement("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }), W2.createElement("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })), W2.createElement("g", { fill: "white" }, W2.createElement("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }), W2.createElement("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })), W2.createElement("g", { fill: r5 }, W2.createElement("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }), W2.createElement("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" }))));
function hn({ points: r5, zoom: e5 }) {
  if (r5.length === 0)
    return null;
  let t5 = w2.getSvgPathFromStroke(_e(r5, { size: 16 / e5, start: { taper: true } }));
  return Ue.createElement("path", { d: t5, className: "tl-erase-line" });
}
var Et = Ue.memo(hn);
var Bt = [[-1, 0.15, 64], [0.05, 0.375, 16], [0.15, 1, 4], [0.7, 2.5, 1]];
function Ct({ grid: r5, camera: e5 }) {
  return he2.createElement("svg", { className: "tl-grid", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, he2.createElement("defs", null, Bt.map(([t5, n5, o5], i4) => {
    let s5 = o5 * r5 * e5.zoom, a7 = e5.point[0] * e5.zoom, d6 = e5.point[1] * e5.zoom, l7 = a7 > 0 ? a7 % s5 : s5 + a7 % s5, c5 = d6 > 0 ? d6 % s5 : s5 + d6 % s5, m6 = e5.zoom < n5 ? w2.modulate(e5.zoom, [t5, n5], [0, 1]) : 1;
    return he2.createElement("pattern", { key: `grid-pattern-${i4}`, id: `grid-${i4}`, width: s5, height: s5, patternUnits: "userSpaceOnUse" }, he2.createElement("circle", { className: "tl-grid-dot", cx: l7, cy: c5, r: 1, opacity: m6 }));
  })), Bt.map((t5, n5) => he2.createElement("rect", { key: `grid-rect-${n5}`, width: "100%", height: "100%", fill: `url(#grid-${n5})` })));
}
function fn({ camera: { zoom: r5, point: e5 }, children: t5 }) {
  let n5 = 2.5 / r5;
  return ne.createElement("svg", { className: "tl-overlay" }, ne.createElement("defs", null, ne.createElement("g", { id: "tl-snap-point" }, ne.createElement("path", { className: "tl-snap-point", d: `M ${-n5},${-n5} L ${n5},${n5} M ${-n5},${n5} L ${n5},${-n5}` }))), ne.createElement("g", { transform: `scale(${r5}) translate(${e5})` }, t5));
}
var St = ne.memo(fn);
var te = ae2.memo(ae2.forwardRef(function(s5, i4) {
  var a7 = s5, { id: e5, className: t5 = "", children: n5 } = a7, o5 = O2(a7, ["id", "className", "children"]);
  return ae2.createElement("svg", g2({ ref: i4, className: `tl-positioned-svg ${t5}` }, o5), ae2.createElement("g", { id: e5, className: "tl-centered-g" }, n5));
}));
function Tn({ bounds: r5, isLocked: e5, isHidden: t5 }) {
  return $e.createElement("rect", { className: ["tl-bounds-center", e5 ? "tl-dashed" : ""].join(" "), x: -1, y: -1, width: r5.width + 2, height: r5.height + 2, opacity: t5 ? 0 : 1, pointerEvents: "none", "aria-label": "center handle" });
}
var wt = $e.memo(Tn);
var gn = { right: 0, bottomRight: 45, bottom: 90, bottomLeft: 135, left: 180, topLeft: 225, top: 270, topRight: 315 };
function Ln({ bounds: r5, side: e5, targetSize: t5, size: n5 }) {
  let o5 = t5 * 2, i4 = { left: -o5, topLeft: -o5, bottomLeft: -o5, right: r5.width, topRight: r5.width, bottomRight: r5.width, top: r5.width / 2 - o5 / 2, bottom: r5.width / 2 - o5 / 2 }[e5], s5 = { left: r5.height / 2 - o5 / 2, right: r5.height / 2 - o5 / 2, top: -o5 * 2, topLeft: -o5, topRight: -o5, bottom: r5.height, bottomLeft: r5.height, bottomRight: r5.height }[e5], { callbacks: a7, inputs: d6 } = R3(), l7 = q2.useCallback((c5) => {
    var p6;
    c5.stopPropagation();
    let m6 = d6.pointerDown(c5, e5);
    (p6 = a7.onShapeClone) == null || p6.call(a7, m6, c5);
  }, [a7.onShapeClone]);
  return q2.createElement("g", { className: "tl-clone-target", transform: `translate(${i4}, ${s5})`, "aria-label": "clone button" }, q2.createElement("rect", { className: "tl-transparent", width: t5 * 2, height: t5 * 2 }), q2.createElement("g", { className: "tl-clone-button-target", onPointerDown: l7, transform: `translate(${t5}, ${t5}) rotate(${gn[e5]})` }, q2.createElement("circle", { className: "tl-transparent ", r: t5 }), q2.createElement("path", { className: "tl-clone-button", d: `M -${n5 / 2},-${n5 / 2} L ${n5 / 2},0 -${n5 / 2},${n5 / 2} Z`, strokeLinejoin: "round" })));
}
var Q2 = q2.memo(Ln);
function yn({ targetSize: r5, size: e5, bounds: t5 }) {
  return $3.createElement($3.Fragment, null, $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: "top" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: "right" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: "bottom" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: "left" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: "topLeft" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: "topRight" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: "bottomLeft" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: "bottomRight" }));
}
var Ht = $3.memo(yn);
var vn = { ["top_left_corner"]: "tl-cursor-nwse", ["top_right_corner"]: "tl-cursor-nesw", ["bottom_right_corner"]: "tl-cursor-nwse", ["bottom_left_corner"]: "tl-cursor-nesw" };
function xn({ size: r5, targetSize: e5, isHidden: t5, corner: n5, bounds: o5 }) {
  let i4 = _2(n5), s5 = n5 === "top_left_corner" || n5 === "top_right_corner", a7 = n5 === "top_left_corner" || n5 === "bottom_left_corner";
  return fe.createElement("g", { opacity: t5 ? 0 : 1 }, fe.createElement("rect", g2({ className: "tl-transparent " + (t5 ? "" : vn[n5]), "aria-label": "corner transparent", x: (a7 ? -1 : o5.width + 1) - e5, y: (s5 ? -1 : o5.height + 1) - e5, width: e5 * 2, height: e5 * 2, pointerEvents: t5 ? "none" : "all" }, i4)), fe.createElement("rect", { className: "tl-corner-handle", "aria-label": "corner handle", x: (a7 ? -1 : o5.width + 1) - r5 / 2, y: (s5 ? -1 : o5.height + 1) - r5 / 2, width: r5, height: r5, pointerEvents: "none" }));
}
var be2 = fe.memo(xn);
var bn = { ["top_edge"]: "tl-cursor-ns", ["right_edge"]: "tl-cursor-ew", ["bottom_edge"]: "tl-cursor-ns", ["left_edge"]: "tl-cursor-ew" };
function Pn({ size: r5, isHidden: e5, bounds: t5, edge: n5 }) {
  let o5 = _2(n5), i4 = n5 === "top_edge" || n5 === "bottom_edge", s5 = n5 === "right_edge" || n5 === "bottom_edge", { height: a7, width: d6 } = t5;
  return Ne.createElement("rect", g2({ pointerEvents: e5 ? "none" : "all", className: "tl-transparent tl-edge-handle " + (e5 ? "" : bn[n5]), "aria-label": `${n5} handle`, opacity: e5 ? 0 : 1, x: i4 ? r5 / 2 : (s5 ? d6 + 1 : -1) - r5 / 2, y: i4 ? (s5 ? a7 + 1 : -1) - r5 / 2 : r5 / 2, width: i4 ? Math.max(0, d6 + 1 - r5) : r5, height: i4 ? r5 : Math.max(0, a7 + 1 - r5) }, o5));
}
var Pe = Ne.memo(Pn);
function Rn({ size: r5, bounds: e5, isHidden: t5 }) {
  let n5 = _2("left"), o5 = _2("center"), i4 = _2("right");
  return F2.createElement("g", { cursor: "grab", transform: `translate(${e5.width / 2 - r5 * 4}, ${e5.height + r5 * 2})`, "aria-label": "link handle" }, F2.createElement("g", { className: "tl-transparent", pointerEvents: t5 ? "none" : "all" }, F2.createElement("rect", g2({ x: 0, y: 0, width: r5 * 2, height: r5 * 2 }, n5)), F2.createElement("rect", g2({ x: r5 * 3, y: 0, width: r5 * 2, height: r5 * 2 }, o5)), F2.createElement("rect", g2({ x: r5 * 6, y: 0, width: r5 * 2, height: r5 * 2 }, i4))), F2.createElement("g", { className: "tl-rotate-handle", transform: `translate(${r5 / 2}, ${r5 / 2})`, "aria-label": "link rotate handle" }, F2.createElement("path", { d: `M 0,${r5 / 2} L ${r5},${r5} ${r5},0 Z`, pointerEvents: "none", opacity: t5 ? 0 : 1 }), F2.createElement("path", { transform: `translate(${r5 * 3}, 0)`, d: `M 0,0 L ${r5},0 ${r5 / 2},${r5} Z`, pointerEvents: "none", opacity: t5 ? 0 : 1 }), F2.createElement("path", { transform: `translate(${r5 * 6}, 0)`, d: `M ${r5},${r5 / 2} L 0,0 0,${r5} Z`, pointerEvents: "none", opacity: t5 ? 0 : 1 })));
}
var It = F2.memo(Rn);
function En({ bounds: r5, targetSize: e5, size: t5, isHidden: n5 }) {
  let o5 = _2("rotate");
  return Te2.createElement("g", { cursor: "grab", opacity: n5 ? 0 : 1 }, Te2.createElement("circle", g2({ className: "tl-transparent", "aria-label": "rotate handle transparent", cx: r5.width / 2, cy: t5 * -2, r: e5, pointerEvents: n5 ? "none" : "all" }, o5)), Te2.createElement("circle", { className: "tl-rotate-handle", "aria-label": "rotate handle", cx: r5.width / 2, cy: t5 * -2, r: t5 / 2, pointerEvents: "none" }));
}
var Mt = Te2.memo(En);
var Bn = function({ zoom: e5, bounds: t5, viewportWidth: n5, rotation: o5, isHidden: i4, isLocked: s5, hideCloneHandles: a7, hideResizeHandles: d6, hideRotateHandle: l7, hideBindingHandles: c5 }) {
  let m6 = (n5 < 768 ? 16 : 8) / e5, p6 = 8 / e5, u5 = Math.min(t5.width, t5.height) * e5, y6 = !l7 && !i4 && !s5 && u5 > 32, T5 = !i4 && !s5 && u5 > 24, v6 = !i4 && !s5 && u5 > 20, x5 = !a7 && u5 > 24;
  return K3.createElement(Z, { bounds: t5, rotation: o5 }, K3.createElement(te, null, K3.createElement(wt, { bounds: t5, isLocked: s5, isHidden: i4 }), !d6 && !s5 ? K3.createElement(K3.Fragment, null, K3.createElement(Pe, { targetSize: m6, size: p6, bounds: t5, edge: "top_edge", isHidden: !T5 }), K3.createElement(Pe, { targetSize: m6, size: p6, bounds: t5, edge: "right_edge", isHidden: !T5 }), K3.createElement(Pe, { targetSize: m6, size: p6, bounds: t5, edge: "bottom_edge", isHidden: !T5 }), K3.createElement(Pe, { targetSize: m6, size: p6, bounds: t5, edge: "left_edge", isHidden: !T5 }), K3.createElement(be2, { targetSize: m6, size: p6, bounds: t5, isHidden: i4 || !v6, corner: "top_left_corner" }), K3.createElement(be2, { targetSize: m6, size: p6, bounds: t5, isHidden: i4 || !v6, corner: "top_right_corner" }), K3.createElement(be2, { targetSize: m6, size: p6, bounds: t5, isHidden: i4 || !v6, corner: "bottom_right_corner" }), K3.createElement(be2, { targetSize: m6, size: p6, bounds: t5, isHidden: i4 || !v6, corner: "bottom_left_corner" })) : null, y6 && K3.createElement(Mt, { targetSize: m6, size: p6, bounds: t5, isHidden: !T5 }), x5 && K3.createElement(Ht, { bounds: t5, targetSize: m6, size: p6 }), !c5 && K3.createElement(It, { targetSize: m6, size: p6, bounds: t5, isHidden: !T5 })));
};
var kt = K3.memo(Bn);
function Cn({ bounds: r5, rotation: e5, isHidden: t5 }) {
  let n5 = Lt();
  return ge2.createElement(Z, { bounds: r5, rotation: e5 }, ge2.createElement(te, null, ge2.createElement("rect", g2({ className: "tl-bounds-bg", "aria-label": "bounds bg", width: r5.width, height: r5.height, opacity: t5 ? 0 : 1 }, n5))));
}
var Kt = ge2.memo(Cn);
function Sn({ id: r5, point: e5 }) {
  let t5 = ht(r5);
  return oe.createElement(Z, { bounds: w2.translateBounds({ minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 }, e5) }, oe.createElement(te, null, oe.createElement("g", g2({ className: "tl-handle", "aria-label": "handle" }, t5), oe.createElement("circle", { className: "tl-handle-bg", pointerEvents: "all" }), oe.createElement("circle", { className: "tl-counter-scaled tl-handle", pointerEvents: "none", r: 4 }))));
}
var Dt = oe.memo(Sn);
function wn({ shape: r5, zoom: e5 }) {
  if (r5.handles === void 0)
    return null;
  let t5 = null, n5 = Object.values(r5.handles).reduce((o5, i4) => {
    let s5 = e.add(i4.point, r5.point);
    return (!t5 || e.dist(s5, t5) * e5 >= 32) && (o5.push(i4), t5 = s5), o5;
  }, []);
  return n5.length === 1 ? null : de3.createElement(de3.Fragment, null, n5.map((o5) => de3.createElement(Dt, { key: r5.id + "_" + o5.id, id: o5.id, point: e.add(o5.point, r5.point) })));
}
var Yt = de3.memo(wn);
function Hn(r5) {
  let e5 = r5.utils.getRef(r5.shape);
  return We.createElement(r5.utils.Component, g2({ ref: e5 }, r5));
}
var Xt = We.memo(Hn, (r5, e5) => r5.isHovered !== e5.isHovered || r5.isSelected !== e5.isSelected || r5.isEditing !== e5.isEditing || r5.isBinding !== e5.isBinding || r5.isGhost !== e5.isGhost || r5.meta !== e5.meta ? false : e5.shape !== r5.shape ? !e5.utils.shouldRender(e5.shape, r5.shape) : true);
function In(o5) {
  var i4 = o5, { shape: r5, utils: e5, meta: t5 } = i4, n5 = O2(i4, ["shape", "utils", "meta"]);
  let { callbacks: s5 } = R3(), a7 = e5.getBounds(r5), d6 = it(r5.id);
  return Re.createElement(Z, { id: r5.id, bounds: a7, rotation: r5.rotation, "data-shape": r5.type, isGhost: n5.isGhost, isSelected: n5.isSelected }, Re.createElement(Xt, g2({ shape: r5, utils: e5, meta: t5, events: d6, bounds: a7, onShapeChange: s5.onShapeChange, onShapeBlur: s5.onShapeBlur }, n5)));
}
var Ut = Re.memo(In);
function Mn(i4) {
  var s5 = i4, { shape: r5, utils: e5, meta: t5, children: n5 } = s5, o5 = O2(s5, ["shape", "utils", "meta", "children"]);
  return re.createElement(re.Fragment, null, re.createElement(Ut, g2({ shape: r5, utils: e5[r5.type], meta: t5 }, o5)), n5 && n5.map((a7) => re.createElement(je, g2({ key: a7.shape.id, utils: e5 }, a7))));
}
var je = re.memo(Mn);
function kn({ isHovered: r5 = false, isSelected: e5 = false, isEditing: t5 = false, shape: n5, user: o5, meta: i4 }) {
  let { shapeUtils: s5 } = R3(), a7 = s5[n5.type], d6 = a7.getBounds(n5), l7 = De(d6, n5.rotation);
  return le2.createElement("div", { ref: l7, draggable: false, className: ["tl-indicator", "tl-absolute", e5 && !o5 ? "tl-selected" : "tl-hovered", t5 ? "tl-editing" : "", n5.isLocked ? "tl-locked" : ""].join(" ") }, le2.createElement("svg", { width: "100%", height: "100%" }, le2.createElement("g", { className: "tl-centered-g", stroke: o5 == null ? void 0 : o5.color }, le2.createElement(a7.Indicator, { shape: n5, meta: i4, user: o5, bounds: d6, isSelected: e5, isHovered: r5 }))));
}
var Ee = le2.memo(kn);
function Kn({ page: r5, pageState: e5, assets: t5, hideBounds: n5, hideHandles: o5, hideIndicators: i4, hideBindingHandles: s5, hideCloneHandles: a7, hideRotateHandle: d6, hideResizeHandles: l7, meta: c5 }) {
  let { bounds: m6, shapeUtils: p6 } = R3(), u5 = at(r5, e5, t5, c5), { bounds: y6, isLinked: T5, isLocked: v6, rotation: x5 } = mt(r5, e5, p6), { selectedIds: f5, hoveredId: L5, editingId: Y3, camera: { zoom: X3 } } = e5, S4 = i4, b6 = true, P5 = false, B5, M3 = f5.map((I3) => r5.shapes[I3]);
  if (M3.length === 1) {
    let I3 = M3[0];
    P5 = Y3 === I3.id, P5 && (S4 = true);
    let A6 = p6[I3.type];
    b6 = a7 || !A6.showCloneHandles, I3.handles !== void 0 && !P5 && (B5 = I3);
  }
  return G3.createElement(G3.Fragment, null, y6 && G3.createElement(Kt, { bounds: y6, rotation: x5, isHidden: n5 }), u5.map((I3) => G3.createElement(je, g2({ key: I3.shape.id, utils: p6 }, I3))), !S4 && M3.map((I3) => G3.createElement(Ee, { key: "selected_" + I3.id, shape: I3, meta: c5, isSelected: true, isEditing: P5 })), !S4 && L5 && L5 !== Y3 && G3.createElement(Ee, { key: "hovered_" + L5, shape: r5.shapes[L5], meta: c5, isHovered: true }), y6 && G3.createElement(kt, { zoom: X3, bounds: y6, viewportWidth: m6.width, isLocked: v6, rotation: x5, isHidden: n5, hideRotateHandle: d6, hideResizeHandles: l7, hideBindingHandles: s5 || !T5, hideCloneHandles: b6 }), !o5 && B5 && G3.createElement(Yt, { shape: B5, zoom: X3 }));
}
var $t = G3.memo(Kn);
function Dn({ snapLines: r5 }) {
  return j2.createElement(j2.Fragment, null, r5.map((e5, t5) => j2.createElement(Xn, { key: t5, snapLine: e5 })));
}
function Yn({ snapLine: r5 }) {
  let e5 = w2.getBoundsFromPoints(r5);
  return j2.createElement(j2.Fragment, null, j2.createElement("line", { className: "tl-snap-line", x1: e5.minX, y1: e5.minY, x2: e5.maxX, y2: e5.maxY }), r5.map(([t5, n5], o5) => j2.createElement("use", { key: o5, href: "#tl-snap-point", x: t5, y: n5 })));
}
var Xn = j2.memo(Yn);
var Nt = j2.memo(Dn);
function Wt({ user: r5, Cursor: e5 }) {
  let t5 = ce3.useRef(null);
  return ce3.useLayoutEffect(() => {
    t5.current && (t5.current.style.transform = `translate(${r5.point[0]}px, ${r5.point[1]}px)`);
  }, [r5.point]), ce3.createElement("div", { ref: t5, className: `tl-absolute tl-user tl-counter-scaled ${r5.session ? "" : "tl-animated"}` }, ce3.createElement(e5, { id: r5.id, color: r5.color, metadata: r5.metadata }));
}
function At({ userId: r5, users: e5, Cursor: t5 }) {
  return Be.createElement(Be.Fragment, null, Object.values(e5).filter((n5) => n5 && n5.id !== r5).map((n5) => Be.createElement(Wt, { key: n5.id, user: n5, Cursor: t5 })));
}
function Ot({ userId: r5, users: e5, meta: t5, page: n5 }) {
  let { shapeUtils: o5 } = R3();
  return ie3.createElement(ie3.Fragment, null, Object.values(e5).filter(Boolean).filter((i4) => i4.id !== r5 && i4.selectedIds.length > 0).map((i4) => {
    let s5 = i4.selectedIds.map((d6) => n5.shapes[d6]).filter(Boolean);
    if (s5.length === 0)
      return null;
    let a7 = w2.getCommonBounds(s5.map((d6) => o5[d6.type].getBounds(d6)));
    return ie3.createElement(ie3.Fragment, { key: i4.id + "_shapes" }, ie3.createElement("div", { className: "tl-absolute tl-user-indicator-bounds", style: { backgroundColor: i4.color + "0d", borderColor: i4.color + "78", transform: `translate(${a7.minX}px, ${a7.minY}px)`, width: a7.width, height: a7.height, pointerEvents: "none" } }), s5.map((d6) => ie3.createElement(Ee, { key: `${i4.id}_${d6.id}_indicator`, shape: d6, user: i4, meta: t5, isHovered: true })));
  }));
}
var Un = (r5) => {
  let e5 = r5.parentElement;
  for (; e5; ) {
    if (e5 === document.body)
      return document;
    let { overflowY: t5 } = window.getComputedStyle(e5);
    if (e5.scrollHeight > e5.clientHeight && (t5 === "auto" || t5 === "scroll" || t5 === "overlay"))
      return e5;
    e5 = e5.parentElement;
  }
  return document;
};
function Vt(r5, e5) {
  let { inputs: t5, callbacks: n5 } = R3(), o5 = se3.useRef(false), i4 = se3.useCallback(() => {
    var s5, a7;
    if (o5.current) {
      let d6 = (s5 = r5.current) == null ? void 0 : s5.getBoundingClientRect();
      if (d6) {
        let l7 = { minX: d6.left, maxX: d6.left + d6.width, minY: d6.top, maxY: d6.top + d6.height, width: d6.width, height: d6.height };
        t5.bounds = l7, e5(l7), (a7 = n5.onBoundsChange) == null || a7.call(n5, l7);
      }
    } else
      o5.current = true;
  }, [r5, t5, n5.onBoundsChange]);
  se3.useEffect(() => {
    let s5 = r5.current ? Un(r5.current) : document, a7 = C3.debounce(i4, 100);
    return s5.addEventListener("scroll", a7), window.addEventListener("resize", a7), () => {
      s5.removeEventListener("scroll", a7), window.removeEventListener("resize", a7);
    };
  }, []), se3.useEffect(() => {
    let s5 = new ResizeObserver((a7) => {
      t5.isPinching || a7[0].contentRect && i4();
    });
    return r5.current && s5.observe(r5.current), () => {
      s5.disconnect();
    };
  }, [r5, t5]), se3.useEffect(() => {
    i4();
  }, [r5]);
}
function $n({ id: r5, page: e5, pageState: t5, assets: n5, snapLines: o5, eraseLine: i4, grid: s5, users: a7, userId: d6, components: l7 = {}, meta: c5, performanceMode: m6, showDashedBrush: p6, hideHandles: u5, hideBounds: y6, hideIndicators: T5, hideBindingHandles: v6, hideCloneHandles: x5, hideResizeHandles: f5, hideRotateHandle: L5, hideGrid: Y3, onBoundsChange: X3, hideCursors: S4 }) {
  var A6;
  let b6 = D2.useRef(null), P5 = D2.useRef(t5.camera.zoom);
  P5.current = t5.camera.zoom, tt(P5, b6), Vt(b6, X3), nt(), Tt(b6);
  let B5 = D2.useRef(null), M3 = D2.useRef(null);
  lt(M3, B5, t5), bt(m6, B5), vt();
  let I3 = rt();
  return D2.createElement("div", { id: r5, className: "tl-container", ref: B5 }, D2.createElement("div", g2({ id: "canvas", className: "tl-absolute tl-canvas", ref: b6 }, I3), !Y3 && s5 && D2.createElement(Ct, { grid: s5, camera: t5.camera }), D2.createElement("div", { ref: M3, className: "tl-absolute tl-layer", "data-testid": "layer" }, D2.createElement($t, { page: e5, pageState: t5, assets: n5, hideBounds: y6, hideIndicators: T5, hideHandles: u5, hideBindingHandles: v6, hideCloneHandles: x5, hideResizeHandles: f5, hideRotateHandle: L5, meta: c5 }), a7 && d6 && D2.createElement(Ot, { userId: d6, users: a7, page: e5, meta: c5 }), t5.brush && D2.createElement(Pt, { brush: t5.brush, dashed: p6, zoom: t5.camera.zoom }), a7 && !S4 && D2.createElement(At, { userId: d6, users: a7, Cursor: (A6 = l7 == null ? void 0 : l7.Cursor) != null ? A6 : Rt })), D2.createElement(St, { camera: t5.camera }, i4 && D2.createElement(Et, { points: i4, zoom: t5.camera.zoom }), o5 && D2.createElement(Nt, { snapLines: o5 }))));
}
var zt = D2.memo($n);
var Nn = 250;
var H2 = class {
  constructor() {
    E2(this, "pointer");
    E2(this, "keyboard");
    E2(this, "keys", {});
    E2(this, "isPinching", false);
    E2(this, "bounds", { minX: 0, maxX: 640, minY: 0, maxY: 480, width: 640, height: 480 });
    E2(this, "pointerUpTime", 0);
    E2(this, "activePointer");
    E2(this, "panStart", (e5) => {
      var a7, d6;
      let { shiftKey: t5, ctrlKey: n5, metaKey: o5, altKey: i4 } = e5, s5 = { target: "wheel", pointerId: ((a7 = this.pointer) == null ? void 0 : a7.pointerId) || 0, origin: ((d6 = this.pointer) == null ? void 0 : d6.origin) || [0, 0], delta: [0, 0], pressure: 0.5, point: H2.getPoint(e5, this.bounds), shiftKey: t5, ctrlKey: n5, metaKey: o5, altKey: i4, spaceKey: this.keys[" "] };
      return this.pointer = s5, s5;
    });
    E2(this, "pan", (e5, t5) => {
      if (!this.pointer || this.pointer.target !== "wheel")
        return this.panStart(t5);
      let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = t5, a7 = this.pointer, d6 = H2.getPoint(t5, this.bounds), l7 = U2(g2({}, a7), { target: "wheel", delta: e5, point: d6, shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5, spaceKey: this.keys[" "] });
      return this.pointer = l7, l7;
    });
    E2(this, "keydown", (e5) => {
      var s5, a7;
      let { shiftKey: t5, ctrlKey: n5, metaKey: o5, altKey: i4 } = e5;
      return this.keys[e5.key] = true, { point: ((s5 = this.pointer) == null ? void 0 : s5.point) || [0, 0], origin: ((a7 = this.pointer) == null ? void 0 : a7.origin) || [0, 0], key: e5.key, keys: Object.keys(this.keys), shiftKey: t5, ctrlKey: n5, metaKey: C3.isDarwin() ? o5 : n5, altKey: i4 };
    });
    E2(this, "keyup", (e5) => {
      var s5, a7;
      let { shiftKey: t5, ctrlKey: n5, metaKey: o5, altKey: i4 } = e5;
      return delete this.keys[e5.key], { point: ((s5 = this.pointer) == null ? void 0 : s5.point) || [0, 0], origin: ((a7 = this.pointer) == null ? void 0 : a7.origin) || [0, 0], key: e5.key, keys: Object.keys(this.keys), shiftKey: t5, ctrlKey: n5, metaKey: C3.isDarwin() ? o5 : n5, altKey: i4 };
    });
  }
  pointerIsValid(e5) {
    if ("pointerId" in e5 && this.activePointer && this.activePointer !== e5.pointerId)
      return false;
    if ("touches" in e5) {
      let t5 = e5.changedTouches[0];
      if (this.activePointer && this.activePointer !== t5.identifier)
        return false;
    }
    return true;
  }
  touchStart(e5, t5) {
    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = e5.changedTouches[0];
    this.activePointer = a7.identifier;
    let d6 = { target: t5, pointerId: a7.identifier, origin: H2.getPoint(a7, this.bounds), delta: [0, 0], point: H2.getPoint(a7, this.bounds), pressure: H2.getPressure(a7), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[" "] };
    return this.pointer = d6, d6;
  }
  touchEnd(e5, t5) {
    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = e5.changedTouches[0], d6 = { target: t5, pointerId: a7.identifier, origin: H2.getPoint(a7, this.bounds), delta: [0, 0], point: H2.getPoint(a7, this.bounds), pressure: H2.getPressure(a7), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[" "] };
    return this.pointer = d6, this.activePointer = void 0, d6;
  }
  touchMove(e5, t5) {
    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = e5.changedTouches[0], d6 = this.pointer, l7 = H2.getPoint(a7, this.bounds), c5 = (d6 == null ? void 0 : d6.point) ? e.sub(l7, d6.point) : [0, 0], m6 = U2(g2({ origin: l7 }, d6), { target: t5, pointerId: a7.identifier, point: l7, delta: c5, pressure: H2.getPressure(a7), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[" "] });
    return this.pointer = m6, m6;
  }
  pointerDown(e5, t5) {
    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = H2.getPoint(e5, this.bounds);
    this.activePointer = e5.pointerId;
    let d6 = { target: t5, pointerId: e5.pointerId, origin: a7, point: a7, delta: [0, 0], pressure: H2.getPressure(e5), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[" "] };
    return this.pointer = d6, d6;
  }
  pointerEnter(e5, t5) {
    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = H2.getPoint(e5, this.bounds), d6 = { target: t5, pointerId: e5.pointerId, origin: a7, delta: [0, 0], point: a7, pressure: H2.getPressure(e5), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[" "] };
    return this.pointer = d6, d6;
  }
  pointerMove(e5, t5) {
    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = this.pointer, d6 = H2.getPoint(e5, this.bounds), l7 = (a7 == null ? void 0 : a7.point) ? e.sub(d6, a7.point) : [0, 0], c5 = U2(g2({ origin: d6 }, a7), { target: t5, pointerId: e5.pointerId, point: d6, delta: l7, pressure: H2.getPressure(e5), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[" "] });
    return this.pointer = c5, c5;
  }
  pointerUp(e5, t5) {
    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = this.pointer, d6 = H2.getPoint(e5, this.bounds), l7 = (a7 == null ? void 0 : a7.point) ? e.sub(d6, a7.point) : [0, 0];
    this.activePointer = void 0;
    let c5 = U2(g2({ origin: d6 }, a7), { target: t5, pointerId: e5.pointerId, point: d6, delta: l7, pressure: H2.getPressure(e5), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[" "] });
    return this.pointer = c5, this.pointerUpTime = performance.now(), c5;
  }
  isDoubleClick() {
    if (!this.pointer)
      return false;
    let { origin: e5, point: t5 } = this.pointer, n5 = performance.now() - this.pointerUpTime < Nn && e.dist(e5, t5) < 4;
    return n5 && (this.activePointer = void 0), n5;
  }
  clear() {
    this.pointer = void 0;
  }
  resetDoubleClick() {
    this.pointerUpTime = 0;
  }
  pinch(e5, t5) {
    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = this.keys, a7 = e.sub(t5, e5), d6 = { pointerId: 0, target: "pinch", origin: t5, delta: a7, point: e.sub(e.toFixed(e5), [this.bounds.minX, this.bounds.minY]), pressure: 0.5, shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[" "] };
    return this.pointer = d6, d6;
  }
  reset() {
    this.pointerUpTime = 0, this.pointer = void 0, this.keyboard = void 0, this.activePointer = void 0, this.keys = {};
  }
  static getPoint(e5, t5) {
    return [+e5.clientX.toFixed(2) - t5.minX, +e5.clientY.toFixed(2) - t5.minY];
  }
  static getPressure(e5) {
    return "pressure" in e5 && +e5.pressure.toFixed(2) || 0.5;
  }
  static commandKey() {
    return C3.isDarwin() ? "\u2318" : "Ctrl";
  }
};
var Cs = new H2();
var Wn = Object.freeze({});
function An(M3) {
  var I3 = M3, { id: r5 = "tl", shapeUtils: e5, page: t5, pageState: n5, assets: o5 = Wn, users: i4, userId: s5, theme: a7, meta: d6, snapLines: l7, eraseLine: c5, grid: m6, containerRef: p6, performanceMode: u5, components: y6, hideHandles: T5 = false, hideIndicators: v6 = false, hideCloneHandles: x5 = false, hideBindingHandles: f5 = false, hideResizeHandles: L5 = false, hideRotateHandles: Y3 = false, hideBounds: X3 = false, hideGrid: S4 = true, showDashedBrush: b6 = false, hideCursors: P5 } = I3, B5 = O2(I3, ["id", "shapeUtils", "page", "pageState", "assets", "users", "userId", "theme", "meta", "snapLines", "eraseLine", "grid", "containerRef", "performanceMode", "components", "hideHandles", "hideIndicators", "hideCloneHandles", "hideBindingHandles", "hideResizeHandles", "hideRotateHandles", "hideBounds", "hideGrid", "showDashedBrush", "hideCursors"]);
  dt(a7, "#" + r5);
  let A6 = N2.useRef(null), J3 = N2.useRef(n5);
  N2.useEffect(() => {
    J3.current = n5;
  }, [n5]);
  let [Ft, Gt] = N2.useState(() => ({ callbacks: B5, shapeUtils: e5, rSelectionBounds: A6, rPageState: J3, bounds: { minX: 0, minY: 0, maxX: 1 / 0, maxY: 1 / 0, width: 1 / 0, height: 1 / 0 }, inputs: new H2() })), jt = N2.useCallback((_t) => {
    Gt((Zt) => U2(g2({}, Zt), { bounds: _t }));
  }, []);
  return N2.createElement(Le.Provider, { value: Ft }, N2.createElement(zt, { id: r5, page: t5, pageState: n5, assets: o5, snapLines: l7, eraseLine: c5, grid: m6, users: i4, userId: s5, externalContainerRef: p6, hideBounds: X3, hideIndicators: v6, hideHandles: T5, hideCloneHandles: x5, hideBindingHandles: f5, hideRotateHandle: Y3, hideResizeHandles: L5, hideGrid: S4, showDashedBrush: b6, onBoundsChange: jt, performanceMode: u5, components: y6, meta: d6, hideCursors: P5 }));
}
var ks = N2.memo(An);
var Xs = me2.memo(me2.forwardRef(function(i4, o5) {
  var s5 = i4, { children: e5, className: t5 = "" } = s5, n5 = O2(s5, ["children", "className"]);
  return me2.createElement("div", g2({ ref: o5, className: `tl-positioned-div ${t5}`, draggable: false }, n5), me2.createElement("div", { className: "tl-inner-div" }, e5));
}));
var _e2 = class {
  constructor() {
    E2(this, "refMap", /* @__PURE__ */ new Map());
    E2(this, "boundsCache", /* @__PURE__ */ new WeakMap());
    E2(this, "showCloneHandles", false);
    E2(this, "hideBounds", false);
    E2(this, "isStateful", false);
    E2(this, "shouldRender", (e5, t5) => true);
    E2(this, "getRef", (e5) => (this.refMap.has(e5.id) || this.refMap.set(e5.id, Ae.createRef()), this.refMap.get(e5.id)));
    E2(this, "hitTestBounds", (e5, t5) => {
      let n5 = this.getBounds(e5), o5 = w2.getRotatedCorners(n5, e5.rotation);
      return o5.every((i4) => w2.pointInBounds(i4, t5)) || ee2(o5, t5).length > 0;
    });
    E2(this, "getRotatedBounds", (e5) => w2.getBoundsFromPoints(w2.getRotatedCorners(this.getBounds(e5), e5.rotation)));
  }
};
E2(_e2, "Component", (e5) => Ae.forwardRef(e5)), E2(_e2, "Indicator", (e5) => e5);

// node_modules/.pnpm/@babel+runtime@7.20.7/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/.pnpm/@radix-ui+react-context-menu@2.1.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-context-menu/dist/index.mjs
var import_react29 = require("react");

// node_modules/.pnpm/@radix-ui+primitive@1.0.1/node_modules/@radix-ui/primitive/dist/index.mjs
function $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented)
      return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
  };
}

// node_modules/.pnpm/@radix-ui+react-context@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-context/dist/index.mjs
var import_react7 = require("react");
function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
  const Context = /* @__PURE__ */ (0, import_react7.createContext)(defaultContext);
  function Provider(props) {
    const { children, ...context } = props;
    const value = (0, import_react7.useMemo)(
      () => context,
      Object.values(context)
    );
    return /* @__PURE__ */ (0, import_react7.createElement)(Context.Provider, {
      value
    }, children);
  }
  function useContext6(consumerName) {
    const context = (0, import_react7.useContext)(Context);
    if (context)
      return context;
    if (defaultContext !== void 0)
      return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  Provider.displayName = rootComponentName + "Provider";
  return [
    Provider,
    useContext6
  ];
}
function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext) {
    const BaseContext = /* @__PURE__ */ (0, import_react7.createContext)(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [
      ...defaultContexts,
      defaultContext
    ];
    function Provider(props) {
      const { scope, children, ...context } = props;
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = (0, import_react7.useMemo)(
        () => context,
        Object.values(context)
      );
      return /* @__PURE__ */ (0, import_react7.createElement)(Context.Provider, {
        value
      }, children);
    }
    function useContext6(consumerName, scope) {
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context = (0, import_react7.useContext)(Context);
      if (context)
        return context;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider.displayName = rootComponentName + "Provider";
    return [
      Provider,
      useContext6
    ];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return /* @__PURE__ */ (0, import_react7.createContext)(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;
      return (0, import_react7.useMemo)(
        () => ({
          [`__scope${scopeName}`]: {
            ...scope,
            [scopeName]: contexts
          }
        }),
        [
          scope,
          contexts
        ]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [
    $c512c27ab02ef895$export$fd42f52fd3ae11092,
    $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)
  ];
}
function $c512c27ab02ef895$var$composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope1 = () => {
    const scopeHooks = scopes.map(
      (createScope) => ({
        useScope: createScope(),
        scopeName: createScope.scopeName
      })
    );
    return function useComposedScopes(overrideScopes) {
      const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return {
          ...nextScopes,
          ...currentScope
        };
      }, {});
      return (0, import_react7.useMemo)(
        () => ({
          [`__scope${baseScope.scopeName}`]: nextScopes1
        }),
        [
          nextScopes1
        ]
      );
    };
  };
  createScope1.scopeName = baseScope.scopeName;
  return createScope1;
}

// node_modules/.pnpm/@radix-ui+react-primitive@1.0.3_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_react10 = require("react");
var import_react_dom = require("react-dom");

// node_modules/.pnpm/@radix-ui+react-slot@1.0.2_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-slot/dist/index.mjs
var import_react9 = require("react");

// node_modules/.pnpm/@radix-ui+react-compose-refs@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var import_react8 = require("react");
function $6ed0406888f73fc4$var$setRef(ref, value) {
  if (typeof ref === "function")
    ref(value);
  else if (ref !== null && ref !== void 0)
    ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef(ref, node)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {
  return (0, import_react8.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);
}

// node_modules/.pnpm/@radix-ui+react-slot@1.0.2_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-slot/dist/index.mjs
var $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ (0, import_react9.forwardRef)((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = import_react9.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (import_react9.Children.count(newElement) > 1)
          return import_react9.Children.only(null);
        return /* @__PURE__ */ (0, import_react9.isValidElement)(newElement) ? newElement.props.children : null;
      } else
        return child;
    });
    return /* @__PURE__ */ (0, import_react9.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
      ref: forwardedRef
    }), /* @__PURE__ */ (0, import_react9.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react9.cloneElement)(newElement, void 0, newChildren) : null);
  }
  return /* @__PURE__ */ (0, import_react9.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
var $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ (0, import_react9.forwardRef)((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (/* @__PURE__ */ (0, import_react9.isValidElement)(children))
    return /* @__PURE__ */ (0, import_react9.cloneElement)(children, {
      ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
      ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref) : children.ref
    });
  return import_react9.Children.count(children) > 1 ? import_react9.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
var $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
  return /* @__PURE__ */ (0, import_react9.createElement)(import_react9.Fragment, null, children);
};
function $5e63c961fc1ce211$var$isSlottable(child) {
  return /* @__PURE__ */ (0, import_react9.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
}
function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue)
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      else if (slotPropValue)
        overrideProps[propName] = slotPropValue;
    } else if (propName === "style")
      overrideProps[propName] = {
        ...slotPropValue,
        ...childPropValue
      };
    else if (propName === "className")
      overrideProps[propName] = [
        slotPropValue,
        childPropValue
      ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}

// node_modules/.pnpm/@radix-ui+react-primitive@1.0.3_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-primitive/dist/index.mjs
var $8927f6f2acc4f386$var$NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node) => {
  const Node = /* @__PURE__ */ (0, import_react10.forwardRef)((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node;
    (0, import_react10.useEffect)(() => {
      window[Symbol.for("radix-ui")] = true;
    }, []);
    return /* @__PURE__ */ (0, import_react10.createElement)(Comp, _extends({}, primitiveProps, {
      ref: forwardedRef
    }));
  });
  Node.displayName = `Primitive.${node}`;
  return {
    ...primitive,
    [node]: Node
  };
}, {});
function $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {
  if (target)
    (0, import_react_dom.flushSync)(
      () => target.dispatchEvent(event)
    );
}

// node_modules/.pnpm/@radix-ui+react-menu@2.0.5_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-menu/dist/index.mjs
var import_react28 = require("react");

// node_modules/.pnpm/@radix-ui+react-collection@1.0.3_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-collection/dist/index.mjs
var import_react11 = __toESM(require("react"), 1);
function $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope] = $c512c27ab02ef895$export$50c7b4e9d9f19c1(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {
    collectionRef: {
      current: null
    },
    itemMap: /* @__PURE__ */ new Map()
  });
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = import_react11.default.useRef(null);
    const itemMap = import_react11.default.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ import_react11.default.createElement(CollectionProviderImpl, {
      scope,
      itemMap,
      collectionRef: ref
    }, children);
  };
  /* @__PURE__ */ Object.assign(CollectionProvider, {
    displayName: PROVIDER_NAME
  });
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlot = /* @__PURE__ */ import_react11.default.forwardRef((props, forwardedRef) => {
    const { scope, children } = props;
    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.collectionRef);
    return /* @__PURE__ */ import_react11.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
      ref: composedRefs
    }, children);
  });
  /* @__PURE__ */ Object.assign(CollectionSlot, {
    displayName: COLLECTION_SLOT_NAME
  });
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = /* @__PURE__ */ import_react11.default.forwardRef((props, forwardedRef) => {
    const { scope, children, ...itemData } = props;
    const ref = import_react11.default.useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const context = useCollectionContext(ITEM_SLOT_NAME, scope);
    import_react11.default.useEffect(() => {
      context.itemMap.set(ref, {
        ref,
        ...itemData
      });
      return () => void context.itemMap.delete(ref);
    });
    return /* @__PURE__ */ import_react11.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
      [ITEM_DATA_ATTR]: "",
      ref: composedRefs
    }, children);
  });
  /* @__PURE__ */ Object.assign(CollectionItemSlot, {
    displayName: ITEM_SLOT_NAME
  });
  function useCollection(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = import_react11.default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode)
        return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a7, b6) => orderedNodes.indexOf(a7.ref.current) - orderedNodes.indexOf(b6.ref.current)
      );
      return orderedItems;
    }, [
      context.collectionRef,
      context.itemMap
    ]);
    return getItems;
  }
  return [
    {
      Provider: CollectionProvider,
      Slot: CollectionSlot,
      ItemSlot: CollectionItemSlot
    },
    useCollection,
    createCollectionScope
  ];
}

// node_modules/.pnpm/@radix-ui+react-direction@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-direction/dist/index.mjs
var import_react12 = require("react");
var $f631663db3294ace$var$DirectionContext = /* @__PURE__ */ (0, import_react12.createContext)(void 0);
function $f631663db3294ace$export$b39126d51d94e6f3(localDir) {
  const globalDir = (0, import_react12.useContext)($f631663db3294ace$var$DirectionContext);
  return localDir || globalDir || "ltr";
}

// node_modules/.pnpm/@radix-ui+react-dismissable-layer@1.0.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_react15 = require("react");

// node_modules/.pnpm/@radix-ui+react-use-callback-ref@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var import_react13 = require("react");
function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {
  const callbackRef = (0, import_react13.useRef)(callback);
  (0, import_react13.useEffect)(() => {
    callbackRef.current = callback;
  });
  return (0, import_react13.useMemo)(
    () => (...args) => {
      var _callbackRef$current;
      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
    },
    []
  );
}

// node_modules/.pnpm/@radix-ui+react-use-escape-keydown@1.0.3_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var import_react14 = require("react");
function $addc16e1bbe58fd0$export$3a72a57244d6e765(onEscapeKeyDownProp, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp);
  (0, import_react14.useEffect)(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape")
        onEscapeKeyDown(event);
    };
    ownerDocument.addEventListener("keydown", handleKeyDown);
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown);
  }, [
    onEscapeKeyDown,
    ownerDocument
  ]);
}

// node_modules/.pnpm/@radix-ui+react-dismissable-layer@1.0.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var $5cb92bef7577960e$var$CONTEXT_UPDATE = "dismissableLayer.update";
var $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var $5cb92bef7577960e$var$FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var $5cb92bef7577960e$var$originalBodyPointerEvents;
var $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ (0, import_react15.createContext)({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ (0, import_react15.forwardRef)((props, forwardedRef) => {
  var _node$ownerDocument;
  const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;
  const context = (0, import_react15.useContext)($5cb92bef7577960e$var$DismissableLayerContext);
  const [node1, setNode] = (0, import_react15.useState)(null);
  const ownerDocument = (_node$ownerDocument = node1 === null || node1 === void 0 ? void 0 : node1.ownerDocument) !== null && _node$ownerDocument !== void 0 ? _node$ownerDocument : globalThis === null || globalThis === void 0 ? void 0 : globalThis.document;
  const [, force] = (0, import_react15.useState)({});
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setNode(node)
  );
  const layers = Array.from(context.layers);
  const [highestLayerWithOutsidePointerEventsDisabled] = [
    ...context.layersWithOutsidePointerEventsDisabled
  ].slice(-1);
  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
  const index2 = node1 ? layers.indexOf(node1) : -1;
  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
  const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
  const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event) => {
    const target = event.target;
    const isPointerDownOnBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (!isPointerEventsEnabled || isPointerDownOnBranch)
      return;
    onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented)
      onDismiss === null || onDismiss === void 0 || onDismiss();
  }, ownerDocument);
  const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event) => {
    const target = event.target;
    const isFocusInBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (isFocusInBranch)
      return;
    onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented)
      onDismiss === null || onDismiss === void 0 || onDismiss();
  }, ownerDocument);
  $addc16e1bbe58fd0$export$3a72a57244d6e765((event) => {
    const isHighestLayer = index2 === context.layers.size - 1;
    if (!isHighestLayer)
      return;
    onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }, ownerDocument);
  (0, import_react15.useEffect)(() => {
    if (!node1)
      return;
    if (disableOutsidePointerEvents) {
      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
        $5cb92bef7577960e$var$originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
        ownerDocument.body.style.pointerEvents = "none";
      }
      context.layersWithOutsidePointerEventsDisabled.add(node1);
    }
    context.layers.add(node1);
    $5cb92bef7577960e$var$dispatchUpdate();
    return () => {
      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1)
        ownerDocument.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;
    };
  }, [
    node1,
    ownerDocument,
    disableOutsidePointerEvents,
    context
  ]);
  (0, import_react15.useEffect)(() => {
    return () => {
      if (!node1)
        return;
      context.layers.delete(node1);
      context.layersWithOutsidePointerEventsDisabled.delete(node1);
      $5cb92bef7577960e$var$dispatchUpdate();
    };
  }, [
    node1,
    context
  ]);
  (0, import_react15.useEffect)(() => {
    const handleUpdate = () => force({});
    document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
    return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
  }, []);
  return /* @__PURE__ */ (0, import_react15.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, layerProps, {
    ref: composedRefs,
    style: {
      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
      ...props.style
    },
    onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusCapture, focusOutside.onFocusCapture),
    onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlurCapture, focusOutside.onBlurCapture),
    onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
  }));
});
function $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside);
  const isPointerInsideReactTreeRef = (0, import_react15.useRef)(false);
  const handleClickRef = (0, import_react15.useRef)(() => {
  });
  (0, import_react15.useEffect)(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent = function() {
          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {
            discrete: true
          });
        };
        const eventDetail = {
          originalEvent: event
        };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;
          ownerDocument.addEventListener("click", handleClickRef.current, {
            once: true
          });
        } else
          handleAndDispatchPointerDownOutsideEvent();
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [
    ownerDocument,
    handlePointerDownOutside
  ]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function $5cb92bef7577960e$var$useFocusOutside(onFocusOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside);
  const isFocusInsideReactTreeRef = (0, import_react15.useRef)(false);
  (0, import_react15.useEffect)(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = {
          originalEvent: event
        };
        $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [
    ownerDocument,
    handleFocusOutside
  ]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function $5cb92bef7577960e$var$dispatchUpdate() {
  const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler)
    target.addEventListener(name, handler, {
      once: true
    });
  if (discrete)
    $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event);
  else
    target.dispatchEvent(event);
}

// node_modules/.pnpm/@radix-ui+react-focus-guards@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var import_react16 = require("react");
var $3db38b7d1fb3fe6a$var$count = 0;
function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {
  (0, import_react16.useEffect)(() => {
    var _edgeGuards$, _edgeGuards$2;
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard());
    document.body.insertAdjacentElement("beforeend", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard());
    $3db38b7d1fb3fe6a$var$count++;
    return () => {
      if ($3db38b7d1fb3fe6a$var$count === 1)
        document.querySelectorAll("[data-radix-focus-guard]").forEach(
          (node) => node.remove()
        );
      $3db38b7d1fb3fe6a$var$count--;
    };
  }, []);
}
function $3db38b7d1fb3fe6a$var$createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}

// node_modules/.pnpm/@radix-ui+react-focus-scope@1.0.3_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var import_react17 = require("react");
var $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var $d3863c46a17e8a28$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
var $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ (0, import_react17.forwardRef)((props, forwardedRef) => {
  const { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp, ...scopeProps } = props;
  const [container1, setContainer] = (0, import_react17.useState)(null);
  const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp);
  const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp);
  const lastFocusedElementRef = (0, import_react17.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setContainer(node)
  );
  const focusScope = (0, import_react17.useRef)({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  (0, import_react17.useEffect)(() => {
    if (trapped) {
      let handleFocusIn = function(event) {
        if (focusScope.paused || !container1)
          return;
        const target = event.target;
        if (container1.contains(target))
          lastFocusedElementRef.current = target;
        else
          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
            select: true
          });
      }, handleFocusOut = function(event) {
        if (focusScope.paused || !container1)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container1.contains(relatedTarget))
          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
            select: true
          });
      }, handleMutations = function(mutations) {
        const focusedElement = document.activeElement;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) {
            if (!(container1 !== null && container1 !== void 0 && container1.contains(focusedElement)))
              $d3863c46a17e8a28$var$focus(container1);
          }
        }
      };
      document.addEventListener("focusin", handleFocusIn);
      document.addEventListener("focusout", handleFocusOut);
      const mutationObserver = new MutationObserver(handleMutations);
      if (container1)
        mutationObserver.observe(container1, {
          childList: true,
          subtree: true
        });
      return () => {
        document.removeEventListener("focusin", handleFocusIn);
        document.removeEventListener("focusout", handleFocusOut);
        mutationObserver.disconnect();
      };
    }
  }, [
    trapped,
    container1,
    focusScope.paused
  ]);
  (0, import_react17.useEffect)(() => {
    if (container1) {
      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container1.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {
            select: true
          });
          if (document.activeElement === previouslyFocusedElement)
            $d3863c46a17e8a28$var$focus(container1);
        }
      }
      return () => {
        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container1.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented)
            $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {
              select: true
            });
          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [
    container1,
    onMountAutoFocus,
    onUnmountAutoFocus,
    focusScope
  ]);
  const handleKeyDown = (0, import_react17.useCallback)((event) => {
    if (!loop && !trapped)
      return;
    if (focusScope.paused)
      return;
    const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
    const focusedElement = document.activeElement;
    if (isTabKey && focusedElement) {
      const container = event.currentTarget;
      const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);
      const hasTabbableElementsInside = first && last;
      if (!hasTabbableElementsInside) {
        if (focusedElement === container)
          event.preventDefault();
      } else {
        if (!event.shiftKey && focusedElement === last) {
          event.preventDefault();
          if (loop)
            $d3863c46a17e8a28$var$focus(first, {
              select: true
            });
        } else if (event.shiftKey && focusedElement === first) {
          event.preventDefault();
          if (loop)
            $d3863c46a17e8a28$var$focus(last, {
              select: true
            });
        }
      }
    }
  }, [
    loop,
    trapped,
    focusScope.paused
  ]);
  return /* @__PURE__ */ (0, import_react17.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    tabIndex: -1
  }, scopeProps, {
    ref: composedRefs,
    onKeyDown: handleKeyDown
  }));
});
function $d3863c46a17e8a28$var$focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    $d3863c46a17e8a28$var$focus(candidate, {
      select
    });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function $d3863c46a17e8a28$var$getTabbableEdges(container) {
  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);
  const first = $d3863c46a17e8a28$var$findVisible(candidates, container);
  const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);
  return [
    first,
    last
  ];
}
function $d3863c46a17e8a28$var$getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function $d3863c46a17e8a28$var$findVisible(elements, container) {
  for (const element of elements) {
    if (!$d3863c46a17e8a28$var$isHidden(element, {
      upTo: container
    }))
      return element;
  }
}
function $d3863c46a17e8a28$var$isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function $d3863c46a17e8a28$var$isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function $d3863c46a17e8a28$var$focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({
      preventScroll: true
    });
    if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select)
      element.select();
  }
}
var $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();
function $d3863c46a17e8a28$var$createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope)
        activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _stack$;
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();
    }
  };
}
function $d3863c46a17e8a28$var$arrayRemove(array, item) {
  const updatedArray = [
    ...array
  ];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1)
    updatedArray.splice(index2, 1);
  return updatedArray;
}
function $d3863c46a17e8a28$var$removeLinks(items) {
  return items.filter(
    (item) => item.tagName !== "A"
  );
}

// node_modules/.pnpm/@radix-ui+react-id@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-id/dist/index.mjs
var $2AODx$react = __toESM(require("react"), 1);

// node_modules/.pnpm/@radix-ui+react-use-layout-effect@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var import_react18 = require("react");
var $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react18.useLayoutEffect : () => {
};

// node_modules/.pnpm/@radix-ui+react-id@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-id/dist/index.mjs
var $1746a345f3d73bb7$var$useReactId = $2AODx$react["useId".toString()] || (() => void 0);
var $1746a345f3d73bb7$var$count = 0;
function $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {
  const [id, setId] = $2AODx$react.useState($1746a345f3d73bb7$var$useReactId());
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (!deterministicId)
      setId(
        (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)
      );
  }, [
    deterministicId
  ]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// node_modules/.pnpm/@radix-ui+react-popper@1.1.2_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-popper/dist/index.mjs
var import_react22 = require("react");

// node_modules/.pnpm/@floating-ui+core@1.2.6/node_modules/@floating-ui/core/dist/floating-ui.core.browser.min.mjs
function t2(t5) {
  return t5.split("-")[1];
}
function e2(t5) {
  return "y" === t5 ? "height" : "width";
}
function n(t5) {
  return t5.split("-")[0];
}
function o(t5) {
  return ["top", "bottom"].includes(n(t5)) ? "x" : "y";
}
function i(i4, r5, a7) {
  let { reference: l7, floating: s5 } = i4;
  const c5 = l7.x + l7.width / 2 - s5.width / 2, f5 = l7.y + l7.height / 2 - s5.height / 2, m6 = o(r5), u5 = e2(m6), g6 = l7[u5] / 2 - s5[u5] / 2, d6 = "x" === m6;
  let p6;
  switch (n(r5)) {
    case "top":
      p6 = { x: c5, y: l7.y - s5.height };
      break;
    case "bottom":
      p6 = { x: c5, y: l7.y + l7.height };
      break;
    case "right":
      p6 = { x: l7.x + l7.width, y: f5 };
      break;
    case "left":
      p6 = { x: l7.x - s5.width, y: f5 };
      break;
    default:
      p6 = { x: l7.x, y: l7.y };
  }
  switch (t2(r5)) {
    case "start":
      p6[m6] -= g6 * (a7 && d6 ? -1 : 1);
      break;
    case "end":
      p6[m6] += g6 * (a7 && d6 ? -1 : 1);
  }
  return p6;
}
var r = async (t5, e5, n5) => {
  const { placement: o5 = "bottom", strategy: r5 = "absolute", middleware: a7 = [], platform: l7 } = n5, s5 = a7.filter(Boolean), c5 = await (null == l7.isRTL ? void 0 : l7.isRTL(e5));
  let f5 = await l7.getElementRects({ reference: t5, floating: e5, strategy: r5 }), { x: m6, y: u5 } = i(f5, o5, c5), g6 = o5, d6 = {}, p6 = 0;
  for (let n6 = 0; n6 < s5.length; n6++) {
    const { name: a8, fn: h6 } = s5[n6], { x: y6, y: x5, data: w7, reset: v6 } = await h6({ x: m6, y: u5, initialPlacement: o5, placement: g6, strategy: r5, middlewareData: d6, rects: f5, platform: l7, elements: { reference: t5, floating: e5 } });
    m6 = null != y6 ? y6 : m6, u5 = null != x5 ? x5 : u5, d6 = { ...d6, [a8]: { ...d6[a8], ...w7 } }, v6 && p6 <= 50 && (p6++, "object" == typeof v6 && (v6.placement && (g6 = v6.placement), v6.rects && (f5 = true === v6.rects ? await l7.getElementRects({ reference: t5, floating: e5, strategy: r5 }) : v6.rects), { x: m6, y: u5 } = i(f5, g6, c5)), n6 = -1);
  }
  return { x: m6, y: u5, placement: g6, strategy: r5, middlewareData: d6 };
};
function a3(t5) {
  return "number" != typeof t5 ? function(t6) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t6 };
  }(t5) : { top: t5, right: t5, bottom: t5, left: t5 };
}
function l3(t5) {
  return { ...t5, top: t5.y, left: t5.x, right: t5.x + t5.width, bottom: t5.y + t5.height };
}
async function s(t5, e5) {
  var n5;
  void 0 === e5 && (e5 = {});
  const { x: o5, y: i4, platform: r5, rects: s5, elements: c5, strategy: f5 } = t5, { boundary: m6 = "clippingAncestors", rootBoundary: u5 = "viewport", elementContext: g6 = "floating", altBoundary: d6 = false, padding: p6 = 0 } = e5, h6 = a3(p6), y6 = c5[d6 ? "floating" === g6 ? "reference" : "floating" : g6], x5 = l3(await r5.getClippingRect({ element: null == (n5 = await (null == r5.isElement ? void 0 : r5.isElement(y6))) || n5 ? y6 : y6.contextElement || await (null == r5.getDocumentElement ? void 0 : r5.getDocumentElement(c5.floating)), boundary: m6, rootBoundary: u5, strategy: f5 })), w7 = "floating" === g6 ? { ...s5.floating, x: o5, y: i4 } : s5.reference, v6 = await (null == r5.getOffsetParent ? void 0 : r5.getOffsetParent(c5.floating)), b6 = await (null == r5.isElement ? void 0 : r5.isElement(v6)) && await (null == r5.getScale ? void 0 : r5.getScale(v6)) || { x: 1, y: 1 }, A6 = l3(r5.convertOffsetParentRelativeRectToViewportRelativeRect ? await r5.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: w7, offsetParent: v6, strategy: f5 }) : w7);
  return { top: (x5.top - A6.top + h6.top) / b6.y, bottom: (A6.bottom - x5.bottom + h6.bottom) / b6.y, left: (x5.left - A6.left + h6.left) / b6.x, right: (A6.right - x5.right + h6.right) / b6.x };
}
var c = Math.min;
var f = Math.max;
function m2(t5, e5, n5) {
  return f(t5, c(e5, n5));
}
var u = (n5) => ({ name: "arrow", options: n5, async fn(i4) {
  const { element: r5, padding: l7 = 0 } = n5 || {}, { x: s5, y: c5, placement: f5, rects: u5, platform: g6, elements: d6 } = i4;
  if (null == r5)
    return {};
  const p6 = a3(l7), h6 = { x: s5, y: c5 }, y6 = o(f5), x5 = e2(y6), w7 = await g6.getDimensions(r5), v6 = "y" === y6, b6 = v6 ? "top" : "left", A6 = v6 ? "bottom" : "right", R7 = v6 ? "clientHeight" : "clientWidth", P5 = u5.reference[x5] + u5.reference[y6] - h6[y6] - u5.floating[x5], E5 = h6[y6] - u5.reference[y6], T5 = await (null == g6.getOffsetParent ? void 0 : g6.getOffsetParent(r5));
  let D6 = T5 ? T5[R7] : 0;
  D6 && await (null == g6.isElement ? void 0 : g6.isElement(T5)) || (D6 = d6.floating[R7] || u5.floating[x5]);
  const L5 = P5 / 2 - E5 / 2, k7 = p6[b6], O6 = D6 - w7[x5] - p6[A6], B5 = D6 / 2 - w7[x5] / 2 + L5, C6 = m2(k7, B5, O6), H5 = null != t2(f5) && B5 != C6 && u5.reference[x5] / 2 - (B5 < k7 ? p6[b6] : p6[A6]) - w7[x5] / 2 < 0;
  return { [y6]: h6[y6] - (H5 ? B5 < k7 ? k7 - B5 : O6 - B5 : 0), data: { [y6]: C6, centerOffset: B5 - C6 } };
} });
var g3 = ["top", "right", "bottom", "left"];
var d2 = g3.reduce((t5, e5) => t5.concat(e5, e5 + "-start", e5 + "-end"), []);
var p2 = { left: "right", right: "left", bottom: "top", top: "bottom" };
function h2(t5) {
  return t5.replace(/left|right|bottom|top/g, (t6) => p2[t6]);
}
function y2(n5, i4, r5) {
  void 0 === r5 && (r5 = false);
  const a7 = t2(n5), l7 = o(n5), s5 = e2(l7);
  let c5 = "x" === l7 ? a7 === (r5 ? "end" : "start") ? "right" : "left" : "start" === a7 ? "bottom" : "top";
  return i4.reference[s5] > i4.floating[s5] && (c5 = h2(c5)), { main: c5, cross: h2(c5) };
}
var x2 = { start: "end", end: "start" };
function w3(t5) {
  return t5.replace(/start|end/g, (t6) => x2[t6]);
}
var b2 = function(e5) {
  return void 0 === e5 && (e5 = {}), { name: "flip", options: e5, async fn(o5) {
    var i4;
    const { placement: r5, middlewareData: a7, rects: l7, initialPlacement: c5, platform: f5, elements: m6 } = o5, { mainAxis: u5 = true, crossAxis: g6 = true, fallbackPlacements: d6, fallbackStrategy: p6 = "bestFit", fallbackAxisSideDirection: x5 = "none", flipAlignment: v6 = true, ...b6 } = e5, A6 = n(r5), R7 = n(c5) === c5, P5 = await (null == f5.isRTL ? void 0 : f5.isRTL(m6.floating)), E5 = d6 || (R7 || !v6 ? [h2(c5)] : function(t5) {
      const e6 = h2(t5);
      return [w3(t5), e6, w3(e6)];
    }(c5));
    d6 || "none" === x5 || E5.push(...function(e6, o6, i5, r6) {
      const a8 = t2(e6);
      let l8 = function(t5, e7, n5) {
        const o7 = ["left", "right"], i6 = ["right", "left"], r7 = ["top", "bottom"], a9 = ["bottom", "top"];
        switch (t5) {
          case "top":
          case "bottom":
            return n5 ? e7 ? i6 : o7 : e7 ? o7 : i6;
          case "left":
          case "right":
            return e7 ? r7 : a9;
          default:
            return [];
        }
      }(n(e6), "start" === i5, r6);
      return a8 && (l8 = l8.map((t5) => t5 + "-" + a8), o6 && (l8 = l8.concat(l8.map(w3)))), l8;
    }(c5, v6, x5, P5));
    const T5 = [c5, ...E5], D6 = await s(o5, b6), L5 = [];
    let k7 = (null == (i4 = a7.flip) ? void 0 : i4.overflows) || [];
    if (u5 && L5.push(D6[A6]), g6) {
      const { main: t5, cross: e6 } = y2(r5, l7, P5);
      L5.push(D6[t5], D6[e6]);
    }
    if (k7 = [...k7, { placement: r5, overflows: L5 }], !L5.every((t5) => t5 <= 0)) {
      var O6, B5;
      const t5 = ((null == (O6 = a7.flip) ? void 0 : O6.index) || 0) + 1, e6 = T5[t5];
      if (e6)
        return { data: { index: t5, overflows: k7 }, reset: { placement: e6 } };
      let n5 = null == (B5 = k7.filter((t6) => t6.overflows[0] <= 0).sort((t6, e7) => t6.overflows[1] - e7.overflows[1])[0]) ? void 0 : B5.placement;
      if (!n5)
        switch (p6) {
          case "bestFit": {
            var C6;
            const t6 = null == (C6 = k7.map((t7) => [t7.placement, t7.overflows.filter((t8) => t8 > 0).reduce((t8, e7) => t8 + e7, 0)]).sort((t7, e7) => t7[1] - e7[1])[0]) ? void 0 : C6[0];
            t6 && (n5 = t6);
            break;
          }
          case "initialPlacement":
            n5 = c5;
        }
      if (r5 !== n5)
        return { reset: { placement: n5 } };
    }
    return {};
  } };
};
function A3(t5, e5) {
  return { top: t5.top - e5.height, right: t5.right - e5.width, bottom: t5.bottom - e5.height, left: t5.left - e5.width };
}
function R4(t5) {
  return g3.some((e5) => t5[e5] >= 0);
}
var P = function(t5) {
  return void 0 === t5 && (t5 = {}), { name: "hide", options: t5, async fn(e5) {
    const { strategy: n5 = "referenceHidden", ...o5 } = t5, { rects: i4 } = e5;
    switch (n5) {
      case "referenceHidden": {
        const t6 = A3(await s(e5, { ...o5, elementContext: "reference" }), i4.reference);
        return { data: { referenceHiddenOffsets: t6, referenceHidden: R4(t6) } };
      }
      case "escaped": {
        const t6 = A3(await s(e5, { ...o5, altBoundary: true }), i4.floating);
        return { data: { escapedOffsets: t6, escaped: R4(t6) } };
      }
      default:
        return {};
    }
  } };
};
var D3 = function(e5) {
  return void 0 === e5 && (e5 = 0), { name: "offset", options: e5, async fn(i4) {
    const { x: r5, y: a7 } = i4, l7 = await async function(e6, i5) {
      const { placement: r6, platform: a8, elements: l8 } = e6, s5 = await (null == a8.isRTL ? void 0 : a8.isRTL(l8.floating)), c5 = n(r6), f5 = t2(r6), m6 = "x" === o(r6), u5 = ["left", "top"].includes(c5) ? -1 : 1, g6 = s5 && m6 ? -1 : 1, d6 = "function" == typeof i5 ? i5(e6) : i5;
      let { mainAxis: p6, crossAxis: h6, alignmentAxis: y6 } = "number" == typeof d6 ? { mainAxis: d6, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d6 };
      return f5 && "number" == typeof y6 && (h6 = "end" === f5 ? -1 * y6 : y6), m6 ? { x: h6 * g6, y: p6 * u5 } : { x: p6 * u5, y: h6 * g6 };
    }(i4, e5);
    return { x: r5 + l7.x, y: a7 + l7.y, data: l7 };
  } };
};
function L2(t5) {
  return "x" === t5 ? "y" : "x";
}
var k3 = function(t5) {
  return void 0 === t5 && (t5 = {}), { name: "shift", options: t5, async fn(e5) {
    const { x: i4, y: r5, placement: a7 } = e5, { mainAxis: l7 = true, crossAxis: c5 = false, limiter: f5 = { fn: (t6) => {
      let { x: e6, y: n5 } = t6;
      return { x: e6, y: n5 };
    } }, ...u5 } = t5, g6 = { x: i4, y: r5 }, d6 = await s(e5, u5), p6 = o(n(a7)), h6 = L2(p6);
    let y6 = g6[p6], x5 = g6[h6];
    if (l7) {
      const t6 = "y" === p6 ? "bottom" : "right";
      y6 = m2(y6 + d6["y" === p6 ? "top" : "left"], y6, y6 - d6[t6]);
    }
    if (c5) {
      const t6 = "y" === h6 ? "bottom" : "right";
      x5 = m2(x5 + d6["y" === h6 ? "top" : "left"], x5, x5 - d6[t6]);
    }
    const w7 = f5.fn({ ...e5, [p6]: y6, [h6]: x5 });
    return { ...w7, data: { x: w7.x - i4, y: w7.y - r5 } };
  } };
};
var O3 = function(t5) {
  return void 0 === t5 && (t5 = {}), { options: t5, fn(e5) {
    const { x: i4, y: r5, placement: a7, rects: l7, middlewareData: s5 } = e5, { offset: c5 = 0, mainAxis: f5 = true, crossAxis: m6 = true } = t5, u5 = { x: i4, y: r5 }, g6 = o(a7), d6 = L2(g6);
    let p6 = u5[g6], h6 = u5[d6];
    const y6 = "function" == typeof c5 ? c5(e5) : c5, x5 = "number" == typeof y6 ? { mainAxis: y6, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...y6 };
    if (f5) {
      const t6 = "y" === g6 ? "height" : "width", e6 = l7.reference[g6] - l7.floating[t6] + x5.mainAxis, n5 = l7.reference[g6] + l7.reference[t6] - x5.mainAxis;
      p6 < e6 ? p6 = e6 : p6 > n5 && (p6 = n5);
    }
    if (m6) {
      var w7, v6;
      const t6 = "y" === g6 ? "width" : "height", e6 = ["top", "left"].includes(n(a7)), o5 = l7.reference[d6] - l7.floating[t6] + (e6 && (null == (w7 = s5.offset) ? void 0 : w7[d6]) || 0) + (e6 ? 0 : x5.crossAxis), i5 = l7.reference[d6] + l7.reference[t6] + (e6 ? 0 : (null == (v6 = s5.offset) ? void 0 : v6[d6]) || 0) - (e6 ? x5.crossAxis : 0);
      h6 < o5 ? h6 = o5 : h6 > i5 && (h6 = i5);
    }
    return { [g6]: p6, [d6]: h6 };
  } };
};
var B3 = function(e5) {
  return void 0 === e5 && (e5 = {}), { name: "size", options: e5, async fn(i4) {
    const { placement: r5, rects: a7, platform: l7, elements: m6 } = i4, { apply: u5 = () => {
    }, ...g6 } = e5, d6 = await s(i4, g6), p6 = n(r5), h6 = t2(r5), y6 = "x" === o(r5), { width: x5, height: w7 } = a7.floating;
    let v6, b6;
    "top" === p6 || "bottom" === p6 ? (v6 = p6, b6 = h6 === (await (null == l7.isRTL ? void 0 : l7.isRTL(m6.floating)) ? "start" : "end") ? "left" : "right") : (b6 = p6, v6 = "end" === h6 ? "top" : "bottom");
    const A6 = w7 - d6[v6], R7 = x5 - d6[b6], P5 = !i4.middlewareData.shift;
    let E5 = A6, T5 = R7;
    if (y6) {
      const t5 = x5 - d6.left - d6.right;
      T5 = h6 || P5 ? c(R7, t5) : t5;
    } else {
      const t5 = w7 - d6.top - d6.bottom;
      E5 = h6 || P5 ? c(A6, t5) : t5;
    }
    if (P5 && !h6) {
      const t5 = f(d6.left, 0), e6 = f(d6.right, 0), n5 = f(d6.top, 0), o5 = f(d6.bottom, 0);
      y6 ? T5 = x5 - 2 * (0 !== t5 || 0 !== e6 ? t5 + e6 : f(d6.left, d6.right)) : E5 = w7 - 2 * (0 !== n5 || 0 !== o5 ? n5 + o5 : f(d6.top, d6.bottom));
    }
    await u5({ ...i4, availableWidth: T5, availableHeight: E5 });
    const D6 = await l7.getDimensions(m6.floating);
    return x5 !== D6.width || w7 !== D6.height ? { reset: { rects: true } } : {};
  } };
};

// node_modules/.pnpm/@floating-ui+dom@1.2.8/node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs
function n2(t5) {
  var e5;
  return (null == (e5 = t5.ownerDocument) ? void 0 : e5.defaultView) || window;
}
function o2(t5) {
  return n2(t5).getComputedStyle(t5);
}
function i2(t5) {
  return t5 instanceof n2(t5).Node;
}
function r2(t5) {
  return i2(t5) ? (t5.nodeName || "").toLowerCase() : "";
}
var l4;
function c2() {
  if (l4)
    return l4;
  const t5 = navigator.userAgentData;
  return t5 && Array.isArray(t5.brands) ? (l4 = t5.brands.map((t6) => t6.brand + "/" + t6.version).join(" "), l4) : navigator.userAgent;
}
function s2(t5) {
  return t5 instanceof n2(t5).HTMLElement;
}
function f2(t5) {
  return t5 instanceof n2(t5).Element;
}
function u2(t5) {
  if ("undefined" == typeof ShadowRoot)
    return false;
  return t5 instanceof n2(t5).ShadowRoot || t5 instanceof ShadowRoot;
}
function a4(t5) {
  const { overflow: e5, overflowX: n5, overflowY: i4, display: r5 } = o2(t5);
  return /auto|scroll|overlay|hidden|clip/.test(e5 + i4 + n5) && !["inline", "contents"].includes(r5);
}
function d3(t5) {
  return ["table", "td", "th"].includes(r2(t5));
}
function h3(t5) {
  const e5 = /firefox/i.test(c2()), n5 = o2(t5), i4 = n5.backdropFilter || n5.WebkitBackdropFilter;
  return "none" !== n5.transform || "none" !== n5.perspective || !!i4 && "none" !== i4 || e5 && "filter" === n5.willChange || e5 && !!n5.filter && "none" !== n5.filter || ["transform", "perspective"].some((t6) => n5.willChange.includes(t6)) || ["paint", "layout", "strict", "content"].some((t6) => {
    const e6 = n5.contain;
    return null != e6 && e6.includes(t6);
  });
}
function p3() {
  return /^((?!chrome|android).)*safari/i.test(c2());
}
function g4(t5) {
  return ["html", "body", "#document"].includes(r2(t5));
}
var m3 = Math.min;
var y3 = Math.max;
var x3 = Math.round;
function w4(t5) {
  const e5 = o2(t5);
  let n5 = parseFloat(e5.width) || 0, i4 = parseFloat(e5.height) || 0;
  const r5 = s2(t5), l7 = r5 ? t5.offsetWidth : n5, c5 = r5 ? t5.offsetHeight : i4, f5 = x3(n5) !== l7 || x3(i4) !== c5;
  return f5 && (n5 = l7, i4 = c5), { width: n5, height: i4, fallback: f5 };
}
function v3(t5) {
  return f2(t5) ? t5 : t5.contextElement;
}
var b3 = { x: 1, y: 1 };
function L3(t5) {
  const e5 = v3(t5);
  if (!s2(e5))
    return b3;
  const n5 = e5.getBoundingClientRect(), { width: o5, height: i4, fallback: r5 } = w4(e5);
  let l7 = (r5 ? x3(n5.width) : n5.width) / o5, c5 = (r5 ? x3(n5.height) : n5.height) / i4;
  return l7 && Number.isFinite(l7) || (l7 = 1), c5 && Number.isFinite(c5) || (c5 = 1), { x: l7, y: c5 };
}
function E3(e5, o5, i4, r5) {
  var l7, c5;
  void 0 === o5 && (o5 = false), void 0 === i4 && (i4 = false);
  const s5 = e5.getBoundingClientRect(), u5 = v3(e5);
  let a7 = b3;
  o5 && (r5 ? f2(r5) && (a7 = L3(r5)) : a7 = L3(e5));
  const d6 = u5 ? n2(u5) : window, h6 = p3() && i4;
  let g6 = (s5.left + (h6 && (null == (l7 = d6.visualViewport) ? void 0 : l7.offsetLeft) || 0)) / a7.x, m6 = (s5.top + (h6 && (null == (c5 = d6.visualViewport) ? void 0 : c5.offsetTop) || 0)) / a7.y, y6 = s5.width / a7.x, x5 = s5.height / a7.y;
  if (u5) {
    const t5 = n2(u5), e6 = r5 && f2(r5) ? n2(r5) : r5;
    let o6 = t5.frameElement;
    for (; o6 && r5 && e6 !== t5; ) {
      const t6 = L3(o6), e7 = o6.getBoundingClientRect(), i5 = getComputedStyle(o6);
      e7.x += (o6.clientLeft + parseFloat(i5.paddingLeft)) * t6.x, e7.y += (o6.clientTop + parseFloat(i5.paddingTop)) * t6.y, g6 *= t6.x, m6 *= t6.y, y6 *= t6.x, x5 *= t6.y, g6 += e7.x, m6 += e7.y, o6 = n2(o6).frameElement;
    }
  }
  return l3({ width: y6, height: x5, x: g6, y: m6 });
}
function T3(t5) {
  return ((i2(t5) ? t5.ownerDocument : t5.document) || window.document).documentElement;
}
function R5(t5) {
  return f2(t5) ? { scrollLeft: t5.scrollLeft, scrollTop: t5.scrollTop } : { scrollLeft: t5.pageXOffset, scrollTop: t5.pageYOffset };
}
function C4(t5) {
  return E3(T3(t5)).left + R5(t5).scrollLeft;
}
function F3(t5) {
  if ("html" === r2(t5))
    return t5;
  const e5 = t5.assignedSlot || t5.parentNode || u2(t5) && t5.host || T3(t5);
  return u2(e5) ? e5.host : e5;
}
function S2(t5) {
  const e5 = F3(t5);
  return g4(e5) ? e5.ownerDocument.body : s2(e5) && a4(e5) ? e5 : S2(e5);
}
function W3(t5, e5) {
  var o5;
  void 0 === e5 && (e5 = []);
  const i4 = S2(t5), r5 = i4 === (null == (o5 = t5.ownerDocument) ? void 0 : o5.body), l7 = n2(i4);
  return r5 ? e5.concat(l7, l7.visualViewport || [], a4(i4) ? i4 : []) : e5.concat(i4, W3(i4));
}
function D4(e5, i4, r5) {
  let l7;
  if ("viewport" === i4)
    l7 = function(t5, e6) {
      const o5 = n2(t5), i5 = T3(t5), r6 = o5.visualViewport;
      let l8 = i5.clientWidth, c6 = i5.clientHeight, s5 = 0, f5 = 0;
      if (r6) {
        l8 = r6.width, c6 = r6.height;
        const t6 = p3();
        (!t6 || t6 && "fixed" === e6) && (s5 = r6.offsetLeft, f5 = r6.offsetTop);
      }
      return { width: l8, height: c6, x: s5, y: f5 };
    }(e5, r5);
  else if ("document" === i4)
    l7 = function(t5) {
      const e6 = T3(t5), n5 = R5(t5), i5 = t5.ownerDocument.body, r6 = y3(e6.scrollWidth, e6.clientWidth, i5.scrollWidth, i5.clientWidth), l8 = y3(e6.scrollHeight, e6.clientHeight, i5.scrollHeight, i5.clientHeight);
      let c6 = -n5.scrollLeft + C4(t5);
      const s5 = -n5.scrollTop;
      return "rtl" === o2(i5).direction && (c6 += y3(e6.clientWidth, i5.clientWidth) - r6), { width: r6, height: l8, x: c6, y: s5 };
    }(T3(e5));
  else if (f2(i4))
    l7 = function(t5, e6) {
      const n5 = E3(t5, true, "fixed" === e6), o5 = n5.top + t5.clientTop, i5 = n5.left + t5.clientLeft, r6 = s2(t5) ? L3(t5) : { x: 1, y: 1 };
      return { width: t5.clientWidth * r6.x, height: t5.clientHeight * r6.y, x: i5 * r6.x, y: o5 * r6.y };
    }(i4, r5);
  else {
    const t5 = { ...i4 };
    if (p3()) {
      var c5, u5;
      const o5 = n2(e5);
      t5.x -= (null == (c5 = o5.visualViewport) ? void 0 : c5.offsetLeft) || 0, t5.y -= (null == (u5 = o5.visualViewport) ? void 0 : u5.offsetTop) || 0;
    }
    l7 = t5;
  }
  return l3(l7);
}
function V5(t5, e5) {
  const n5 = F3(t5);
  return !(n5 === e5 || !f2(n5) || g4(n5)) && ("fixed" === o2(n5).position || V5(n5, e5));
}
function A4(t5, e5) {
  return s2(t5) && "fixed" !== o2(t5).position ? e5 ? e5(t5) : t5.offsetParent : null;
}
function H3(t5, e5) {
  const i4 = n2(t5);
  if (!s2(t5))
    return i4;
  let l7 = A4(t5, e5);
  for (; l7 && d3(l7) && "static" === o2(l7).position; )
    l7 = A4(l7, e5);
  return l7 && ("html" === r2(l7) || "body" === r2(l7) && "static" === o2(l7).position && !h3(l7)) ? i4 : l7 || function(t6) {
    let e6 = F3(t6);
    for (; s2(e6) && !g4(e6); ) {
      if (h3(e6))
        return e6;
      e6 = F3(e6);
    }
    return null;
  }(t5) || i4;
}
function O4(t5, e5, n5) {
  const o5 = s2(e5), i4 = T3(e5), l7 = E3(t5, true, "fixed" === n5, e5);
  let c5 = { scrollLeft: 0, scrollTop: 0 };
  const f5 = { x: 0, y: 0 };
  if (o5 || !o5 && "fixed" !== n5)
    if (("body" !== r2(e5) || a4(i4)) && (c5 = R5(e5)), s2(e5)) {
      const t6 = E3(e5, true);
      f5.x = t6.x + e5.clientLeft, f5.y = t6.y + e5.clientTop;
    } else
      i4 && (f5.x = C4(i4));
  return { x: l7.left + c5.scrollLeft - f5.x, y: l7.top + c5.scrollTop - f5.y, width: l7.width, height: l7.height };
}
var P2 = { getClippingRect: function(t5) {
  let { element: e5, boundary: n5, rootBoundary: i4, strategy: l7 } = t5;
  const c5 = "clippingAncestors" === n5 ? function(t6, e6) {
    const n6 = e6.get(t6);
    if (n6)
      return n6;
    let i5 = W3(t6).filter((t7) => f2(t7) && "body" !== r2(t7)), l8 = null;
    const c6 = "fixed" === o2(t6).position;
    let s6 = c6 ? F3(t6) : t6;
    for (; f2(s6) && !g4(s6); ) {
      const e7 = o2(s6), n7 = h3(s6);
      n7 || "fixed" !== e7.position || (l8 = null), (c6 ? !n7 && !l8 : !n7 && "static" === e7.position && l8 && ["absolute", "fixed"].includes(l8.position) || a4(s6) && !n7 && V5(t6, s6)) ? i5 = i5.filter((t7) => t7 !== s6) : l8 = e7, s6 = F3(s6);
    }
    return e6.set(t6, i5), i5;
  }(e5, this._c) : [].concat(n5), s5 = [...c5, i4], u5 = s5[0], d6 = s5.reduce((t6, n6) => {
    const o5 = D4(e5, n6, l7);
    return t6.top = y3(o5.top, t6.top), t6.right = m3(o5.right, t6.right), t6.bottom = m3(o5.bottom, t6.bottom), t6.left = y3(o5.left, t6.left), t6;
  }, D4(e5, u5, l7));
  return { width: d6.right - d6.left, height: d6.bottom - d6.top, x: d6.left, y: d6.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(t5) {
  let { rect: e5, offsetParent: n5, strategy: o5 } = t5;
  const i4 = s2(n5), l7 = T3(n5);
  if (n5 === l7)
    return e5;
  let c5 = { scrollLeft: 0, scrollTop: 0 }, f5 = { x: 1, y: 1 };
  const u5 = { x: 0, y: 0 };
  if ((i4 || !i4 && "fixed" !== o5) && (("body" !== r2(n5) || a4(l7)) && (c5 = R5(n5)), s2(n5))) {
    const t6 = E3(n5);
    f5 = L3(n5), u5.x = t6.x + n5.clientLeft, u5.y = t6.y + n5.clientTop;
  }
  return { width: e5.width * f5.x, height: e5.height * f5.y, x: e5.x * f5.x - c5.scrollLeft * f5.x + u5.x, y: e5.y * f5.y - c5.scrollTop * f5.y + u5.y };
}, isElement: f2, getDimensions: function(t5) {
  return w4(t5);
}, getOffsetParent: H3, getDocumentElement: T3, getScale: L3, async getElementRects(t5) {
  let { reference: e5, floating: n5, strategy: o5 } = t5;
  const i4 = this.getOffsetParent || H3, r5 = this.getDimensions;
  return { reference: O4(e5, await i4(n5), o5), floating: { x: 0, y: 0, ...await r5(n5) } };
}, getClientRects: (t5) => Array.from(t5.getClientRects()), isRTL: (t5) => "rtl" === o2(t5).direction };
function z3(t5, e5, n5, o5) {
  void 0 === o5 && (o5 = {});
  const { ancestorScroll: i4 = true, ancestorResize: r5 = true, elementResize: l7 = true, animationFrame: c5 = false } = o5, s5 = i4 || r5 ? [...f2(t5) ? W3(t5) : t5.contextElement ? W3(t5.contextElement) : [], ...W3(e5)] : [];
  s5.forEach((t6) => {
    const e6 = !f2(t6) && t6.toString().includes("V");
    !i4 || c5 && !e6 || t6.addEventListener("scroll", n5, { passive: true }), r5 && t6.addEventListener("resize", n5);
  });
  let u5, a7 = null;
  l7 && (a7 = new ResizeObserver(() => {
    n5();
  }), f2(t5) && !c5 && a7.observe(t5), f2(t5) || !t5.contextElement || c5 || a7.observe(t5.contextElement), a7.observe(e5));
  let d6 = c5 ? E3(t5) : null;
  return c5 && function e6() {
    const o6 = E3(t5);
    !d6 || o6.x === d6.x && o6.y === d6.y && o6.width === d6.width && o6.height === d6.height || n5();
    d6 = o6, u5 = requestAnimationFrame(e6);
  }(), n5(), () => {
    var t6;
    s5.forEach((t7) => {
      i4 && t7.removeEventListener("scroll", n5), r5 && t7.removeEventListener("resize", n5);
    }), null == (t6 = a7) || t6.disconnect(), a7 = null, c5 && cancelAnimationFrame(u5);
  };
}
var k4 = (t5, n5, o5) => {
  const i4 = /* @__PURE__ */ new Map(), r5 = { platform: P2, ...o5 }, l7 = { ...r5.platform, _c: i4 };
  return r(t5, n5, { ...r5, platform: l7 });
};

// node_modules/.pnpm/@floating-ui+react-dom@2.0.0_react-dom@18.2.0_react@18.2.0/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
var React2 = __toESM(require("react"));
var import_react19 = require("react");
var ReactDOM = __toESM(require("react-dom"));
var arrow = (options) => {
  const {
    element,
    padding
  } = options;
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(args) {
      if (element && isRef(element)) {
        if (element.current != null) {
          return u({
            element: element.current,
            padding
          }).fn(args);
        }
        return {};
      } else if (element) {
        return u({
          element,
          padding
        }).fn(args);
      }
      return {};
    }
  };
};
var index = typeof document !== "undefined" ? import_react19.useLayoutEffect : import_react19.useEffect;
function deepEqual(a7, b6) {
  if (a7 === b6) {
    return true;
  }
  if (typeof a7 !== typeof b6) {
    return false;
  }
  if (typeof a7 === "function" && a7.toString() === b6.toString()) {
    return true;
  }
  let length, i4, keys;
  if (a7 && b6 && typeof a7 == "object") {
    if (Array.isArray(a7)) {
      length = a7.length;
      if (length != b6.length)
        return false;
      for (i4 = length; i4-- !== 0; ) {
        if (!deepEqual(a7[i4], b6[i4])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a7);
    length = keys.length;
    if (length !== Object.keys(b6).length) {
      return false;
    }
    for (i4 = length; i4-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b6, keys[i4])) {
        return false;
      }
    }
    for (i4 = length; i4-- !== 0; ) {
      const key = keys[i4];
      if (key === "_owner" && a7.$$typeof) {
        continue;
      }
      if (!deepEqual(a7[key], b6[key])) {
        return false;
      }
    }
    return true;
  }
  return a7 !== a7 && b6 !== b6;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React2.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React2.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React2.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React2.useState(null);
  const [_floating, _setFloating] = React2.useState(null);
  const setReference = React2.useCallback((node) => {
    if (node != referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, [_setReference]);
  const setFloating = React2.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, [_setFloating]);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React2.useRef(null);
  const floatingRef = React2.useRef(null);
  const dataRef = React2.useRef(data);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform);
  const update = React2.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    k4(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React2.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      } else {
        update();
      }
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef]);
  const refs = React2.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React2.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React2.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x5 = roundByDPR(elements.floating, data.x);
    const y6 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x5 + "px, " + y6 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x5,
      top: y6
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React2.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}

// node_modules/.pnpm/@radix-ui+react-arrow@1.0.3_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-arrow/dist/index.mjs
var import_react20 = require("react");
var $7e8f5cd07187803e$export$21b07c8f274aebd5 = /* @__PURE__ */ (0, import_react20.forwardRef)((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ (0, import_react20.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.svg, _extends({}, arrowProps, {
    ref: forwardedRef,
    width,
    height,
    viewBox: "0 0 30 10",
    preserveAspectRatio: "none"
  }), props.asChild ? children : /* @__PURE__ */ (0, import_react20.createElement)("polygon", {
    points: "0,0 30,0 15,10"
  }));
});
var $7e8f5cd07187803e$export$be92b6f5f03c0fe9 = $7e8f5cd07187803e$export$21b07c8f274aebd5;

// node_modules/.pnpm/@radix-ui+react-use-size@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-use-size/dist/index.mjs
var import_react21 = require("react");
function $db6c3485150b8e66$export$1ab7ae714698c4b8(element) {
  const [size, setSize] = (0, import_react21.useState)(void 0);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (element) {
      setSize({
        width: element.offsetWidth,
        height: element.offsetHeight
      });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries))
          return;
        if (!entries.length)
          return;
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({
          width,
          height
        });
      });
      resizeObserver.observe(element, {
        box: "border-box"
      });
      return () => resizeObserver.unobserve(element);
    } else
      setSize(void 0);
  }, [
    element
  ]);
  return size;
}

// node_modules/.pnpm/@radix-ui+react-popper@1.1.2_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-popper/dist/index.mjs
var $cf1ac5d9fe0e8206$var$POPPER_NAME = "Popper";
var [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME);
var [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME);
var $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9 = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = (0, import_react22.useState)(null);
  return /* @__PURE__ */ (0, import_react22.createElement)($cf1ac5d9fe0e8206$var$PopperProvider, {
    scope: __scopePopper,
    anchor,
    onAnchorChange: setAnchor
  }, children);
};
var $cf1ac5d9fe0e8206$var$ANCHOR_NAME = "PopperAnchor";
var $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {
  const { __scopePopper, virtualRef, ...anchorProps } = props;
  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$ANCHOR_NAME, __scopePopper);
  const ref = (0, import_react22.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  (0, import_react22.useEffect)(() => {
    context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);
  });
  return virtualRef ? null : /* @__PURE__ */ (0, import_react22.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, anchorProps, {
    ref: composedRefs
  }));
});
var $cf1ac5d9fe0e8206$var$CONTENT_NAME = "PopperContent";
var [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME);
var $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {
  var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$trans, _middlewareData$trans2, _middlewareData$hide;
  const { __scopePopper, side = "bottom", sideOffset = 0, align = "center", alignOffset = 0, arrowPadding = 0, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = "partial", hideWhenDetached = false, avoidCollisions = true, onPlaced, ...contentProps } = props;
  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
  const [content, setContent] = (0, import_react22.useState)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setContent(node)
  );
  const [arrow2, setArrow] = (0, import_react22.useState)(null);
  const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow2);
  const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;
  const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;
  const desiredPlacement = side + (align !== "center" ? "-" + align : "");
  const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...collisionPaddingProp
  };
  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [
    collisionBoundary
  ];
  const hasExplicitBoundaries = boundary.length > 0;
  const detectOverflowOptions = {
    padding: collisionPadding,
    boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),
    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
    altBoundary: hasExplicitBoundaries
  };
  const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
    strategy: "fixed",
    placement: desiredPlacement,
    whileElementsMounted: z3,
    elements: {
      reference: context.anchor
    },
    middleware: [
      D3({
        mainAxis: sideOffset + arrowHeight,
        alignmentAxis: alignOffset
      }),
      avoidCollisions && k3({
        mainAxis: true,
        crossAxis: false,
        limiter: sticky === "partial" ? O3() : void 0,
        ...detectOverflowOptions
      }),
      avoidCollisions && b2({
        ...detectOverflowOptions
      }),
      B3({
        ...detectOverflowOptions,
        apply: ({ elements, rects, availableWidth, availableHeight }) => {
          const { width: anchorWidth, height: anchorHeight } = rects.reference;
          const contentStyle = elements.floating.style;
          contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
          contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
          contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
          contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
        }
      }),
      arrow2 && arrow({
        element: arrow2,
        padding: arrowPadding
      }),
      $cf1ac5d9fe0e8206$var$transformOrigin({
        arrowWidth,
        arrowHeight
      }),
      hideWhenDetached && P({
        strategy: "referenceHidden"
      })
    ]
  });
  const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
  const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPlaced);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (isPositioned)
      handlePlaced === null || handlePlaced === void 0 || handlePlaced();
  }, [
    isPositioned,
    handlePlaced
  ]);
  const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;
  const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;
  const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;
  const [contentZIndex, setContentZIndex] = (0, import_react22.useState)();
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (content)
      setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [
    content
  ]);
  return /* @__PURE__ */ (0, import_react22.createElement)("div", {
    ref: refs.setFloating,
    "data-radix-popper-content-wrapper": "",
    style: {
      ...floatingStyles,
      transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
      // keep off the page when measuring
      minWidth: "max-content",
      zIndex: contentZIndex,
      ["--radix-popper-transform-origin"]: [
        (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,
        (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y
      ].join(" ")
    },
    dir: props.dir
  }, /* @__PURE__ */ (0, import_react22.createElement)($cf1ac5d9fe0e8206$var$PopperContentProvider, {
    scope: __scopePopper,
    placedSide,
    onArrowChange: setArrow,
    arrowX,
    arrowY,
    shouldHideArrow: cannotCenterArrow
  }, /* @__PURE__ */ (0, import_react22.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    "data-side": placedSide,
    "data-align": placedAlign
  }, contentProps, {
    ref: composedRefs,
    style: {
      ...contentProps.style,
      // if the PopperContent hasn't been placed yet (not all measurements done)
      // we prevent animations so that users's animation don't kick in too early referring wrong sides
      animation: !isPositioned ? "none" : void 0,
      // hide the content if using the hide middleware and should be hidden
      opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0
    }
  }))));
});
var $cf1ac5d9fe0e8206$var$ARROW_NAME = "PopperArrow";
var $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0 = /* @__PURE__ */ (0, import_react22.forwardRef)(function $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd02(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = $cf1ac5d9fe0e8206$var$useContentContext($cf1ac5d9fe0e8206$var$ARROW_NAME, __scopePopper);
  const baseSide = $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ (0, import_react22.createElement)("span", {
      ref: contentContext.onArrowChange,
      style: {
        position: "absolute",
        left: contentContext.arrowX,
        top: contentContext.arrowY,
        [baseSide]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[contentContext.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: `rotate(180deg)`,
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[contentContext.placedSide],
        visibility: contentContext.shouldHideArrow ? "hidden" : void 0
      }
    }, /* @__PURE__ */ (0, import_react22.createElement)($7e8f5cd07187803e$export$be92b6f5f03c0fe9, _extends({}, arrowProps, {
      ref: forwardedRef,
      style: {
        ...arrowProps.style,
        // ensures the element can be measured correctly (mostly for if SVG)
        display: "block"
      }
    })))
  );
});
function $cf1ac5d9fe0e8206$var$isNotNull(value) {
  return value !== null;
}
var $cf1ac5d9fe0e8206$var$transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
    const noArrowAlign = {
      start: "0%",
      center: "50%",
      end: "100%"
    }[placedAlign];
    const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;
    const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;
    let x5 = "";
    let y6 = "";
    if (placedSide === "bottom") {
      x5 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y6 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x5 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y6 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x5 = `${-arrowHeight}px`;
      y6 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x5 = `${rects.floating.width + arrowHeight}px`;
      y6 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return {
      data: {
        x: x5,
        y: y6
      }
    };
  }
});
function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [
    side,
    align
  ];
}
var $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9;
var $cf1ac5d9fe0e8206$export$b688253958b8dfe7 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d;
var $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc;
var $cf1ac5d9fe0e8206$export$21b07c8f274aebd5 = $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0;

// node_modules/.pnpm/@radix-ui+react-portal@1.0.3_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-portal/dist/index.mjs
var import_react23 = require("react");
var import_react_dom3 = __toESM(require("react-dom"), 1);
var $f1701beae083dbae$export$602eac185826482c = /* @__PURE__ */ (0, import_react23.forwardRef)((props, forwardedRef) => {
  var _globalThis$document;
  const { container = globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.body, ...portalProps } = props;
  return container ? /* @__PURE__ */ import_react_dom3.default.createPortal(/* @__PURE__ */ (0, import_react23.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, portalProps, {
    ref: forwardedRef
  })), container) : null;
});

// node_modules/.pnpm/@radix-ui+react-presence@1.0.1_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-presence/dist/index.mjs
var import_react24 = require("react");
var import_react_dom4 = require("react-dom");
function $fe963b355347cc68$export$3e6543de14f8614f(initialState, machine) {
  return (0, import_react24.useReducer)((state, event) => {
    const nextState = machine[state][event];
    return nextState !== null && nextState !== void 0 ? nextState : state;
  }, initialState);
}
var $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {
  const { present, children } = props;
  const presence = $921a889cee6df7e8$var$usePresence(present);
  const child = typeof children === "function" ? children({
    present: presence.isPresent
  }) : import_react24.Children.only(children);
  const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref);
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? /* @__PURE__ */ (0, import_react24.cloneElement)(child, {
    ref
  }) : null;
};
$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = "Presence";
function $921a889cee6df7e8$var$usePresence(present) {
  const [node1, setNode] = (0, import_react24.useState)();
  const stylesRef = (0, import_react24.useRef)({});
  const prevPresentRef = (0, import_react24.useRef)(present);
  const prevAnimationNameRef = (0, import_react24.useRef)("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  (0, import_react24.useEffect)(() => {
    const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [
    state
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles);
      if (present)
        send("MOUNT");
      else if (currentAnimationName === "none" || (styles === null || styles === void 0 ? void 0 : styles.display) === "none")
        send("UNMOUNT");
      else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating)
          send("ANIMATION_OUT");
        else
          send("UNMOUNT");
      }
      prevPresentRef.current = present;
    }
  }, [
    present,
    send
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (node1) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node1 && isCurrentAnimation)
          (0, import_react_dom4.flushSync)(
            () => send("ANIMATION_END")
          );
      };
      const handleAnimationStart = (event) => {
        if (event.target === node1)
          prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
      };
      node1.addEventListener("animationstart", handleAnimationStart);
      node1.addEventListener("animationcancel", handleAnimationEnd);
      node1.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node1.removeEventListener("animationstart", handleAnimationStart);
        node1.removeEventListener("animationcancel", handleAnimationEnd);
        node1.removeEventListener("animationend", handleAnimationEnd);
      };
    } else
      send("ANIMATION_END");
  }, [
    node1,
    send
  ]);
  return {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(state),
    ref: (0, import_react24.useCallback)((node) => {
      if (node)
        stylesRef.current = getComputedStyle(node);
      setNode(node);
    }, [])
  };
}
function $921a889cee6df7e8$var$getAnimationName(styles) {
  return (styles === null || styles === void 0 ? void 0 : styles.animationName) || "none";
}

// node_modules/.pnpm/@radix-ui+react-roving-focus@1.0.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-roving-focus/dist/index.mjs
var import_react26 = require("react");

// node_modules/.pnpm/@radix-ui+react-use-controllable-state@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var import_react25 = require("react");
function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {
} }) {
  const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value1 = isControlled ? prop : uncontrolledProp;
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  const setValue = (0, import_react25.useCallback)((nextValue) => {
    if (isControlled) {
      const setter = nextValue;
      const value = typeof nextValue === "function" ? setter(prop) : nextValue;
      if (value !== prop)
        handleChange(value);
    } else
      setUncontrolledProp(nextValue);
  }, [
    isControlled,
    prop,
    setUncontrolledProp,
    handleChange
  ]);
  return [
    value1,
    setValue
  ];
}
function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {
  const uncontrolledState = (0, import_react25.useState)(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = (0, import_react25.useRef)(value);
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  (0, import_react25.useEffect)(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [
    value,
    prevValueRef,
    handleChange
  ]);
  return uncontrolledState;
}

// node_modules/.pnpm/@radix-ui+react-roving-focus@1.0.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-roving-focus/dist/index.mjs
var $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
var $d7bdfb9eb0fdf311$var$GROUP_NAME = "RovingFocusGroup";
var [$d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($d7bdfb9eb0fdf311$var$GROUP_NAME);
var [$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d7bdfb9eb0fdf311$var$GROUP_NAME, [
  $d7bdfb9eb0fdf311$var$createCollectionScope
]);
var [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] = $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME);
var $d7bdfb9eb0fdf311$export$8699f7c8af148338 = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {
  return /* @__PURE__ */ (0, import_react26.createElement)($d7bdfb9eb0fdf311$var$Collection.Provider, {
    scope: props.__scopeRovingFocusGroup
  }, /* @__PURE__ */ (0, import_react26.createElement)($d7bdfb9eb0fdf311$var$Collection.Slot, {
    scope: props.__scopeRovingFocusGroup
  }, /* @__PURE__ */ (0, import_react26.createElement)($d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, _extends({}, props, {
    ref: forwardedRef
  }))));
});
var $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {
  const { __scopeRovingFocusGroup, orientation, loop = false, dir, currentTabStopId: currentTabStopIdProp, defaultCurrentTabStopId, onCurrentTabStopIdChange, onEntryFocus, ...groupProps } = props;
  const ref = (0, import_react26.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = (0, import_react26.useState)(false);
  const handleEntryFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEntryFocus);
  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = (0, import_react26.useRef)(false);
  const [focusableItemsCount, setFocusableItemsCount] = (0, import_react26.useState)(0);
  (0, import_react26.useEffect)(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
    }
  }, [
    handleEntryFocus
  ]);
  return /* @__PURE__ */ (0, import_react26.createElement)($d7bdfb9eb0fdf311$var$RovingFocusProvider, {
    scope: __scopeRovingFocusGroup,
    orientation,
    dir: direction,
    loop,
    currentTabStopId,
    onItemFocus: (0, import_react26.useCallback)(
      (tabStopId) => setCurrentTabStopId(tabStopId),
      [
        setCurrentTabStopId
      ]
    ),
    onItemShiftTab: (0, import_react26.useCallback)(
      () => setIsTabbingBackOut(true),
      []
    ),
    onFocusableItemAdd: (0, import_react26.useCallback)(
      () => setFocusableItemsCount(
        (prevCount) => prevCount + 1
      ),
      []
    ),
    onFocusableItemRemove: (0, import_react26.useCallback)(
      () => setFocusableItemsCount(
        (prevCount) => prevCount - 1
      ),
      []
    )
  }, /* @__PURE__ */ (0, import_react26.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
    "data-orientation": orientation
  }, groupProps, {
    ref: composedRefs,
    style: {
      outline: "none",
      ...props.style
    },
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, () => {
      isClickFocusRef.current = true;
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, (event) => {
      const isKeyboardFocus = !isClickFocusRef.current;
      if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
        const entryFocusEvent = new CustomEvent($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS);
        event.currentTarget.dispatchEvent(entryFocusEvent);
        if (!entryFocusEvent.defaultPrevented) {
          const items = getItems().filter(
            (item) => item.focusable
          );
          const activeItem = items.find(
            (item) => item.active
          );
          const currentItem = items.find(
            (item) => item.id === currentTabStopId
          );
          const candidateItems = [
            activeItem,
            currentItem,
            ...items
          ].filter(Boolean);
          const candidateNodes = candidateItems.map(
            (item) => item.ref.current
          );
          $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes);
        }
      }
      isClickFocusRef.current = false;
    }),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onBlur,
      () => setIsTabbingBackOut(false)
    )
  })));
});
var $d7bdfb9eb0fdf311$var$ITEM_NAME = "RovingFocusGroupItem";
var $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {
  const { __scopeRovingFocusGroup, focusable = true, active = false, tabStopId, ...itemProps } = props;
  const autoId = $1746a345f3d73bb7$export$f680877a34711e37();
  const id = tabStopId || autoId;
  const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext($d7bdfb9eb0fdf311$var$ITEM_NAME, __scopeRovingFocusGroup);
  const isCurrentTabStop = context.currentTabStopId === id;
  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
  const { onFocusableItemAdd, onFocusableItemRemove } = context;
  (0, import_react26.useEffect)(() => {
    if (focusable) {
      onFocusableItemAdd();
      return () => onFocusableItemRemove();
    }
  }, [
    focusable,
    onFocusableItemAdd,
    onFocusableItemRemove
  ]);
  return /* @__PURE__ */ (0, import_react26.createElement)($d7bdfb9eb0fdf311$var$Collection.ItemSlot, {
    scope: __scopeRovingFocusGroup,
    id,
    focusable,
    active
  }, /* @__PURE__ */ (0, import_react26.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
    tabIndex: isCurrentTabStop ? 0 : -1,
    "data-orientation": context.orientation
  }, itemProps, {
    ref: forwardedRef,
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {
      if (!focusable)
        event.preventDefault();
      else
        context.onItemFocus(id);
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocus,
      () => context.onItemFocus(id)
    ),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      if (event.key === "Tab" && event.shiftKey) {
        context.onItemShiftTab();
        return;
      }
      if (event.target !== event.currentTarget)
        return;
      const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(event, context.orientation, context.dir);
      if (focusIntent !== void 0) {
        event.preventDefault();
        const items = getItems().filter(
          (item) => item.focusable
        );
        let candidateNodes = items.map(
          (item) => item.ref.current
        );
        if (focusIntent === "last")
          candidateNodes.reverse();
        else if (focusIntent === "prev" || focusIntent === "next") {
          if (focusIntent === "prev")
            candidateNodes.reverse();
          const currentIndex = candidateNodes.indexOf(event.currentTarget);
          candidateNodes = context.loop ? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
        }
        setTimeout(
          () => $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)
        );
      }
    })
  })));
});
var $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir) {
  const key = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && [
    "ArrowLeft",
    "ArrowRight"
  ].includes(key))
    return void 0;
  if (orientation === "horizontal" && [
    "ArrowUp",
    "ArrowDown"
  ].includes(key))
    return void 0;
  return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key];
}
function $d7bdfb9eb0fdf311$var$focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function $d7bdfb9eb0fdf311$var$wrapArray(array, startIndex) {
  return array.map(
    (_3, index2) => array[(startIndex + index2) % array.length]
  );
}
var $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338;
var $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454;

// node_modules/.pnpm/aria-hidden@1.2.2_@types+react@18.2.7_react@18.2.0/node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x5) {
    return Boolean(x5);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        var attr = node.getAttribute(controlAttribute);
        var alreadyHidden = attr !== null && attr !== "false";
        var counterValue = (counterMap.get(node) || 0) + 1;
        var markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenNodes.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node, true);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node.setAttribute(controlAttribute, "true");
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// node_modules/.pnpm/tslib@2.5.2/node_modules/tslib/tslib.es6.js
var __assign = function() {
  __assign = Object.assign || function __assign2(t5) {
    for (var s5, i4 = 1, n5 = arguments.length; i4 < n5; i4++) {
      s5 = arguments[i4];
      for (var p6 in s5)
        if (Object.prototype.hasOwnProperty.call(s5, p6))
          t5[p6] = s5[p6];
    }
    return t5;
  };
  return __assign.apply(this, arguments);
};
function __rest(s5, e5) {
  var t5 = {};
  for (var p6 in s5)
    if (Object.prototype.hasOwnProperty.call(s5, p6) && e5.indexOf(p6) < 0)
      t5[p6] = s5[p6];
  if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p6 = Object.getOwnPropertySymbols(s5); i4 < p6.length; i4++) {
      if (e5.indexOf(p6[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p6[i4]))
        t5[p6[i4]] = s5[p6[i4]];
    }
  return t5;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i4 = 0, l7 = from.length, ar; i4 < l7; i4++) {
      if (ar || !(i4 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i4);
        ar[i4] = from[i4];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/Combination.js
var React8 = __toESM(require("react"));

// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/UI.js
var React4 = __toESM(require("react"));

// node_modules/.pnpm/react-remove-scroll-bar@2.3.4_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// node_modules/.pnpm/use-callback-ref@1.3.0_@types+react@18.2.7_react@18.2.0/node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// node_modules/.pnpm/use-callback-ref@1.3.0_@types+react@18.2.7_react@18.2.0/node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react27 = require("react");
function useCallbackRef(initialValue, callback) {
  var ref = (0, import_react27.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// node_modules/.pnpm/use-callback-ref@1.3.0_@types+react@18.2.7_react@18.2.0/node_modules/use-callback-ref/dist/es2015/useMergeRef.js
function useMergeRefs(refs, defaultValue) {
  return useCallbackRef(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
}

// node_modules/.pnpm/use-sidecar@1.1.2_@types+react@18.2.7_react@18.2.0/node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a7) {
  return a7;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x5) {
          return x5 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x5) {
          return cb(x5);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x5) {
          pendingQueue.push(x5);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// node_modules/.pnpm/use-sidecar@1.1.2_@types+react@18.2.7_react@18.2.0/node_modules/use-sidecar/dist/es2015/exports.js
var React3 = __toESM(require("react"));
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React3.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React4.forwardRef(function(props, parentRef) {
  var ref = React4.useRef(null);
  var _a = React4.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React4.createElement(
    React4.Fragment,
    null,
    enabled && React4.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
    forwardProps ? React4.cloneElement(React4.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React4.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React7 = __toESM(require("react"));

// node_modules/.pnpm/react-remove-scroll-bar@2.3.4_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React6 = __toESM(require("react"));

// node_modules/.pnpm/react-style-singleton@2.2.1_@types+react@18.2.7_react@18.2.0/node_modules/react-style-singleton/dist/es2015/hook.js
var React5 = __toESM(require("react"));

// node_modules/.pnpm/get-nonce@1.0.1/node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// node_modules/.pnpm/react-style-singleton@2.2.1_@types+react@18.2.7_react@18.2.0/node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// node_modules/.pnpm/react-style-singleton@2.2.1_@types+react@18.2.7_react@18.2.0/node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React5.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// node_modules/.pnpm/react-style-singleton@2.2.1_@types+react@18.2.7_react@18.2.0/node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// node_modules/.pnpm/react-remove-scroll-bar@2.3.4_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse2 = function(x5) {
  return parseInt(x5 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top2 = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse2(left), parse2(top2), parse2(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// node_modules/.pnpm/react-remove-scroll-bar@2.3.4_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top2 = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top2, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var RemoveScrollBar = function(props) {
  var noRelative = props.noRelative, noImportant = props.noImportant, _a = props.gapMode, gapMode = _a === void 0 ? "margin" : _a;
  var gap = React6.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React6.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), s5 = _a[1], d6 = _a[2];
      if (s5 > d6) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target = target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x5, y6) {
  return x5[0] === y6[0] && x5[1] === y6[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React7.useRef([]);
  var touchStartRef = React7.useRef([0, 0]);
  var activeAxis = React7.useRef();
  var id = React7.useState(idCounter++)[0];
  var Style2 = React7.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = React7.useRef(props);
  React7.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React7.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React7.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React7.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e5) {
      return e5.name === event.type && e5.target === event.target && deltaCompare(e5.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React7.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e5) {
        return e5 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React7.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React7.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React7.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React7.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React7.createElement(
    React7.Fragment,
    null,
    inert ? React7.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React7.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
  );
}

// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React8.forwardRef(function(props, ref) {
  return React8.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// node_modules/.pnpm/@radix-ui+react-menu@2.0.5_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-menu/dist/index.mjs
var $6cc32821e9371a1c$var$SELECTION_KEYS = [
  "Enter",
  " "
];
var $6cc32821e9371a1c$var$FIRST_KEYS = [
  "ArrowDown",
  "PageUp",
  "Home"
];
var $6cc32821e9371a1c$var$LAST_KEYS = [
  "ArrowUp",
  "PageDown",
  "End"
];
var $6cc32821e9371a1c$var$FIRST_LAST_KEYS = [
  ...$6cc32821e9371a1c$var$FIRST_KEYS,
  ...$6cc32821e9371a1c$var$LAST_KEYS
];
var $6cc32821e9371a1c$var$SUB_OPEN_KEYS = {
  ltr: [
    ...$6cc32821e9371a1c$var$SELECTION_KEYS,
    "ArrowRight"
  ],
  rtl: [
    ...$6cc32821e9371a1c$var$SELECTION_KEYS,
    "ArrowLeft"
  ]
};
var $6cc32821e9371a1c$var$SUB_CLOSE_KEYS = {
  ltr: [
    "ArrowLeft"
  ],
  rtl: [
    "ArrowRight"
  ]
};
var $6cc32821e9371a1c$var$MENU_NAME = "Menu";
var [$6cc32821e9371a1c$var$Collection, $6cc32821e9371a1c$var$useCollection, $6cc32821e9371a1c$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($6cc32821e9371a1c$var$MENU_NAME);
var [$6cc32821e9371a1c$var$createMenuContext, $6cc32821e9371a1c$export$4027731b685e72eb] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($6cc32821e9371a1c$var$MENU_NAME, [
  $6cc32821e9371a1c$var$createCollectionScope,
  $cf1ac5d9fe0e8206$export$722aac194ae923,
  $d7bdfb9eb0fdf311$export$c7109489551a4f4
]);
var $6cc32821e9371a1c$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
var $6cc32821e9371a1c$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
var [$6cc32821e9371a1c$var$MenuProvider, $6cc32821e9371a1c$var$useMenuContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);
var [$6cc32821e9371a1c$var$MenuRootProvider, $6cc32821e9371a1c$var$useMenuRootContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);
var $6cc32821e9371a1c$export$d9b273488cd8ce6f = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  const [content, setContent] = (0, import_react28.useState)(null);
  const isUsingKeyboardRef = (0, import_react28.useRef)(false);
  const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);
  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
  (0, import_react28.useEffect)(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, {
        capture: true,
        once: true
      });
      document.addEventListener("pointermove", handlePointer, {
        capture: true,
        once: true
      });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, {
      capture: true
    });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, {
        capture: true
      });
      document.removeEventListener("pointerdown", handlePointer, {
        capture: true
      });
      document.removeEventListener("pointermove", handlePointer, {
        capture: true
      });
    };
  }, []);
  return /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuProvider, {
    scope: __scopeMenu,
    open,
    onOpenChange: handleOpenChange,
    content,
    onContentChange: setContent
  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuRootProvider, {
    scope: __scopeMenu,
    onClose: (0, import_react28.useCallback)(
      () => handleOpenChange(false),
      [
        handleOpenChange
      ]
    ),
    isUsingKeyboardRef,
    dir: direction,
    modal
  }, children)));
};
var $6cc32821e9371a1c$export$9fa5ebd18bee4d43 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const { __scopeMenu, ...anchorProps } = props;
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  return /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({}, popperScope, anchorProps, {
    ref: forwardedRef
  }));
});
var $6cc32821e9371a1c$var$PORTAL_NAME = "MenuPortal";
var [$6cc32821e9371a1c$var$PortalProvider, $6cc32821e9371a1c$var$usePortalContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, {
  forceMount: void 0
});
var $6cc32821e9371a1c$export$793392f970497feb = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, __scopeMenu);
  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$PortalProvider, {
    scope: __scopeMenu,
    forceMount
  }, /* @__PURE__ */ (0, import_react28.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ (0, import_react28.createElement)($f1701beae083dbae$export$602eac185826482c, {
    asChild: true,
    container
  }, children)));
};
var $6cc32821e9371a1c$var$CONTENT_NAME = "MenuContent";
var [$6cc32821e9371a1c$var$MenuContentProvider, $6cc32821e9371a1c$var$useMenuContentContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$CONTENT_NAME);
var $6cc32821e9371a1c$export$479f0f2f71193efe = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$Collection.Provider, {
    scope: props.__scopeMenu
  }, /* @__PURE__ */ (0, import_react28.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$Collection.Slot, {
    scope: props.__scopeMenu
  }, rootContext.modal ? /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuRootContentModal, _extends({}, contentProps, {
    ref: forwardedRef
  })) : /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuRootContentNonModal, _extends({}, contentProps, {
    ref: forwardedRef
  })))));
});
var $6cc32821e9371a1c$var$MenuRootContentModal = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const ref = (0, import_react28.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  (0, import_react28.useEffect)(() => {
    const content = ref.current;
    if (content)
      return hideOthers(content);
  }, []);
  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuContentImpl, _extends({}, props, {
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: context.open,
    disableOutsideScroll: true,
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocusOutside,
      (event) => event.preventDefault(),
      {
        checkForDefaultPrevented: false
      }
    ),
    onDismiss: () => context.onOpenChange(false)
  }));
});
var $6cc32821e9371a1c$var$MenuRootContentNonModal = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuContentImpl, _extends({}, props, {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    disableOutsideScroll: false,
    onDismiss: () => context.onOpenChange(false)
  }));
});
var $6cc32821e9371a1c$var$MenuContentImpl = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const { __scopeMenu, loop = false, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEntryFocus, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, disableOutsideScroll, ...contentProps } = props;
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);
  const getItems = $6cc32821e9371a1c$var$useCollection(__scopeMenu);
  const [currentItemId, setCurrentItemId] = (0, import_react28.useState)(null);
  const contentRef = (0, import_react28.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef, context.onContentChange);
  const timerRef = (0, import_react28.useRef)(0);
  const searchRef = (0, import_react28.useRef)("");
  const pointerGraceTimerRef = (0, import_react28.useRef)(0);
  const pointerGraceIntentRef = (0, import_react28.useRef)(null);
  const pointerDirRef = (0, import_react28.useRef)("right");
  const lastPointerXRef = (0, import_react28.useRef)(0);
  const ScrollLockWrapper = disableOutsideScroll ? Combination_default : import_react28.Fragment;
  const scrollLockWrapperProps = disableOutsideScroll ? {
    as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
    allowPinchZoom: true
  } : void 0;
  const handleTypeaheadSearch = (key) => {
    var _items$find, _items$find2;
    const search = searchRef.current + key;
    const items = getItems().filter(
      (item) => !item.disabled
    );
    const currentItem = document.activeElement;
    const currentMatch = (_items$find = items.find(
      (item) => item.ref.current === currentItem
    )) === null || _items$find === void 0 ? void 0 : _items$find.textValue;
    const values = items.map(
      (item) => item.textValue
    );
    const nextMatch = $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch);
    const newItem = (_items$find2 = items.find(
      (item) => item.textValue === nextMatch
    )) === null || _items$find2 === void 0 ? void 0 : _items$find2.ref.current;
    (function updateSearch(value) {
      searchRef.current = value;
      window.clearTimeout(timerRef.current);
      if (value !== "")
        timerRef.current = window.setTimeout(
          () => updateSearch(""),
          1e3
        );
    })(search);
    if (newItem)
      setTimeout(
        () => newItem.focus()
      );
  };
  (0, import_react28.useEffect)(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
  const isPointerMovingToSubmenu = (0, import_react28.useCallback)((event) => {
    var _pointerGraceIntentRe, _pointerGraceIntentRe2;
    const isMovingTowards = pointerDirRef.current === ((_pointerGraceIntentRe = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe === void 0 ? void 0 : _pointerGraceIntentRe.side);
    return isMovingTowards && $6cc32821e9371a1c$var$isPointerInGraceArea(event, (_pointerGraceIntentRe2 = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe2 === void 0 ? void 0 : _pointerGraceIntentRe2.area);
  }, []);
  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuContentProvider, {
    scope: __scopeMenu,
    searchRef,
    onItemEnter: (0, import_react28.useCallback)((event) => {
      if (isPointerMovingToSubmenu(event))
        event.preventDefault();
    }, [
      isPointerMovingToSubmenu
    ]),
    onItemLeave: (0, import_react28.useCallback)((event) => {
      var _contentRef$current;
      if (isPointerMovingToSubmenu(event))
        return;
      (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 || _contentRef$current.focus();
      setCurrentItemId(null);
    }, [
      isPointerMovingToSubmenu
    ]),
    onTriggerLeave: (0, import_react28.useCallback)((event) => {
      if (isPointerMovingToSubmenu(event))
        event.preventDefault();
    }, [
      isPointerMovingToSubmenu
    ]),
    pointerGraceTimerRef,
    onPointerGraceIntentChange: (0, import_react28.useCallback)((intent) => {
      pointerGraceIntentRef.current = intent;
    }, [])
  }, /* @__PURE__ */ (0, import_react28.createElement)(ScrollLockWrapper, scrollLockWrapperProps, /* @__PURE__ */ (0, import_react28.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {
    asChild: true,
    trapped: trapFocus,
    onMountAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onOpenAutoFocus, (event) => {
      var _contentRef$current2;
      event.preventDefault();
      (_contentRef$current2 = contentRef.current) === null || _contentRef$current2 === void 0 || _contentRef$current2.focus();
    }),
    onUnmountAutoFocus: onCloseAutoFocus
  }, /* @__PURE__ */ (0, import_react28.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    onDismiss
  }, /* @__PURE__ */ (0, import_react28.createElement)($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends({
    asChild: true
  }, rovingFocusGroupScope, {
    dir: rootContext.dir,
    orientation: "vertical",
    loop,
    currentTabStopId: currentItemId,
    onCurrentTabStopIdChange: setCurrentItemId,
    onEntryFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onEntryFocus, (event) => {
      if (!rootContext.isUsingKeyboardRef.current)
        event.preventDefault();
    })
  }), /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({
    role: "menu",
    "aria-orientation": "vertical",
    "data-state": $6cc32821e9371a1c$var$getOpenState(context.open),
    "data-radix-menu-content": "",
    dir: rootContext.dir
  }, popperScope, contentProps, {
    ref: composedRefs,
    style: {
      outline: "none",
      ...contentProps.style
    },
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onKeyDown, (event) => {
      const target = event.target;
      const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
      const isCharacterKey = event.key.length === 1;
      if (isKeyDownInside) {
        if (event.key === "Tab")
          event.preventDefault();
        if (!isModifierKey && isCharacterKey)
          handleTypeaheadSearch(event.key);
      }
      const content = contentRef.current;
      if (event.target !== content)
        return;
      if (!$6cc32821e9371a1c$var$FIRST_LAST_KEYS.includes(event.key))
        return;
      event.preventDefault();
      const items = getItems().filter(
        (item) => !item.disabled
      );
      const candidateNodes = items.map(
        (item) => item.ref.current
      );
      if ($6cc32821e9371a1c$var$LAST_KEYS.includes(event.key))
        candidateNodes.reverse();
      $6cc32821e9371a1c$var$focusFirst(candidateNodes);
    }),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, (event) => {
      if (!event.currentTarget.contains(event.target)) {
        window.clearTimeout(timerRef.current);
        searchRef.current = "";
      }
    }),
    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
      const target = event.target;
      const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
      if (event.currentTarget.contains(target) && pointerXHasChanged) {
        const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
        pointerDirRef.current = newDir;
        lastPointerXRef.current = event.clientX;
      }
    }))
  })))))));
});
var $6cc32821e9371a1c$export$22a631d1f72787bb = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const { __scopeMenu, ...groupProps } = props;
  return /* @__PURE__ */ (0, import_react28.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    role: "group"
  }, groupProps, {
    ref: forwardedRef
  }));
});
var $6cc32821e9371a1c$var$ITEM_NAME = "MenuItem";
var $6cc32821e9371a1c$var$ITEM_SELECT = "menu.itemSelect";
var $6cc32821e9371a1c$export$2ce376c2cc3355c8 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const { disabled = false, onSelect, ...itemProps } = props;
  const ref = (0, import_react28.useRef)(null);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);
  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const isPointerDownRef = (0, import_react28.useRef)(false);
  const handleSelect = () => {
    const menuItem = ref.current;
    if (!disabled && menuItem) {
      const itemSelectEvent = new CustomEvent($6cc32821e9371a1c$var$ITEM_SELECT, {
        bubbles: true,
        cancelable: true
      });
      menuItem.addEventListener(
        $6cc32821e9371a1c$var$ITEM_SELECT,
        (event) => onSelect === null || onSelect === void 0 ? void 0 : onSelect(event),
        {
          once: true
        }
      );
      $8927f6f2acc4f386$export$6d1a0317bde7de7f(menuItem, itemSelectEvent);
      if (itemSelectEvent.defaultPrevented)
        isPointerDownRef.current = false;
      else
        rootContext.onClose();
    }
  };
  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuItemImpl, _extends({}, itemProps, {
    ref: composedRefs,
    disabled,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, handleSelect),
    onPointerDown: (event) => {
      var _props$onPointerDown;
      (_props$onPointerDown = props.onPointerDown) === null || _props$onPointerDown === void 0 || _props$onPointerDown.call(props, event);
      isPointerDownRef.current = true;
    },
    onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, (event) => {
      var _event$currentTarget;
      if (!isPointerDownRef.current)
        (_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || _event$currentTarget.click();
    }),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      const isTypingAhead = contentContext.searchRef.current !== "";
      if (disabled || isTypingAhead && event.key === " ")
        return;
      if ($6cc32821e9371a1c$var$SELECTION_KEYS.includes(event.key)) {
        event.currentTarget.click();
        event.preventDefault();
      }
    })
  }));
});
var $6cc32821e9371a1c$var$MenuItemImpl = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, __scopeMenu);
  const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);
  const ref = (0, import_react28.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const [isFocused, setIsFocused] = (0, import_react28.useState)(false);
  const [textContent, setTextContent] = (0, import_react28.useState)("");
  (0, import_react28.useEffect)(() => {
    const menuItem = ref.current;
    if (menuItem) {
      var _menuItem$textContent;
      setTextContent(((_menuItem$textContent = menuItem.textContent) !== null && _menuItem$textContent !== void 0 ? _menuItem$textContent : "").trim());
    }
  }, [
    itemProps.children
  ]);
  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$Collection.ItemSlot, {
    scope: __scopeMenu,
    disabled,
    textValue: textValue !== null && textValue !== void 0 ? textValue : textContent
  }, /* @__PURE__ */ (0, import_react28.createElement)($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends({
    asChild: true
  }, rovingFocusGroupScope, {
    focusable: !disabled
  }), /* @__PURE__ */ (0, import_react28.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    role: "menuitem",
    "data-highlighted": isFocused ? "" : void 0,
    "aria-disabled": disabled || void 0,
    "data-disabled": disabled ? "" : void 0
  }, itemProps, {
    ref: composedRefs,
    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
      if (disabled)
        contentContext.onItemLeave(event);
      else {
        contentContext.onItemEnter(event);
        if (!event.defaultPrevented) {
          const item = event.currentTarget;
          item.focus();
        }
      }
    })),
    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse(
      (event) => contentContext.onItemLeave(event)
    )),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocus,
      () => setIsFocused(true)
    ),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onBlur,
      () => setIsFocused(false)
    )
  }))));
});
var $6cc32821e9371a1c$export$f6f243521332502d = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$ItemIndicatorProvider, {
    scope: props.__scopeMenu,
    checked
  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$export$2ce376c2cc3355c8, _extends({
    role: "menuitemcheckbox",
    "aria-checked": $6cc32821e9371a1c$var$isIndeterminate(checked) ? "mixed" : checked
  }, checkboxItemProps, {
    ref: forwardedRef,
    "data-state": $6cc32821e9371a1c$var$getCheckedState(checked),
    onSelect: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      checkboxItemProps.onSelect,
      () => onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange($6cc32821e9371a1c$var$isIndeterminate(checked) ? true : !checked),
      {
        checkForDefaultPrevented: false
      }
    )
  })));
});
var $6cc32821e9371a1c$var$RADIO_GROUP_NAME = "MenuRadioGroup";
var [$6cc32821e9371a1c$var$RadioGroupProvider, $6cc32821e9371a1c$var$useRadioGroupContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$RADIO_GROUP_NAME, {
  value: void 0,
  onValueChange: () => {
  }
});
var $6cc32821e9371a1c$export$ea2200c9eee416b3 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const { value, onValueChange, ...groupProps } = props;
  const handleValueChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onValueChange);
  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$RadioGroupProvider, {
    scope: props.__scopeMenu,
    value,
    onValueChange: handleValueChange
  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$export$22a631d1f72787bb, _extends({}, groupProps, {
    ref: forwardedRef
  })));
});
var $6cc32821e9371a1c$var$RADIO_ITEM_NAME = "MenuRadioItem";
var $6cc32821e9371a1c$export$69bd225e9817f6d0 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const { value, ...radioItemProps } = props;
  const context = $6cc32821e9371a1c$var$useRadioGroupContext($6cc32821e9371a1c$var$RADIO_ITEM_NAME, props.__scopeMenu);
  const checked = value === context.value;
  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$ItemIndicatorProvider, {
    scope: props.__scopeMenu,
    checked
  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$export$2ce376c2cc3355c8, _extends({
    role: "menuitemradio",
    "aria-checked": checked
  }, radioItemProps, {
    ref: forwardedRef,
    "data-state": $6cc32821e9371a1c$var$getCheckedState(checked),
    onSelect: $e42e1063c40fb3ef$export$b9ecd428b558ff10(radioItemProps.onSelect, () => {
      var _context$onValueChang;
      return (_context$onValueChang = context.onValueChange) === null || _context$onValueChang === void 0 ? void 0 : _context$onValueChang.call(context, value);
    }, {
      checkForDefaultPrevented: false
    })
  })));
});
var $6cc32821e9371a1c$var$ITEM_INDICATOR_NAME = "MenuItemIndicator";
var [$6cc32821e9371a1c$var$ItemIndicatorProvider, $6cc32821e9371a1c$var$useItemIndicatorContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, {
  checked: false
});
var $6cc32821e9371a1c$export$a2593e23056970a3 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
  const indicatorContext = $6cc32821e9371a1c$var$useItemIndicatorContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, __scopeMenu);
  return /* @__PURE__ */ (0, import_react28.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || $6cc32821e9371a1c$var$isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true
  }, /* @__PURE__ */ (0, import_react28.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({}, itemIndicatorProps, {
    ref: forwardedRef,
    "data-state": $6cc32821e9371a1c$var$getCheckedState(indicatorContext.checked)
  })));
});
var $6cc32821e9371a1c$export$1cec7dcdd713e220 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const { __scopeMenu, ...separatorProps } = props;
  return /* @__PURE__ */ (0, import_react28.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    role: "separator",
    "aria-orientation": "horizontal"
  }, separatorProps, {
    ref: forwardedRef
  }));
});
var $6cc32821e9371a1c$export$bcdda4773debf5fa = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const { __scopeMenu, ...arrowProps } = props;
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  return /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {
    ref: forwardedRef
  }));
});
var $6cc32821e9371a1c$var$SUB_NAME = "MenuSub";
var [$6cc32821e9371a1c$var$MenuSubProvider, $6cc32821e9371a1c$var$useMenuSubContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$SUB_NAME);
var $6cc32821e9371a1c$export$71bdb9d1e2909932 = (props) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props;
  const parentMenuContext = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$SUB_NAME, __scopeMenu);
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  const [trigger, setTrigger] = (0, import_react28.useState)(null);
  const [content, setContent] = (0, import_react28.useState)(null);
  const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);
  (0, import_react28.useEffect)(() => {
    if (parentMenuContext.open === false)
      handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [
    parentMenuContext.open,
    handleOpenChange
  ]);
  return /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuProvider, {
    scope: __scopeMenu,
    open,
    onOpenChange: handleOpenChange,
    content,
    onContentChange: setContent
  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuSubProvider, {
    scope: __scopeMenu,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    triggerId: $1746a345f3d73bb7$export$f680877a34711e37(),
    trigger,
    onTriggerChange: setTrigger
  }, children)));
};
var $6cc32821e9371a1c$var$SUB_TRIGGER_NAME = "MenuSubTrigger";
var $6cc32821e9371a1c$export$5fbbb3ba7297405f = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
  const subContext = $6cc32821e9371a1c$var$useMenuSubContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
  const openTimerRef = (0, import_react28.useRef)(null);
  const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
  const scope = {
    __scopeMenu: props.__scopeMenu
  };
  const clearOpenTimer = (0, import_react28.useCallback)(() => {
    if (openTimerRef.current)
      window.clearTimeout(openTimerRef.current);
    openTimerRef.current = null;
  }, []);
  (0, import_react28.useEffect)(
    () => clearOpenTimer,
    [
      clearOpenTimer
    ]
  );
  (0, import_react28.useEffect)(() => {
    const pointerGraceTimer = pointerGraceTimerRef.current;
    return () => {
      window.clearTimeout(pointerGraceTimer);
      onPointerGraceIntentChange(null);
    };
  }, [
    pointerGraceTimerRef,
    onPointerGraceIntentChange
  ]);
  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$export$9fa5ebd18bee4d43, _extends({
    asChild: true
  }, scope), /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuItemImpl, _extends({
    id: subContext.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": context.open,
    "aria-controls": subContext.contentId,
    "data-state": $6cc32821e9371a1c$var$getOpenState(context.open)
  }, props, {
    ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, subContext.onTriggerChange),
    onClick: (event) => {
      var _props$onClick;
      (_props$onClick = props.onClick) === null || _props$onClick === void 0 || _props$onClick.call(props, event);
      if (props.disabled || event.defaultPrevented)
        return;
      event.currentTarget.focus();
      if (!context.open)
        context.onOpenChange(true);
    },
    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
      contentContext.onItemEnter(event);
      if (event.defaultPrevented)
        return;
      if (!props.disabled && !context.open && !openTimerRef.current) {
        contentContext.onPointerGraceIntentChange(null);
        openTimerRef.current = window.setTimeout(() => {
          context.onOpenChange(true);
          clearOpenTimer();
        }, 100);
      }
    })),
    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse((event) => {
      var _context$content;
      clearOpenTimer();
      const contentRect = (_context$content = context.content) === null || _context$content === void 0 ? void 0 : _context$content.getBoundingClientRect();
      if (contentRect) {
        var _context$content2;
        const side = (_context$content2 = context.content) === null || _context$content2 === void 0 ? void 0 : _context$content2.dataset.side;
        const rightSide = side === "right";
        const bleed = rightSide ? -5 : 5;
        const contentNearEdge = contentRect[rightSide ? "left" : "right"];
        const contentFarEdge = contentRect[rightSide ? "right" : "left"];
        contentContext.onPointerGraceIntentChange({
          area: [
            // consistently within polygon bounds
            {
              x: event.clientX + bleed,
              y: event.clientY
            },
            {
              x: contentNearEdge,
              y: contentRect.top
            },
            {
              x: contentFarEdge,
              y: contentRect.top
            },
            {
              x: contentFarEdge,
              y: contentRect.bottom
            },
            {
              x: contentNearEdge,
              y: contentRect.bottom
            }
          ],
          side
        });
        window.clearTimeout(pointerGraceTimerRef.current);
        pointerGraceTimerRef.current = window.setTimeout(
          () => contentContext.onPointerGraceIntentChange(null),
          300
        );
      } else {
        contentContext.onTriggerLeave(event);
        if (event.defaultPrevented)
          return;
        contentContext.onPointerGraceIntentChange(null);
      }
    })),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      const isTypingAhead = contentContext.searchRef.current !== "";
      if (props.disabled || isTypingAhead && event.key === " ")
        return;
      if ($6cc32821e9371a1c$var$SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
        var _context$content3;
        context.onOpenChange(true);
        (_context$content3 = context.content) === null || _context$content3 === void 0 || _context$content3.focus();
        event.preventDefault();
      }
    })
  })));
});
var $6cc32821e9371a1c$var$SUB_CONTENT_NAME = "MenuSubContent";
var $6cc32821e9371a1c$export$e7142ab31822bde6 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const { forceMount = portalContext.forceMount, ...subContentProps } = props;
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const subContext = $6cc32821e9371a1c$var$useMenuSubContext($6cc32821e9371a1c$var$SUB_CONTENT_NAME, props.__scopeMenu);
  const ref = (0, import_react28.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$Collection.Provider, {
    scope: props.__scopeMenu
  }, /* @__PURE__ */ (0, import_react28.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$Collection.Slot, {
    scope: props.__scopeMenu
  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuContentImpl, _extends({
    id: subContext.contentId,
    "aria-labelledby": subContext.triggerId
  }, subContentProps, {
    ref: composedRefs,
    align: "start",
    side: rootContext.dir === "rtl" ? "left" : "right",
    disableOutsidePointerEvents: false,
    disableOutsideScroll: false,
    trapFocus: false,
    onOpenAutoFocus: (event) => {
      var _ref$current;
      if (rootContext.isUsingKeyboardRef.current)
        (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.focus();
      event.preventDefault();
    },
    onCloseAutoFocus: (event) => event.preventDefault(),
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusOutside, (event) => {
      if (event.target !== subContext.trigger)
        context.onOpenChange(false);
    }),
    onEscapeKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onEscapeKeyDown, (event) => {
      rootContext.onClose();
      event.preventDefault();
    }),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      const isKeyDownInside = event.currentTarget.contains(event.target);
      const isCloseKey = $6cc32821e9371a1c$var$SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
      if (isKeyDownInside && isCloseKey) {
        var _subContext$trigger;
        context.onOpenChange(false);
        (_subContext$trigger = subContext.trigger) === null || _subContext$trigger === void 0 || _subContext$trigger.focus();
        event.preventDefault();
      }
    })
  })))));
});
function $6cc32821e9371a1c$var$getOpenState(open) {
  return open ? "open" : "closed";
}
function $6cc32821e9371a1c$var$isIndeterminate(checked) {
  return checked === "indeterminate";
}
function $6cc32821e9371a1c$var$getCheckedState(checked) {
  return $6cc32821e9371a1c$var$isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function $6cc32821e9371a1c$var$focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function $6cc32821e9371a1c$var$wrapArray(array, startIndex) {
  return array.map(
    (_3, index2) => array[(startIndex + index2) % array.length]
  );
}
function $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every(
    (char) => char === search[0]
  );
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = $6cc32821e9371a1c$var$wrapArray(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter(
      (v6) => v6 !== currentMatch
    );
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function $6cc32821e9371a1c$var$isPointInPolygon(point, polygon) {
  const { x: x5, y: y6 } = point;
  let inside = false;
  for (let i4 = 0, j4 = polygon.length - 1; i4 < polygon.length; j4 = i4++) {
    const xi = polygon[i4].x;
    const yi = polygon[i4].y;
    const xj = polygon[j4].x;
    const yj = polygon[j4].y;
    const intersect = yi > y6 !== yj > y6 && x5 < (xj - xi) * (y6 - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function $6cc32821e9371a1c$var$isPointerInGraceArea(event, area) {
  if (!area)
    return false;
  const cursorPos = {
    x: event.clientX,
    y: event.clientY
  };
  return $6cc32821e9371a1c$var$isPointInPolygon(cursorPos, area);
}
function $6cc32821e9371a1c$var$whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var $6cc32821e9371a1c$export$be92b6f5f03c0fe9 = $6cc32821e9371a1c$export$d9b273488cd8ce6f;
var $6cc32821e9371a1c$export$b688253958b8dfe7 = $6cc32821e9371a1c$export$9fa5ebd18bee4d43;
var $6cc32821e9371a1c$export$602eac185826482c = $6cc32821e9371a1c$export$793392f970497feb;
var $6cc32821e9371a1c$export$7c6e2c02157bb7d2 = $6cc32821e9371a1c$export$479f0f2f71193efe;
var $6cc32821e9371a1c$export$6d08773d2e66f8f2 = $6cc32821e9371a1c$export$2ce376c2cc3355c8;
var $6cc32821e9371a1c$export$16ce288f89fa631c = $6cc32821e9371a1c$export$f6f243521332502d;
var $6cc32821e9371a1c$export$a98f0dcb43a68a25 = $6cc32821e9371a1c$export$ea2200c9eee416b3;
var $6cc32821e9371a1c$export$371ab307eab489c0 = $6cc32821e9371a1c$export$69bd225e9817f6d0;
var $6cc32821e9371a1c$export$c3468e2714d175fa = $6cc32821e9371a1c$export$a2593e23056970a3;
var $6cc32821e9371a1c$export$1ff3c3f08ae963c0 = $6cc32821e9371a1c$export$1cec7dcdd713e220;
var $6cc32821e9371a1c$export$21b07c8f274aebd5 = $6cc32821e9371a1c$export$bcdda4773debf5fa;
var $6cc32821e9371a1c$export$d7a01e11500dfb6f = $6cc32821e9371a1c$export$71bdb9d1e2909932;
var $6cc32821e9371a1c$export$2ea8a7a591ac5eac = $6cc32821e9371a1c$export$5fbbb3ba7297405f;
var $6cc32821e9371a1c$export$6d4de93b380beddf = $6cc32821e9371a1c$export$e7142ab31822bde6;

// node_modules/.pnpm/@radix-ui+react-context-menu@2.1.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-context-menu/dist/index.mjs
var $1b0217ee4a91d156$var$CONTEXT_MENU_NAME = "ContextMenu";
var [$1b0217ee4a91d156$var$createContextMenuContext, $1b0217ee4a91d156$export$1059331f43ddcc82] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($1b0217ee4a91d156$var$CONTEXT_MENU_NAME, [
  $6cc32821e9371a1c$export$4027731b685e72eb
]);
var $1b0217ee4a91d156$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb();
var [$1b0217ee4a91d156$var$ContextMenuProvider, $1b0217ee4a91d156$var$useContextMenuContext] = $1b0217ee4a91d156$var$createContextMenuContext($1b0217ee4a91d156$var$CONTEXT_MENU_NAME);
var $1b0217ee4a91d156$export$8dc6765e8be191c7 = (props) => {
  const { __scopeContextMenu, children, onOpenChange, dir, modal = true } = props;
  const [open1, setOpen] = (0, import_react29.useState)(false);
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  const handleOpenChangeProp = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);
  const handleOpenChange = (0, import_react29.useCallback)((open) => {
    setOpen(open);
    handleOpenChangeProp(open);
  }, [
    handleOpenChangeProp
  ]);
  return /* @__PURE__ */ (0, import_react29.createElement)($1b0217ee4a91d156$var$ContextMenuProvider, {
    scope: __scopeContextMenu,
    open: open1,
    onOpenChange: handleOpenChange,
    modal
  }, /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$be92b6f5f03c0fe9, _extends({}, menuScope, {
    dir,
    open: open1,
    onOpenChange: handleOpenChange,
    modal
  }), children));
};
var $1b0217ee4a91d156$var$TRIGGER_NAME = "ContextMenuTrigger";
var $1b0217ee4a91d156$export$be6fc7b1d5b0beb9 = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {
  const { __scopeContextMenu, disabled = false, ...triggerProps } = props;
  const context = $1b0217ee4a91d156$var$useContextMenuContext($1b0217ee4a91d156$var$TRIGGER_NAME, __scopeContextMenu);
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  const pointRef = (0, import_react29.useRef)({
    x: 0,
    y: 0
  });
  const virtualRef = (0, import_react29.useRef)({
    getBoundingClientRect: () => DOMRect.fromRect({
      width: 0,
      height: 0,
      ...pointRef.current
    })
  });
  const longPressTimerRef = (0, import_react29.useRef)(0);
  const clearLongPress = (0, import_react29.useCallback)(
    () => window.clearTimeout(longPressTimerRef.current),
    []
  );
  const handleOpen = (event) => {
    pointRef.current = {
      x: event.clientX,
      y: event.clientY
    };
    context.onOpenChange(true);
  };
  (0, import_react29.useEffect)(
    () => clearLongPress,
    [
      clearLongPress
    ]
  );
  (0, import_react29.useEffect)(
    () => void (disabled && clearLongPress()),
    [
      disabled,
      clearLongPress
    ]
  );
  return /* @__PURE__ */ (0, import_react29.createElement)(import_react29.Fragment, null, /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$b688253958b8dfe7, _extends({}, menuScope, {
    virtualRef
  })), /* @__PURE__ */ (0, import_react29.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
    "data-state": context.open ? "open" : "closed",
    "data-disabled": disabled ? "" : void 0
  }, triggerProps, {
    ref: forwardedRef,
    style: {
      WebkitTouchCallout: "none",
      ...props.style
    },
    onContextMenu: disabled ? props.onContextMenu : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onContextMenu, (event) => {
      clearLongPress();
      handleOpen(event);
      event.preventDefault();
    }),
    onPointerDown: disabled ? props.onPointerDown : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, $1b0217ee4a91d156$var$whenTouchOrPen((event) => {
      clearLongPress();
      longPressTimerRef.current = window.setTimeout(
        () => handleOpen(event),
        700
      );
    })),
    onPointerMove: disabled ? props.onPointerMove : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress)),
    onPointerCancel: disabled ? props.onPointerCancel : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerCancel, $1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress)),
    onPointerUp: disabled ? props.onPointerUp : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, $1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress))
  })));
});
var $1b0217ee4a91d156$export$14afd0be83e45060 = (props) => {
  const { __scopeContextMenu, ...portalProps } = props;
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$602eac185826482c, _extends({}, menuScope, portalProps));
};
var $1b0217ee4a91d156$var$CONTENT_NAME = "ContextMenuContent";
var $1b0217ee4a91d156$export$572205900c9369e = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {
  const { __scopeContextMenu, ...contentProps } = props;
  const context = $1b0217ee4a91d156$var$useContextMenuContext($1b0217ee4a91d156$var$CONTENT_NAME, __scopeContextMenu);
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  const hasInteractedOutsideRef = (0, import_react29.useRef)(false);
  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$7c6e2c02157bb7d2, _extends({}, menuScope, contentProps, {
    ref: forwardedRef,
    side: "right",
    sideOffset: 2,
    align: "start",
    onCloseAutoFocus: (event) => {
      var _props$onCloseAutoFoc;
      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
      if (!event.defaultPrevented && hasInteractedOutsideRef.current)
        event.preventDefault();
      hasInteractedOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      var _props$onInteractOuts;
      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
      if (!event.defaultPrevented && !context.modal)
        hasInteractedOutsideRef.current = true;
    },
    style: {
      ...props.style,
      "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
});
var $1b0217ee4a91d156$export$16a26dc176a49100 = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {
  const { __scopeContextMenu, ...itemProps } = props;
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$6d08773d2e66f8f2, _extends({}, menuScope, itemProps, {
    ref: forwardedRef
  }));
});
var $1b0217ee4a91d156$export$f47d0a58228a61e2 = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {
  const { __scopeContextMenu, ...arrowProps } = props;
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$21b07c8f274aebd5, _extends({}, menuScope, arrowProps, {
    ref: forwardedRef
  }));
});
var $1b0217ee4a91d156$export$5bc21d1c00c4b201 = (props) => {
  const { __scopeContextMenu, children, onOpenChange, open: openProp, defaultOpen } = props;
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  const [open, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$d7a01e11500dfb6f, _extends({}, menuScope, {
    open,
    onOpenChange: setOpen
  }), children);
};
var $1b0217ee4a91d156$export$30b2b5c64556d316 = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {
  const { __scopeContextMenu, ...triggerItemProps } = props;
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$2ea8a7a591ac5eac, _extends({}, menuScope, triggerItemProps, {
    ref: forwardedRef
  }));
});
var $1b0217ee4a91d156$export$2c967063bd2dc512 = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {
  const { __scopeContextMenu, ...subContentProps } = props;
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$6d4de93b380beddf, _extends({}, menuScope, subContentProps, {
    ref: forwardedRef,
    style: {
      ...props.style,
      "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
});
function $1b0217ee4a91d156$var$whenTouchOrPen(handler) {
  return (event) => event.pointerType !== "mouse" ? handler(event) : void 0;
}
var $1b0217ee4a91d156$export$be92b6f5f03c0fe9 = $1b0217ee4a91d156$export$8dc6765e8be191c7;
var $1b0217ee4a91d156$export$41fb9f06171c75f4 = $1b0217ee4a91d156$export$be6fc7b1d5b0beb9;
var $1b0217ee4a91d156$export$602eac185826482c = $1b0217ee4a91d156$export$14afd0be83e45060;
var $1b0217ee4a91d156$export$7c6e2c02157bb7d2 = $1b0217ee4a91d156$export$572205900c9369e;
var $1b0217ee4a91d156$export$d7a01e11500dfb6f = $1b0217ee4a91d156$export$5bc21d1c00c4b201;
var $1b0217ee4a91d156$export$2ea8a7a591ac5eac = $1b0217ee4a91d156$export$30b2b5c64556d316;
var $1b0217ee4a91d156$export$6d4de93b380beddf = $1b0217ee4a91d156$export$2c967063bd2dc512;

// node_modules/.pnpm/@radix-ui+react-icons@1.3.0_react@18.2.0/node_modules/@radix-ui/react-icons/dist/react-icons.esm.js
var import_react30 = require("react");
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i4;
  for (i4 = 0; i4 < sourceKeys.length; i4++) {
    key = sourceKeys[i4];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded$3 = ["color"];
var AlignBottomIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M9 3C9 2.44772 8.55229 2 8 2H7C6.44772 2 6 2.44772 6 3L6 14H1.5C1.22386 14 1 14.2239 1 14.5C1 14.7761 1.22386 15 1.5 15L6 15H9H13.5C13.7761 15 14 14.7761 14 14.5C14 14.2239 13.7761 14 13.5 14H9V3Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4 = ["color"];
var AlignCenterHorizontallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M1.99988 6C1.44759 6 0.999877 6.44772 0.999877 7L0.999877 8C0.999877 8.55228 1.44759 9 1.99988 9L6.99988 9L6.99988 13.5C6.99988 13.7761 7.22374 14 7.49988 14C7.77602 14 7.99988 13.7761 7.99988 13.5L7.99988 9L12.9999 9C13.5522 9 13.9999 8.55228 13.9999 8L13.9999 7C13.9999 6.44772 13.5522 6 12.9999 6L7.99988 6L7.99988 1.5C7.99988 1.22386 7.77602 1 7.49988 1C7.22373 1 6.99988 1.22386 6.99988 1.5L6.99988 6L1.99988 6Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$5 = ["color"];
var AlignCenterVerticallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$5);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M6.99988 1C6.44759 1 5.99988 1.44772 5.99988 2V7H1.49988C1.22374 7 0.999878 7.22386 0.999878 7.5C0.999878 7.77614 1.22374 8 1.49988 8H5.99988V13C5.99988 13.5523 6.44759 14 6.99988 14H7.99988C8.55216 14 8.99988 13.5523 8.99988 13V8H13.4999C13.776 8 13.9999 7.77614 13.9999 7.5C13.9999 7.22386 13.776 7 13.4999 7H8.99988V2C8.99988 1.44772 8.55216 1 7.99988 1L6.99988 1Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$6 = ["color"];
var AlignLeftIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$6);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M0.499995 0.999995C0.223855 0.999995 -5.58458e-07 1.22385 -5.46388e-07 1.49999L-2.18554e-08 13.4999C-9.78492e-09 13.776 0.223855 13.9999 0.499995 13.9999C0.776136 13.9999 0.999991 13.776 0.999991 13.4999L0.999991 8.99993L12 8.99993C12.5523 8.99993 13 8.55222 13 7.99993L13 6.99994C13 6.44766 12.5523 5.99995 12 5.99995L0.999991 5.99995L0.999991 1.49999C0.999991 1.22385 0.776135 0.999995 0.499995 0.999995Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$7 = ["color"];
var AlignRightIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$7);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M14.4999 1C14.2237 1 13.9999 1.22386 13.9999 1.5L13.9999 6L2.99988 6C2.44759 6 1.99988 6.44772 1.99988 7L1.99988 8C1.99988 8.55228 2.44759 9 2.99988 9L13.9999 9L13.9999 13.5C13.9999 13.7761 14.2237 14 14.4999 14C14.776 14 14.9999 13.7761 14.9999 13.5L14.9999 9L14.9999 6L14.9999 1.5C14.9999 1.22386 14.776 1 14.4999 1Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$8 = ["color"];
var AlignTopIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$8);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M1.5 0C1.22386 0 1 0.223858 1 0.5C1 0.776142 1.22386 1 1.5 1H6V12C6 12.5523 6.44772 13 7 13H8C8.55228 13 9 12.5523 9 12V1H13.5C13.7761 1 14 0.776142 14 0.5C14 0.223858 13.7761 0 13.5 0H9H6H1.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$a = ["color"];
var AngleIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$a);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M8.8914 2.1937C9.1158 2.35464 9.16725 2.66701 9.00631 2.89141L2.47388 12H13.5C13.7761 12 14 12.2239 14 12.5C14 12.7762 13.7761 13 13.5 13H1.5C1.31254 13 1.14082 12.8952 1.0552 12.7284C0.969578 12.5616 0.984438 12.361 1.09369 12.2086L8.19369 2.30862C8.35462 2.08422 8.667 2.03277 8.8914 2.1937ZM11.1 6.50001C11.1 6.22387 11.3238 6.00001 11.6 6.00001C11.8761 6.00001 12.1 6.22387 12.1 6.50001C12.1 6.77615 11.8761 7.00001 11.6 7.00001C11.3238 7.00001 11.1 6.77615 11.1 6.50001ZM10.4 4.00001C10.1239 4.00001 9.90003 4.22387 9.90003 4.50001C9.90003 4.77615 10.1239 5.00001 10.4 5.00001C10.6762 5.00001 10.9 4.77615 10.9 4.50001C10.9 4.22387 10.6762 4.00001 10.4 4.00001ZM12.1 8.50001C12.1 8.22387 12.3238 8.00001 12.6 8.00001C12.8761 8.00001 13.1 8.22387 13.1 8.50001C13.1 8.77615 12.8761 9.00001 12.6 9.00001C12.3238 9.00001 12.1 8.77615 12.1 8.50001ZM13.4 10C13.1239 10 12.9 10.2239 12.9 10.5C12.9 10.7761 13.1239 11 13.4 11C13.6762 11 13.9 10.7761 13.9 10.5C13.9 10.2239 13.6762 10 13.4 10Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$e = ["color"];
var ArrowDownIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$e);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M7.5 2C7.77614 2 8 2.22386 8 2.5L8 11.2929L11.1464 8.14645C11.3417 7.95118 11.6583 7.95118 11.8536 8.14645C12.0488 8.34171 12.0488 8.65829 11.8536 8.85355L7.85355 12.8536C7.75979 12.9473 7.63261 13 7.5 13C7.36739 13 7.24021 12.9473 7.14645 12.8536L3.14645 8.85355C2.95118 8.65829 2.95118 8.34171 3.14645 8.14645C3.34171 7.95118 3.65829 7.95118 3.85355 8.14645L7 11.2929L7 2.5C7 2.22386 7.22386 2 7.5 2Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$i = ["color"];
var ArrowTopRightIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$i);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L10.2929 4L6 4C5.72386 4 5.5 3.77614 5.5 3.5C5.5 3.22386 5.72386 3 6 3L11.5 3C11.6326 3 11.7598 3.05268 11.8536 3.14645C11.9473 3.24022 12 3.36739 12 3.5L12 9.00001C12 9.27615 11.7761 9.50001 11.5 9.50001C11.2239 9.50001 11 9.27615 11 9.00001V4.70711L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$j = ["color"];
var ArrowUpIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$j);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M7.14645 2.14645C7.34171 1.95118 7.65829 1.95118 7.85355 2.14645L11.8536 6.14645C12.0488 6.34171 12.0488 6.65829 11.8536 6.85355C11.6583 7.04882 11.3417 7.04882 11.1464 6.85355L8 3.70711L8 12.5C8 12.7761 7.77614 13 7.5 13C7.22386 13 7 12.7761 7 12.5L7 3.70711L3.85355 6.85355C3.65829 7.04882 3.34171 7.04882 3.14645 6.85355C2.95118 6.65829 2.95118 6.34171 3.14645 6.14645L7.14645 2.14645Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$k = ["color"];
var AspectRatioIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$k);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M2.5 2H12.5C12.7761 2 13 2.22386 13 2.5V12.5C13 12.7761 12.7761 13 12.5 13H2.5C2.22386 13 2 12.7761 2 12.5V2.5C2 2.22386 2.22386 2 2.5 2ZM1 2.5C1 1.67157 1.67157 1 2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5ZM7.5 4C7.77614 4 8 3.77614 8 3.5C8 3.22386 7.77614 3 7.5 3C7.22386 3 7 3.22386 7 3.5C7 3.77614 7.22386 4 7.5 4ZM8 5.5C8 5.77614 7.77614 6 7.5 6C7.22386 6 7 5.77614 7 5.5C7 5.22386 7.22386 5 7.5 5C7.77614 5 8 5.22386 8 5.5ZM7.5 8C7.77614 8 8 7.77614 8 7.5C8 7.22386 7.77614 7 7.5 7C7.22386 7 7 7.22386 7 7.5C7 7.77614 7.22386 8 7.5 8ZM10 7.5C10 7.77614 9.77614 8 9.5 8C9.22386 8 9 7.77614 9 7.5C9 7.22386 9.22386 7 9.5 7C9.77614 7 10 7.22386 10 7.5ZM11.5 8C11.7761 8 12 7.77614 12 7.5C12 7.22386 11.7761 7 11.5 7C11.2239 7 11 7.22386 11 7.5C11 7.77614 11.2239 8 11.5 8Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$F = ["color"];
var BoxIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$F);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M12.5 2H2.5C2.22386 2 2 2.22386 2 2.5V12.5C2 12.7761 2.22386 13 2.5 13H12.5C12.7761 13 13 12.7761 13 12.5V2.5C13 2.22386 12.7761 2 12.5 2ZM2.5 1C1.67157 1 1 1.67157 1 2.5V12.5C1 13.3284 1.67157 14 2.5 14H12.5C13.3284 14 14 13.3284 14 12.5V2.5C14 1.67157 13.3284 1 12.5 1H2.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$T = ["color"];
var CheckIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$T);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$Y = ["color"];
var ChevronRightIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$Y);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$_ = ["color"];
var CircleIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$_);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M0.877075 7.49991C0.877075 3.84222 3.84222 0.877075 7.49991 0.877075C11.1576 0.877075 14.1227 3.84222 14.1227 7.49991C14.1227 11.1576 11.1576 14.1227 7.49991 14.1227C3.84222 14.1227 0.877075 11.1576 0.877075 7.49991ZM7.49991 1.82708C4.36689 1.82708 1.82708 4.36689 1.82708 7.49991C1.82708 10.6329 4.36689 13.1727 7.49991 13.1727C10.6329 13.1727 13.1727 10.6329 13.1727 7.49991C13.1727 4.36689 10.6329 1.82708 7.49991 1.82708Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$1h = ["color"];
var CopyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$1h);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M1 9.50006C1 10.3285 1.67157 11.0001 2.5 11.0001H4L4 10.0001H2.5C2.22386 10.0001 2 9.7762 2 9.50006L2 2.50006C2 2.22392 2.22386 2.00006 2.5 2.00006L9.5 2.00006C9.77614 2.00006 10 2.22392 10 2.50006V4.00002H5.5C4.67158 4.00002 4 4.67159 4 5.50002V12.5C4 13.3284 4.67158 14 5.5 14H12.5C13.3284 14 14 13.3284 14 12.5V5.50002C14 4.67159 13.3284 4.00002 12.5 4.00002H11V2.50006C11 1.67163 10.3284 1.00006 9.5 1.00006H2.5C1.67157 1.00006 1 1.67163 1 2.50006V9.50006ZM5 5.50002C5 5.22388 5.22386 5.00002 5.5 5.00002H12.5C12.7761 5.00002 13 5.22388 13 5.50002V12.5C13 12.7762 12.7761 13 12.5 13H5.5C5.22386 13 5 12.7762 5 12.5V5.50002Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$1x = ["color"];
var CursorArrowIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$1x);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M3.29227 0.048984C3.47033 -0.032338 3.67946 -0.00228214 3.8274 0.125891L12.8587 7.95026C13.0134 8.08432 13.0708 8.29916 13.0035 8.49251C12.9362 8.68586 12.7578 8.81866 12.5533 8.82768L9.21887 8.97474L11.1504 13.2187C11.2648 13.47 11.1538 13.7664 10.9026 13.8808L8.75024 14.8613C8.499 14.9758 8.20255 14.8649 8.08802 14.6137L6.15339 10.3703L3.86279 12.7855C3.72196 12.934 3.50487 12.9817 3.31479 12.9059C3.1247 12.8301 3 12.6461 3 12.4414V0.503792C3 0.308048 3.11422 0.130306 3.29227 0.048984ZM4 1.59852V11.1877L5.93799 9.14425C6.05238 9.02363 6.21924 8.96776 6.38319 8.99516C6.54715 9.02256 6.68677 9.12965 6.75573 9.2809L8.79056 13.7441L10.0332 13.178L8.00195 8.71497C7.93313 8.56376 7.94391 8.38824 8.03072 8.24659C8.11753 8.10494 8.26903 8.01566 8.435 8.00834L11.2549 7.88397L4 1.59852Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$1I = ["color"];
var DotFilledIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$1I);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M9.875 7.5C9.875 8.81168 8.81168 9.875 7.5 9.875C6.18832 9.875 5.125 8.81168 5.125 7.5C5.125 6.18832 6.18832 5.125 7.5 5.125C8.81168 5.125 9.875 6.18832 9.875 7.5Z",
    fill: color
  }));
});
var _excluded$1J = ["color"];
var DotsHorizontalIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$1J);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M3.625 7.5C3.625 8.12132 3.12132 8.625 2.5 8.625C1.87868 8.625 1.375 8.12132 1.375 7.5C1.375 6.87868 1.87868 6.375 2.5 6.375C3.12132 6.375 3.625 6.87868 3.625 7.5ZM8.625 7.5C8.625 8.12132 8.12132 8.625 7.5 8.625C6.87868 8.625 6.375 8.12132 6.375 7.5C6.375 6.87868 6.87868 6.375 7.5 6.375C8.12132 6.375 8.625 6.87868 8.625 7.5ZM12.5 8.625C13.1213 8.625 13.625 8.12132 13.625 7.5C13.625 6.87868 13.1213 6.375 12.5 6.375C11.8787 6.375 11.375 6.87868 11.375 7.5C11.375 8.12132 11.8787 8.625 12.5 8.625Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$2p = ["color"];
var GroupIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$2p);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M1.44995 0.949951C1.31734 0.949951 1.19016 1.00263 1.0964 1.0964C1.00263 1.19017 0.949951 1.31735 0.949951 1.44995L0.949966 3.44995C0.949969 3.7261 1.17383 3.94995 1.44997 3.94995C1.72611 3.94995 1.94997 3.72609 1.94997 3.44995L1.94995 1.94995H3.44997C3.72611 1.94995 3.94997 1.72609 3.94997 1.44995C3.94997 1.17381 3.72611 0.949951 3.44997 0.949951H1.44995ZM5.94995 0.949951C5.67381 0.949951 5.44995 1.17381 5.44995 1.44995C5.44995 1.72609 5.67381 1.94995 5.94995 1.94995H8.94995C9.22609 1.94995 9.44995 1.72609 9.44995 1.44995C9.44995 1.17381 9.22609 0.949951 8.94995 0.949951H5.94995ZM5.44995 13.45C5.44995 13.1738 5.67381 12.95 5.94995 12.95H8.94995C9.22609 12.95 9.44995 13.1738 9.44995 13.45C9.44995 13.7261 9.22609 13.95 8.94995 13.95H5.94995C5.67381 13.95 5.44995 13.7261 5.44995 13.45ZM1.94995 5.94995C1.94995 5.67381 1.72609 5.44995 1.44995 5.44995C1.17381 5.44995 0.949951 5.67381 0.949951 5.94995V8.94995C0.949951 9.22609 1.17381 9.44995 1.44995 9.44995C1.72609 9.44995 1.94995 9.22609 1.94995 8.94995V5.94995ZM13.45 5.44995C13.7261 5.44995 13.95 5.67381 13.95 5.94995V8.94995C13.95 9.22609 13.7261 9.44995 13.45 9.44995C13.1738 9.44995 12.95 9.22609 12.95 8.94995V5.94995C12.95 5.67381 13.1738 5.44995 13.45 5.44995ZM11.45 0.949951C11.1738 0.949951 10.95 1.17381 10.95 1.44995C10.95 1.72609 11.1738 1.94995 11.45 1.94995H12.9499V3.44995C12.9499 3.72609 13.1738 3.94995 13.4499 3.94995C13.7261 3.94995 13.9499 3.72609 13.9499 3.44995V1.44995C13.9499 1.17381 13.7252 0.949951 13.449 0.949951H11.45ZM1.44995 10.95C1.72609 10.95 1.94995 11.1738 1.94995 11.45V12.95H3.44997C3.72611 12.95 3.94997 13.1738 3.94997 13.45C3.94997 13.7261 3.72611 13.95 3.44997 13.95H1.44995C1.17381 13.95 0.949951 13.7261 0.949951 13.45V11.45C0.949951 11.1738 1.17381 10.95 1.44995 10.95ZM13.95 11.45C13.95 11.1738 13.7261 10.95 13.45 10.95C13.1738 10.9499 12.95 11.1738 12.95 11.4499L12.9491 12.95H11.45C11.1738 12.95 10.95 13.1738 10.95 13.45C10.95 13.7261 11.1738 13.95 11.45 13.95H13.4499C13.7261 13.95 13.9499 13.7261 13.9499 13.45L13.95 11.45Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$2s = ["color"];
var HamburgerMenuIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$2s);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M1.5 3C1.22386 3 1 3.22386 1 3.5C1 3.77614 1.22386 4 1.5 4H13.5C13.7761 4 14 3.77614 14 3.5C14 3.22386 13.7761 3 13.5 3H1.5ZM1 7.5C1 7.22386 1.22386 7 1.5 7H13.5C13.7761 7 14 7.22386 14 7.5C14 7.77614 13.7761 8 13.5 8H1.5C1.22386 8 1 7.77614 1 7.5ZM1 11.5C1 11.2239 1.22386 11 1.5 11H13.5C13.7761 11 14 11.2239 14 11.5C14 11.7761 13.7761 12 13.5 12H1.5C1.22386 12 1 11.7761 1 11.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$2C = ["color"];
var ImageIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$2C);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5C1 1.67157 1.67157 1 2.5 1ZM2.5 2C2.22386 2 2 2.22386 2 2.5V8.3636L3.6818 6.6818C3.76809 6.59551 3.88572 6.54797 4.00774 6.55007C4.12975 6.55216 4.24568 6.60372 4.32895 6.69293L7.87355 10.4901L10.6818 7.6818C10.8575 7.50607 11.1425 7.50607 11.3182 7.6818L13 9.3636V2.5C13 2.22386 12.7761 2 12.5 2H2.5ZM2 12.5V9.6364L3.98887 7.64753L7.5311 11.4421L8.94113 13H2.5C2.22386 13 2 12.7761 2 12.5ZM12.5 13H10.155L8.48336 11.153L11 8.6364L13 10.6364V12.5C13 12.7761 12.7761 13 12.5 13ZM6.64922 5.5C6.64922 5.03013 7.03013 4.64922 7.5 4.64922C7.96987 4.64922 8.35078 5.03013 8.35078 5.5C8.35078 5.96987 7.96987 6.35078 7.5 6.35078C7.03013 6.35078 6.64922 5.96987 6.64922 5.5ZM7.5 3.74922C6.53307 3.74922 5.74922 4.53307 5.74922 5.5C5.74922 6.46693 6.53307 7.25078 7.5 7.25078C8.46693 7.25078 9.25078 6.46693 9.25078 5.5C9.25078 4.53307 8.46693 3.74922 7.5 3.74922Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$2_ = ["color"];
var LockClosedIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$2_);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M5 4.63601C5 3.76031 5.24219 3.1054 5.64323 2.67357C6.03934 2.24705 6.64582 1.9783 7.5014 1.9783C8.35745 1.9783 8.96306 2.24652 9.35823 2.67208C9.75838 3.10299 10 3.75708 10 4.63325V5.99999H5V4.63601ZM4 5.99999V4.63601C4 3.58148 4.29339 2.65754 4.91049 1.99307C5.53252 1.32329 6.42675 0.978302 7.5014 0.978302C8.57583 0.978302 9.46952 1.32233 10.091 1.99162C10.7076 2.65557 11 3.57896 11 4.63325V5.99999H12C12.5523 5.99999 13 6.44771 13 6.99999V13C13 13.5523 12.5523 14 12 14H3C2.44772 14 2 13.5523 2 13V6.99999C2 6.44771 2.44772 5.99999 3 5.99999H4ZM3 6.99999H12V13H3V6.99999Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$2$ = ["color"];
var LockOpen1Icon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$2$);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M7.4986 0C6.3257 0 5.36107 0.38943 4.73753 1.19361C4.23745 1.83856 4 2.68242 4 3.63325H5C5 2.84313 5.19691 2.23312 5.5278 1.80636C5.91615 1.30552 6.55152 1 7.4986 1C8.35683 1 8.96336 1.26502 9.35846 1.68623C9.75793 2.11211 10 2.76044 10 3.63601V6H3C2.44772 6 2 6.44772 2 7V13C2 13.5523 2.44772 14 3 14H12C12.5523 14 13 13.5523 13 13V7C13 6.44771 12.5523 6 12 6H11V3.63601C11 2.58135 10.7065 1.66167 10.0878 1.0021C9.46477 0.337871 8.57061 0 7.4986 0ZM3 7H12V13H3V7Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$3b = ["color"];
var MixerVerticalIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3b);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M5 1.5C5 1.22386 4.77614 1 4.5 1C4.22386 1 4 1.22386 4 1.5L4 7C4 7.01671 4.00082 7.03323 4.00242 7.04952C2.86009 7.28022 2 8.28967 2 9.5C2 10.7103 2.86009 11.7198 4.00242 11.9505C4.00082 11.9668 4 11.9833 4 12V13.5C4 13.7761 4.22386 14 4.5 14C4.77614 14 5 13.7761 5 13.5V12C5 11.9833 4.99918 11.9668 4.99758 11.9505C6.1399 11.7198 7 10.7103 7 9.5C7 8.28967 6.1399 7.28022 4.99758 7.04952C4.99918 7.03323 5 7.01671 5 7L5 1.5ZM11 1.5C11 1.22386 10.7761 1 10.5 1C10.2239 1 10 1.22386 10 1.5V3C10 3.01671 10.0008 3.03323 10.0024 3.04952C8.8601 3.28022 8 4.28967 8 5.5C8 6.71033 8.8601 7.71978 10.0024 7.95048C10.0008 7.96677 10 7.98329 10 8V13.5C10 13.7761 10.2239 14 10.5 14C10.7761 14 11 13.7761 11 13.5V8C11 7.98329 10.9992 7.96677 10.9976 7.95048C12.1399 7.71978 13 6.71033 13 5.5C13 4.28967 12.1399 3.28022 10.9976 3.04952C10.9992 3.03323 11 3.01671 11 3V1.5ZM4.5 8C3.67157 8 3 8.67157 3 9.5C3 10.3284 3.67157 11 4.5 11C5.32843 11 6 10.3284 6 9.5C6 8.67157 5.32843 8 4.5 8ZM9 5.5C9 4.67157 9.67157 4 10.5 4C11.3284 4 12 4.67157 12 5.5C12 6.32843 11.3284 7 10.5 7C9.67157 7 9 6.32843 9 5.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$3n = ["color"];
var Pencil1Icon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3n);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M11.8536 1.14645C11.6583 0.951184 11.3417 0.951184 11.1465 1.14645L3.71455 8.57836C3.62459 8.66832 3.55263 8.77461 3.50251 8.89155L2.04044 12.303C1.9599 12.491 2.00189 12.709 2.14646 12.8536C2.29103 12.9981 2.50905 13.0401 2.69697 12.9596L6.10847 11.4975C6.2254 11.4474 6.3317 11.3754 6.42166 11.2855L13.8536 3.85355C14.0488 3.65829 14.0488 3.34171 13.8536 3.14645L11.8536 1.14645ZM4.42166 9.28547L11.5 2.20711L12.7929 3.5L5.71455 10.5784L4.21924 11.2192L3.78081 10.7808L4.42166 9.28547Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$3o = ["color"];
var Pencil2Icon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3o);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M12.1464 1.14645C12.3417 0.951184 12.6583 0.951184 12.8535 1.14645L14.8535 3.14645C15.0488 3.34171 15.0488 3.65829 14.8535 3.85355L10.9109 7.79618C10.8349 7.87218 10.7471 7.93543 10.651 7.9835L6.72359 9.94721C6.53109 10.0435 6.29861 10.0057 6.14643 9.85355C5.99425 9.70137 5.95652 9.46889 6.05277 9.27639L8.01648 5.34897C8.06455 5.25283 8.1278 5.16507 8.2038 5.08907L12.1464 1.14645ZM12.5 2.20711L8.91091 5.79618L7.87266 7.87267L8.12731 8.12732L10.2038 7.08907L13.7929 3.5L12.5 2.20711ZM9.99998 2L8.99998 3H4.9C4.47171 3 4.18056 3.00039 3.95552 3.01877C3.73631 3.03668 3.62421 3.06915 3.54601 3.10899C3.35785 3.20487 3.20487 3.35785 3.10899 3.54601C3.06915 3.62421 3.03669 3.73631 3.01878 3.95552C3.00039 4.18056 3 4.47171 3 4.9V11.1C3 11.5283 3.00039 11.8194 3.01878 12.0445C3.03669 12.2637 3.06915 12.3758 3.10899 12.454C3.20487 12.6422 3.35785 12.7951 3.54601 12.891C3.62421 12.9309 3.73631 12.9633 3.95552 12.9812C4.18056 12.9996 4.47171 13 4.9 13H11.1C11.5283 13 11.8194 12.9996 12.0445 12.9812C12.2637 12.9633 12.3758 12.9309 12.454 12.891C12.6422 12.7951 12.7951 12.6422 12.891 12.454C12.9309 12.3758 12.9633 12.2637 12.9812 12.0445C12.9996 11.8194 13 11.5283 13 11.1V6.99998L14 5.99998V11.1V11.1207C14 11.5231 14 11.8553 13.9779 12.1259C13.9549 12.407 13.9057 12.6653 13.782 12.908C13.5903 13.2843 13.2843 13.5903 12.908 13.782C12.6653 13.9057 12.407 13.9549 12.1259 13.9779C11.8553 14 11.5231 14 11.1207 14H11.1H4.9H4.87934C4.47686 14 4.14468 14 3.87409 13.9779C3.59304 13.9549 3.33469 13.9057 3.09202 13.782C2.7157 13.5903 2.40973 13.2843 2.21799 12.908C2.09434 12.6653 2.04506 12.407 2.0221 12.1259C1.99999 11.8553 1.99999 11.5231 2 11.1207V11.1206V11.1V4.9V4.87935V4.87932V4.87931C1.99999 4.47685 1.99999 4.14468 2.0221 3.87409C2.04506 3.59304 2.09434 3.33469 2.21799 3.09202C2.40973 2.71569 2.7157 2.40973 3.09202 2.21799C3.33469 2.09434 3.59304 2.04506 3.87409 2.0221C4.14468 1.99999 4.47685 1.99999 4.87932 2H4.87935H4.9H9.99998Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$3s = ["color"];
var PinBottomIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3s);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M13.5 13.95C13.7485 13.95 13.95 13.7485 13.95 13.5C13.95 13.2514 13.7485 13.05 13.5 13.05L1.49995 13.05C1.25142 13.05 1.04995 13.2514 1.04995 13.5C1.04995 13.7485 1.25142 13.95 1.49995 13.95L13.5 13.95ZM11.0681 7.5683C11.2439 7.39257 11.2439 7.10764 11.0681 6.93191C10.8924 6.75617 10.6075 6.75617 10.4317 6.93191L7.94993 9.41371L7.94993 1.49998C7.94993 1.25146 7.74846 1.04998 7.49993 1.04998C7.2514 1.04998 7.04993 1.25146 7.04993 1.49998L7.04993 9.41371L4.56813 6.93191C4.39239 6.75617 4.10746 6.75617 3.93173 6.93191C3.75599 7.10764 3.75599 7.39257 3.93173 7.5683L7.18173 10.8183C7.35746 10.994 7.64239 10.994 7.81812 10.8183L11.0681 7.5683Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$3v = ["color"];
var PinTopIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3v);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M1.50005 1.05005C1.25152 1.05005 1.05005 1.25152 1.05005 1.50005C1.05005 1.74858 1.25152 1.95005 1.50005 1.95005L13.5 1.95005C13.7486 1.95005 13.95 1.74858 13.95 1.50005C13.95 1.25152 13.7486 1.05005 13.5 1.05005H1.50005ZM3.93188 7.43169C3.75614 7.60743 3.75614 7.89236 3.93188 8.06809C4.10761 8.24383 4.39254 8.24383 4.56827 8.06809L7.05007 5.58629V13.5C7.05007 13.7485 7.25155 13.95 7.50007 13.95C7.7486 13.95 7.95007 13.7485 7.95007 13.5L7.95007 5.58629L10.4319 8.06809C10.6076 8.24383 10.8925 8.24383 11.0683 8.06809C11.244 7.89235 11.244 7.60743 11.0683 7.43169L7.81827 4.18169C7.64254 4.00596 7.35761 4.00596 7.18188 4.18169L3.93188 7.43169Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$3x = ["color"];
var PlusIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3x);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M8 2.75C8 2.47386 7.77614 2.25 7.5 2.25C7.22386 2.25 7 2.47386 7 2.75V7H2.75C2.47386 7 2.25 7.22386 2.25 7.5C2.25 7.77614 2.47386 8 2.75 8H7V12.25C7 12.5261 7.22386 12.75 7.5 12.75C7.77614 12.75 8 12.5261 8 12.25V8H12.25C12.5261 8 12.75 7.77614 12.75 7.5C12.75 7.22386 12.5261 7 12.25 7H8V2.75Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$3I = ["color"];
var RotateCounterClockwiseIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3I);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M7.59664 2.93628C7.76085 3.06401 8.00012 2.94698 8.00012 2.73895V1.99998C9.98143 2 11.1848 2.3637 11.9105 3.08945C12.6363 3.81522 13 5.0186 13 6.99998C13 7.27613 13.2239 7.49998 13.5 7.49998C13.7761 7.49998 14 7.27613 14 6.99998C14 4.9438 13.6325 3.39719 12.6176 2.38234C11.6028 1.36752 10.0562 0.999999 8.00012 0.999984V0.261266C8.00012 0.0532293 7.76085 -0.0637944 7.59664 0.063928L6.00384 1.30277C5.87516 1.40286 5.87516 1.59735 6.00384 1.69744L7.59664 2.93628ZM9.5 5H2.5C2.22386 5 2 5.22386 2 5.5V12.5C2 12.7761 2.22386 13 2.5 13H9.5C9.77614 13 10 12.7761 10 12.5V5.5C10 5.22386 9.77614 5 9.5 5ZM2.5 4C1.67157 4 1 4.67157 1 5.5V12.5C1 13.3284 1.67157 14 2.5 14H9.5C10.3284 14 11 13.3284 11 12.5V5.5C11 4.67157 10.3284 4 9.5 4H2.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$42 = ["color"];
var SpaceEvenlyHorizontallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$42);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M14.4999 0.999992C14.2237 0.999992 13.9999 1.22385 13.9999 1.49999L13.9999 13.4999C13.9999 13.776 14.2237 13.9999 14.4999 13.9999C14.776 13.9999 14.9999 13.776 14.9999 13.4999L14.9999 1.49999C14.9999 1.22385 14.776 0.999992 14.4999 0.999992ZM0.499996 0.999992C0.223856 0.999992 -9.78509e-09 1.22385 -2.18556e-08 1.49999L4.07279e-07 13.4999C3.95208e-07 13.776 0.223855 13.9999 0.499996 13.9999C0.776136 13.9999 0.999992 13.776 0.999992 13.4999L0.999992 1.49999C0.999992 1.22385 0.776136 0.999992 0.499996 0.999992ZM1.99998 6.99994C1.99998 6.44766 2.44769 5.99995 2.99998 5.99995L5.99995 5.99995C6.55223 5.99995 6.99994 6.44766 6.99994 6.99994L6.99994 7.99993C6.99994 8.55221 6.55223 8.99992 5.99995 8.99992L2.99998 8.99992C2.4477 8.99992 1.99998 8.55221 1.99998 7.99993L1.99998 6.99994ZM8.99993 5.99995C8.44765 5.99995 7.99993 6.44766 7.99993 6.99994L7.99993 7.99993C7.99993 8.55221 8.44765 8.99992 8.99993 8.99992L11.9999 8.99992C12.5522 8.99992 12.9999 8.55221 12.9999 7.99993L12.9999 6.99994C12.9999 6.44766 12.5522 5.99995 11.9999 5.99995L8.99993 5.99995Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$43 = ["color"];
var SpaceEvenlyVerticallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$43);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M0.999878 0.5C0.999878 0.223858 1.22374 0 1.49988 0H13.4999C13.776 0 13.9999 0.223858 13.9999 0.5C13.9999 0.776142 13.776 1 13.4999 1H1.49988C1.22374 1 0.999878 0.776142 0.999878 0.5ZM7 2C6.44772 2 6 2.44772 6 3V6C6 6.55228 6.44772 7 7 7H8C8.55228 7 9 6.55228 9 6V3C9 2.44772 8.55228 2 8 2H7ZM7 8C6.44772 8 6 8.44771 6 9V12C6 12.5523 6.44772 13 7 13H8C8.55228 13 9 12.5523 9 12V9C9 8.44772 8.55228 8 8 8H7ZM1.49988 14C1.22374 14 0.999878 14.2239 0.999878 14.5C0.999878 14.7761 1.22374 15 1.49988 15H13.4999C13.776 15 13.9999 14.7761 13.9999 14.5C13.9999 14.2239 13.776 14 13.4999 14H1.49988Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$48 = ["color"];
var SquareIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$48);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M1 1H1.5H13.5H14V1.5V13.5V14H13.5H1.5H1V13.5V1.5V1ZM2 2V13H13V2H2Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4f = ["color"];
var StretchHorizontallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4f);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M14.4999 0.999992C14.2237 0.999992 13.9999 1.22385 13.9999 1.49999L13.9999 5.99995L0.999992 5.99995L0.999992 1.49999C0.999992 1.22385 0.776136 0.999992 0.499996 0.999992C0.223856 0.999992 -9.78509e-09 1.22385 -2.18556e-08 1.49999L4.07279e-07 13.4999C3.95208e-07 13.776 0.223855 13.9999 0.499996 13.9999C0.776136 13.9999 0.999992 13.776 0.999992 13.4999L0.999992 8.99992L13.9999 8.99992L13.9999 13.4999C13.9999 13.776 14.2237 13.9999 14.4999 13.9999C14.776 13.9999 14.9999 13.776 14.9999 13.4999L14.9999 1.49999C14.9999 1.22385 14.776 0.999992 14.4999 0.999992Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4g = ["color"];
var StretchVerticallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4g);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M0.999878 0.5C0.999878 0.223858 1.22374 0 1.49988 0H13.4999C13.776 0 13.9999 0.223858 13.9999 0.5C13.9999 0.776142 13.776 1 13.4999 1H6H1.49988C1.22374 1 0.999878 0.776142 0.999878 0.5ZM9 14V1L6 1V14H1.49988C1.22374 14 0.999878 14.2239 0.999878 14.5C0.999878 14.7761 1.22374 15 1.49988 15H13.4999C13.776 15 13.9999 14.7761 13.9999 14.5C13.9999 14.2239 13.776 14 13.4999 14H9Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4n = ["color"];
var TextIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4n);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M3.94993 2.95002L3.94993 4.49998C3.94993 4.74851 3.74845 4.94998 3.49993 4.94998C3.2514 4.94998 3.04993 4.74851 3.04993 4.49998V2.50004C3.04993 2.45246 3.05731 2.40661 3.07099 2.36357C3.12878 2.18175 3.29897 2.05002 3.49993 2.05002H11.4999C11.6553 2.05002 11.7922 2.12872 11.8731 2.24842C11.9216 2.32024 11.9499 2.40682 11.9499 2.50002L11.9499 2.50004V4.49998C11.9499 4.74851 11.7485 4.94998 11.4999 4.94998C11.2514 4.94998 11.0499 4.74851 11.0499 4.49998V2.95002H8.04993V12.05H9.25428C9.50281 12.05 9.70428 12.2515 9.70428 12.5C9.70428 12.7486 9.50281 12.95 9.25428 12.95H5.75428C5.50575 12.95 5.30428 12.7486 5.30428 12.5C5.30428 12.2515 5.50575 12.05 5.75428 12.05H6.94993V2.95002H3.94993Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4p = ["color"];
var TextAlignCenterIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4p);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM4 7.5C4 7.22386 4.22386 7 4.5 7H10.5C10.7761 7 11 7.22386 11 7.5C11 7.77614 10.7761 8 10.5 8H4.5C4.22386 8 4 7.77614 4 7.5ZM3 10.5C3 10.2239 3.22386 10 3.5 10H11.5C11.7761 10 12 10.2239 12 10.5C12 10.7761 11.7761 11 11.5 11H3.5C3.22386 11 3 10.7761 3 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4q = ["color"];
var TextAlignJustifyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4q);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M2.5 4C2.22386 4 2 4.22386 2 4.5C2 4.77614 2.22386 5 2.5 5H12.5C12.7761 5 13 4.77614 13 4.5C13 4.22386 12.7761 4 12.5 4H2.5ZM2 7.5C2 7.22386 2.22386 7 2.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H2.5C2.22386 8 2 7.77614 2 7.5ZM2 10.5C2 10.2239 2.22386 10 2.5 10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H2.5C2.22386 11 2 10.7761 2 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4r = ["color"];
var TextAlignLeftIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4r);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM2 7.5C2 7.22386 2.22386 7 2.5 7H7.5C7.77614 7 8 7.22386 8 7.5C8 7.77614 7.77614 8 7.5 8H2.5C2.22386 8 2 7.77614 2 7.5ZM2 10.5C2 10.2239 2.22386 10 2.5 10H10.5C10.7761 10 11 10.2239 11 10.5C11 10.7761 10.7761 11 10.5 11H2.5C2.22386 11 2 10.7761 2 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4t = ["color"];
var TextAlignRightIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4t);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM7 7.5C7 7.22386 7.22386 7 7.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H7.5C7.22386 8 7 7.77614 7 7.5ZM4 10.5C4 10.2239 4.22386 10 4.5 10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H4.5C4.22386 11 4 10.7761 4 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4R = ["color"];
var VercelLogoIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4R);
  return (0, import_react30.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react30.createElement)("path", {
    d: "M7.49998 1L6.92321 2.00307L1.17498 12L0.599976 13H1.7535H13.2464H14.4L13.825 12L8.07674 2.00307L7.49998 1ZM7.49998 3.00613L2.3285 12H12.6714L7.49998 3.00613Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});

// src/components/Tldraw/components/ContextMenu/ContextMenu.tsx
var React16 = __toESM(require("react"));

// src/components/Tldraw/translations/main.json
var main_default = {
  "style.menu.color": "Color",
  "style.menu.fill": "Fill",
  "style.menu.dash": "Dash",
  "style.menu.size": "Size",
  "style.menu.keep.open": "Keep Open",
  "style.menu.font": "Font",
  "style.menu.align": "Align",
  styles: "Styles",
  "zoom.in": "Zoom In",
  "zoom.out": "Zoom Out",
  to: "To",
  "menu.tools": "Tools",
  "menu.transform": "Transform",
  "menu.file": "File",
  "menu.edit": "Edit",
  "menu.view": "View",
  "menu.preferences": "Preferences",
  "menu.sign.in": "Sign In",
  "menu.sign.out": "Sign Out",
  "become.a.sponsor": "Become a Sponsor",
  "zoom.to.content": "Back to content",
  "zoom.to.selection": "Zoom to Selection",
  "zoom.to.fit": "Zoom to Fit",
  "zoom.to": "Zoom to",
  "preferences.dark.mode": "Dark Mode",
  "preferences.focus.mode": "Focus Mode",
  "preferences.debug.mode": "Debug Mode",
  "preferences.show.grid": "Show Grid",
  "preferences.use.cad.selection": "Use CAD Selection",
  "preferences.keep.stylemenu.open": "Keep Style Menu Open",
  "preferences.always.show.snaps": "Always Show Snaps",
  "preferences.rotate.handles": "Rotate Handles",
  "preferences.binding.handles": "Binding Handles",
  "preferences.clone.handles": "Clone Handles",
  undo: "Undo",
  redo: "Redo",
  cut: "Cut",
  copy: "Copy",
  paste: "Paste",
  "copy.as": "Copy As",
  "export.as": "Export As",
  "select.all": "Select All",
  "select.none": "Select None",
  delete: "Delete",
  "new.project": "New Project",
  open: "Open",
  save: "Save",
  "save.as": "Save As",
  "upload.media": "Upload Media",
  "create.page": "Create Page",
  "new.page": "New Page",
  "page.name": "Page Name",
  duplicate: "Duplicate",
  cancel: "Cancel",
  "copy.invite.link": "Copy Invite Link",
  "copy.readonly.link": "Copy ReadOnly Link",
  "create.multiplayer.project": "Create a Multiplayer Project",
  "copy.multiplayer.project": "Copy to Multiplayer Project",
  select: "Select",
  eraser: "Eraser",
  draw: "Draw",
  arrow: "Arrow",
  text: "Text",
  sticky: "Sticky",
  rectangle: "Rectangle",
  ellipse: "Ellipse",
  triangle: "Triangle",
  line: "Line",
  rotate: "Rotate",
  "lock.aspect.ratio": "Lock Aspect Ratio",
  "unlock.aspect.ratio": "Unlock Aspect Ratio",
  group: "Group",
  ungroup: "Ungroup",
  "move.to.back": "Move to Back",
  "move.backward": "Move Backward",
  "move.forward": "Move Forward",
  "move.to.front": "Move to Front",
  "reset.angle": "Reset Angle",
  lock: "Lock",
  unlock: "Unlock",
  "align.distribute": "Align / Distribute",
  "move.to.page": "Move to Page",
  "flip.horizontal": "Flip Horizontal",
  "flip.vertical": "Flip Vertical",
  move: "Move",
  "to.front": "To Front",
  forward: "Forward",
  backward: "Backward",
  back: "To Back",
  language: "Language",
  "translation.link": "Learn More",
  "dock.position": "Dock Position",
  bottom: "Bottom",
  left: "Left",
  right: "Right",
  top: "Top",
  page: "Page",
  "keyboard.shortcuts": "Keyboard shortcuts",
  search: "Search",
  loading: "Loading{dots}",
  "export.background": "Export Background",
  transparent: "Transparent",
  auto: "Auto",
  light: "Light",
  dark: "Dark",
  github: "Github",
  twitter: "Twitter",
  discord: "Discord",
  image: "Image",
  "align.left": "Align Left",
  "align.center.x": "Align Horizontal Center",
  "align.right": "Align Right",
  "align.top": "Align Top",
  "align.center.y": "Align Vertical Center",
  "align.bottom": "Align Bottom",
  "distribute.x": "Distribute Horizontal",
  "distribute.y": "Distribute Vertical",
  "stretch.x": "Stretch Horizontal",
  "stretch.y": "Stretch Vertical",
  "dialog.save.firsttime": "Do you want to save your current project?",
  "dialog.save.again": "Do you want to save changes to your current project?",
  "dialog.cancel": "Cancel",
  "dialog.no": "No",
  "dialog.yes": "Yes",
  "enter.file.name": "Enter file name"
};

// src/components/Tldraw/translations/FormattedMessage.tsx
var import_jsx_runtime = require("react/jsx-runtime");
function FormattedMessage({ id }) {
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: main_default[id] });
}
function useIntl() {
  return {
    formatMessage({ id }) {
      return main_default[id];
    }
  };
}

// node_modules/.pnpm/@stitches+react@1.2.8_react@18.2.0/node_modules/@stitches/react/dist/index.mjs
var import_react31 = __toESM(require("react"), 1);
var e3 = "colors";
var t3 = "sizes";
var r3 = "space";
var n3 = { gap: r3, gridGap: r3, columnGap: r3, gridColumnGap: r3, rowGap: r3, gridRowGap: r3, inset: r3, insetBlock: r3, insetBlockEnd: r3, insetBlockStart: r3, insetInline: r3, insetInlineEnd: r3, insetInlineStart: r3, margin: r3, marginTop: r3, marginRight: r3, marginBottom: r3, marginLeft: r3, marginBlock: r3, marginBlockEnd: r3, marginBlockStart: r3, marginInline: r3, marginInlineEnd: r3, marginInlineStart: r3, padding: r3, paddingTop: r3, paddingRight: r3, paddingBottom: r3, paddingLeft: r3, paddingBlock: r3, paddingBlockEnd: r3, paddingBlockStart: r3, paddingInline: r3, paddingInlineEnd: r3, paddingInlineStart: r3, top: r3, right: r3, bottom: r3, left: r3, scrollMargin: r3, scrollMarginTop: r3, scrollMarginRight: r3, scrollMarginBottom: r3, scrollMarginLeft: r3, scrollMarginX: r3, scrollMarginY: r3, scrollMarginBlock: r3, scrollMarginBlockEnd: r3, scrollMarginBlockStart: r3, scrollMarginInline: r3, scrollMarginInlineEnd: r3, scrollMarginInlineStart: r3, scrollPadding: r3, scrollPaddingTop: r3, scrollPaddingRight: r3, scrollPaddingBottom: r3, scrollPaddingLeft: r3, scrollPaddingX: r3, scrollPaddingY: r3, scrollPaddingBlock: r3, scrollPaddingBlockEnd: r3, scrollPaddingBlockStart: r3, scrollPaddingInline: r3, scrollPaddingInlineEnd: r3, scrollPaddingInlineStart: r3, fontSize: "fontSizes", background: e3, backgroundColor: e3, backgroundImage: e3, borderImage: e3, border: e3, borderBlock: e3, borderBlockEnd: e3, borderBlockStart: e3, borderBottom: e3, borderBottomColor: e3, borderColor: e3, borderInline: e3, borderInlineEnd: e3, borderInlineStart: e3, borderLeft: e3, borderLeftColor: e3, borderRight: e3, borderRightColor: e3, borderTop: e3, borderTopColor: e3, caretColor: e3, color: e3, columnRuleColor: e3, fill: e3, outline: e3, outlineColor: e3, stroke: e3, textDecorationColor: e3, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: t3, minBlockSize: t3, maxBlockSize: t3, inlineSize: t3, minInlineSize: t3, maxInlineSize: t3, width: t3, minWidth: t3, maxWidth: t3, height: t3, minHeight: t3, maxHeight: t3, flexBasis: t3, gridTemplateColumns: t3, gridTemplateRows: t3, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" };
var i3 = (e5, t5) => "function" == typeof t5 ? { "()": Function.prototype.toString.call(t5) } : t5;
var o3 = () => {
  const e5 = /* @__PURE__ */ Object.create(null);
  return (t5, r5, ...n5) => {
    const o5 = ((e6) => JSON.stringify(e6, i3))(t5);
    return o5 in e5 ? e5[o5] : e5[o5] = r5(t5, ...n5);
  };
};
var l5 = Symbol.for("sxs.internal");
var s3 = (e5, t5) => Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t5));
var a5 = (e5) => {
  for (const t5 in e5)
    return true;
  return false;
};
var { hasOwnProperty: c3 } = Object.prototype;
var d4 = (e5) => e5.includes("-") ? e5 : e5.replace(/[A-Z]/g, (e6) => "-" + e6.toLowerCase());
var g5 = /\s+(?![^()]*\))/;
var p4 = (e5) => (t5) => e5(..."string" == typeof t5 ? String(t5).split(g5) : [t5]);
var u3 = { appearance: (e5) => ({ WebkitAppearance: e5, appearance: e5 }), backfaceVisibility: (e5) => ({ WebkitBackfaceVisibility: e5, backfaceVisibility: e5 }), backdropFilter: (e5) => ({ WebkitBackdropFilter: e5, backdropFilter: e5 }), backgroundClip: (e5) => ({ WebkitBackgroundClip: e5, backgroundClip: e5 }), boxDecorationBreak: (e5) => ({ WebkitBoxDecorationBreak: e5, boxDecorationBreak: e5 }), clipPath: (e5) => ({ WebkitClipPath: e5, clipPath: e5 }), content: (e5) => ({ content: e5.includes('"') || e5.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e5) ? e5 : `"${e5}"` }), hyphens: (e5) => ({ WebkitHyphens: e5, hyphens: e5 }), maskImage: (e5) => ({ WebkitMaskImage: e5, maskImage: e5 }), maskSize: (e5) => ({ WebkitMaskSize: e5, maskSize: e5 }), tabSize: (e5) => ({ MozTabSize: e5, tabSize: e5 }), textSizeAdjust: (e5) => ({ WebkitTextSizeAdjust: e5, textSizeAdjust: e5 }), userSelect: (e5) => ({ WebkitUserSelect: e5, userSelect: e5 }), marginBlock: p4((e5, t5) => ({ marginBlockStart: e5, marginBlockEnd: t5 || e5 })), marginInline: p4((e5, t5) => ({ marginInlineStart: e5, marginInlineEnd: t5 || e5 })), maxSize: p4((e5, t5) => ({ maxBlockSize: e5, maxInlineSize: t5 || e5 })), minSize: p4((e5, t5) => ({ minBlockSize: e5, minInlineSize: t5 || e5 })), paddingBlock: p4((e5, t5) => ({ paddingBlockStart: e5, paddingBlockEnd: t5 || e5 })), paddingInline: p4((e5, t5) => ({ paddingInlineStart: e5, paddingInlineEnd: t5 || e5 })) };
var h4 = /([\d.]+)([^]*)/;
var f3 = (e5, t5) => e5.length ? e5.reduce((e6, r5) => (e6.push(...t5.map((e7) => e7.includes("&") ? e7.replace(/&/g, /[ +>|~]/.test(r5) && /&.*&/.test(e7) ? `:is(${r5})` : r5) : r5 + " " + e7)), e6), []) : t5;
var m4 = (e5, t5) => e5 in b4 && "string" == typeof t5 ? t5.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (t6, r5, n5, i4) => r5 + ("stretch" === n5 ? `-moz-available${i4};${d4(e5)}:${r5}-webkit-fill-available` : `-moz-fit-content${i4};${d4(e5)}:${r5}fit-content`) + i4) : String(t5);
var b4 = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 };
var S3 = (e5) => e5 ? e5 + "-" : "";
var k5 = (e5, t5, r5) => e5.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (e6, n5, i4, o5, l7) => "$" == o5 == !!i4 ? e6 : (n5 || "--" == o5 ? "calc(" : "") + "var(--" + ("$" === o5 ? S3(t5) + (l7.includes("$") ? "" : S3(r5)) + l7.replace(/\$/g, "-") : l7) + ")" + (n5 || "--" == o5 ? "*" + (n5 || "") + (i4 || "1") + ")" : ""));
var y4 = /\s*,\s*(?![^()]*\))/;
var B4 = Object.prototype.toString;
var $4 = (e5, t5, r5, n5, i4) => {
  let o5, l7, s5;
  const a7 = (e6, t6, r6) => {
    let c5, g6;
    const p6 = (e7) => {
      for (c5 in e7) {
        const R7 = 64 === c5.charCodeAt(0), z5 = R7 && Array.isArray(e7[c5]) ? e7[c5] : [e7[c5]];
        for (g6 of z5) {
          const e8 = /[A-Z]/.test($5 = c5) ? $5 : $5.replace(/-[^]/g, (e9) => e9[1].toUpperCase()), z6 = "object" == typeof g6 && g6 && g6.toString === B4 && (!n5.utils[e8] || !t6.length);
          if (e8 in n5.utils && !z6) {
            const t7 = n5.utils[e8];
            if (t7 !== l7) {
              l7 = t7, p6(t7(g6)), l7 = null;
              continue;
            }
          } else if (e8 in u3) {
            const t7 = u3[e8];
            if (t7 !== s5) {
              s5 = t7, p6(t7(g6)), s5 = null;
              continue;
            }
          }
          if (R7 && (b6 = c5.slice(1) in n5.media ? "@media " + n5.media[c5.slice(1)] : c5, c5 = b6.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (e9, t7, r7, n6, i5, o6) => {
            const l8 = h4.test(t7), s6 = 0.0625 * (l8 ? -1 : 1), [a8, c6] = l8 ? [n6, t7] : [t7, n6];
            return "(" + ("=" === r7[0] ? "" : ">" === r7[0] === l8 ? "max-" : "min-") + a8 + ":" + ("=" !== r7[0] && 1 === r7.length ? c6.replace(h4, (e10, t8, n7) => Number(t8) + s6 * (">" === r7 ? 1 : -1) + n7) : c6) + (i5 ? ") and (" + (">" === i5[0] ? "min-" : "max-") + a8 + ":" + (1 === i5.length ? o6.replace(h4, (e10, t8, r8) => Number(t8) + s6 * (">" === i5 ? -1 : 1) + r8) : o6) : "") + ")";
          })), z6) {
            const e9 = R7 ? r6.concat(c5) : [...r6], n6 = R7 ? [...t6] : f3(t6, c5.split(y4));
            void 0 !== o5 && i4(x4(...o5)), o5 = void 0, a7(g6, n6, e9);
          } else
            void 0 === o5 && (o5 = [[], t6, r6]), c5 = R7 || 36 !== c5.charCodeAt(0) ? c5 : `--${S3(n5.prefix)}${c5.slice(1).replace(/\$/g, "-")}`, g6 = z6 ? g6 : "number" == typeof g6 ? g6 && e8 in I2 ? String(g6) + "px" : String(g6) : k5(m4(e8, null == g6 ? "" : g6), n5.prefix, n5.themeMap[e8]), o5[0].push(`${R7 ? `${c5} ` : `${d4(c5)}:`}${g6}`);
        }
      }
      var b6, $5;
    };
    p6(e6), void 0 !== o5 && i4(x4(...o5)), o5 = void 0;
  };
  a7(e5, t5, r5);
};
var x4 = (e5, t5, r5) => `${r5.map((e6) => `${e6}{`).join("")}${t5.length ? `${t5.join(",")}{` : ""}${e5.join(";")}${t5.length ? "}" : ""}${Array(r5.length ? r5.length + 1 : 0).join("}")}`;
var I2 = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 };
var R6 = (e5) => String.fromCharCode(e5 + (e5 > 25 ? 39 : 97));
var z4 = (e5) => ((e6) => {
  let t5, r5 = "";
  for (t5 = Math.abs(e6); t5 > 52; t5 = t5 / 52 | 0)
    r5 = R6(t5 % 52) + r5;
  return R6(t5 % 52) + r5;
})(((e6, t5) => {
  let r5 = t5.length;
  for (; r5; )
    e6 = 33 * e6 ^ t5.charCodeAt(--r5);
  return e6;
})(5381, JSON.stringify(e5)) >>> 0);
var W4 = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"];
var j3 = (e5) => {
  if (e5.href && !e5.href.startsWith(location.origin))
    return false;
  try {
    return !!e5.cssRules;
  } catch (e6) {
    return false;
  }
};
var E4 = (e5) => {
  let t5;
  const r5 = () => {
    const { cssRules: e6 } = t5.sheet;
    return [].map.call(e6, (r6, n6) => {
      const { cssText: i4 } = r6;
      let o5 = "";
      if (i4.startsWith("--sxs"))
        return "";
      if (e6[n6 - 1] && (o5 = e6[n6 - 1].cssText).startsWith("--sxs")) {
        if (!r6.cssRules.length)
          return "";
        for (const e7 in t5.rules)
          if (t5.rules[e7].group === r6)
            return `--sxs{--sxs:${[...t5.rules[e7].cache].join(" ")}}${i4}`;
        return r6.cssRules.length ? `${o5}${i4}` : "";
      }
      return i4;
    }).join("");
  }, n5 = () => {
    if (t5) {
      const { rules: e6, sheet: r6 } = t5;
      if (!r6.deleteRule) {
        for (; 3 === Object(Object(r6.cssRules)[0]).type; )
          r6.cssRules.splice(0, 1);
        r6.cssRules = [];
      }
      for (const t6 in e6)
        delete e6[t6];
    }
    const i4 = Object(e5).styleSheets || [];
    for (const e6 of i4)
      if (j3(e6)) {
        for (let i5 = 0, o6 = e6.cssRules; o6[i5]; ++i5) {
          const l8 = Object(o6[i5]);
          if (1 !== l8.type)
            continue;
          const s5 = Object(o6[i5 + 1]);
          if (4 !== s5.type)
            continue;
          ++i5;
          const { cssText: a7 } = l8;
          if (!a7.startsWith("--sxs"))
            continue;
          const c5 = a7.slice(14, -3).trim().split(/\s+/), d6 = W4[c5[0]];
          d6 && (t5 || (t5 = { sheet: e6, reset: n5, rules: {}, toString: r5 }), t5.rules[d6] = { group: s5, index: i5, cache: new Set(c5) });
        }
        if (t5)
          break;
      }
    if (!t5) {
      const i5 = (e6, t6) => ({ type: t6, cssRules: [], insertRule(e7, t7) {
        this.cssRules.splice(t7, 0, i5(e7, { import: 3, undefined: 1 }[(e7.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
      }, get cssText() {
        return "@media{}" === e6 ? `@media{${[].map.call(this.cssRules, (e7) => e7.cssText).join("")}}` : e6;
      } });
      t5 = { sheet: e5 ? (e5.head || e5).appendChild(document.createElement("style")).sheet : i5("", "text/css"), rules: {}, reset: n5, toString: r5 };
    }
    const { sheet: o5, rules: l7 } = t5;
    for (let e6 = W4.length - 1; e6 >= 0; --e6) {
      const t6 = W4[e6];
      if (!l7[t6]) {
        const r6 = W4[e6 + 1], n6 = l7[r6] ? l7[r6].index : o5.cssRules.length;
        o5.insertRule("@media{}", n6), o5.insertRule(`--sxs{--sxs:${e6}}`, n6), l7[t6] = { group: o5.cssRules[n6 + 1], index: n6, cache: /* @__PURE__ */ new Set([e6]) };
      }
      v4(l7[t6]);
    }
  };
  return n5(), t5;
};
var v4 = (e5) => {
  const t5 = e5.group;
  let r5 = t5.cssRules.length;
  e5.apply = (e6) => {
    try {
      t5.insertRule(e6, r5), ++r5;
    } catch (e7) {
    }
  };
};
var T4 = Symbol();
var w5 = o3();
var M2 = (e5, t5) => w5(e5, () => (...r5) => {
  let n5 = { type: null, composers: /* @__PURE__ */ new Set() };
  for (const t6 of r5)
    if (null != t6)
      if (t6[l5]) {
        null == n5.type && (n5.type = t6[l5].type);
        for (const e6 of t6[l5].composers)
          n5.composers.add(e6);
      } else
        t6.constructor !== Object || t6.$$typeof ? null == n5.type && (n5.type = t6) : n5.composers.add(C5(t6, e5));
  return null == n5.type && (n5.type = "span"), n5.composers.size || n5.composers.add(["PJLV", {}, [], [], {}, []]), P3(e5, n5, t5);
});
var C5 = ({ variants: e5, compoundVariants: t5, defaultVariants: r5, ...n5 }, i4) => {
  const o5 = `${S3(i4.prefix)}c-${z4(n5)}`, l7 = [], s5 = [], d6 = /* @__PURE__ */ Object.create(null), g6 = [];
  for (const e6 in r5)
    d6[e6] = String(r5[e6]);
  if ("object" == typeof e5 && e5)
    for (const t6 in e5) {
      p6 = d6, u5 = t6, c3.call(p6, u5) || (d6[t6] = "undefined");
      const r6 = e5[t6];
      for (const e6 in r6) {
        const n6 = { [t6]: String(e6) };
        "undefined" === String(e6) && g6.push(t6);
        const i5 = r6[e6], o6 = [n6, i5, !a5(i5)];
        l7.push(o6);
      }
    }
  var p6, u5;
  if ("object" == typeof t5 && t5)
    for (const e6 of t5) {
      let { css: t6, ...r6 } = e6;
      t6 = "object" == typeof t6 && t6 || {};
      for (const e7 in r6)
        r6[e7] = String(r6[e7]);
      const n6 = [r6, t6, !a5(t6)];
      s5.push(n6);
    }
  return [o5, n5, l7, s5, d6, g6];
};
var P3 = (e5, t5, r5) => {
  const [n5, i4, o5, a7] = L4(t5.composers), c5 = "function" == typeof t5.type || t5.type.$$typeof ? ((e6) => {
    function t6() {
      for (let r6 = 0; r6 < t6[T4].length; r6++) {
        const [n6, i5] = t6[T4][r6];
        e6.rules[n6].apply(i5);
      }
      return t6[T4] = [], null;
    }
    return t6[T4] = [], t6.rules = {}, W4.forEach((e7) => t6.rules[e7] = { apply: (r6) => t6[T4].push([e7, r6]) }), t6;
  })(r5) : null, d6 = (c5 || r5).rules, g6 = `.${n5}${i4.length > 1 ? `:where(.${i4.slice(1).join(".")})` : ""}`, p6 = (l7) => {
    l7 = "object" == typeof l7 && l7 || A5;
    const { css: s5, ...p7 } = l7, u5 = {};
    for (const e6 in o5)
      if (delete p7[e6], e6 in l7) {
        let t6 = l7[e6];
        "object" == typeof t6 && t6 ? u5[e6] = { "@initial": o5[e6], ...t6 } : (t6 = String(t6), u5[e6] = "undefined" !== t6 || a7.has(e6) ? t6 : o5[e6]);
      } else
        u5[e6] = o5[e6];
    const h6 = /* @__PURE__ */ new Set([...i4]);
    for (const [n6, i5, o6, l8] of t5.composers) {
      r5.rules.styled.cache.has(n6) || (r5.rules.styled.cache.add(n6), $4(i5, [`.${n6}`], [], e5, (e6) => {
        d6.styled.apply(e6);
      }));
      const t6 = O5(o6, u5, e5.media), s6 = O5(l8, u5, e5.media, true);
      for (const i6 of t6)
        if (void 0 !== i6)
          for (const [t7, o7, l9] of i6) {
            const i7 = `${n6}-${z4(o7)}-${t7}`;
            h6.add(i7);
            const s7 = (l9 ? r5.rules.resonevar : r5.rules.onevar).cache, a8 = l9 ? d6.resonevar : d6.onevar;
            s7.has(i7) || (s7.add(i7), $4(o7, [`.${i7}`], [], e5, (e6) => {
              a8.apply(e6);
            }));
          }
      for (const t7 of s6)
        if (void 0 !== t7)
          for (const [i6, o7] of t7) {
            const t8 = `${n6}-${z4(o7)}-${i6}`;
            h6.add(t8), r5.rules.allvar.cache.has(t8) || (r5.rules.allvar.cache.add(t8), $4(o7, [`.${t8}`], [], e5, (e6) => {
              d6.allvar.apply(e6);
            }));
          }
    }
    if ("object" == typeof s5 && s5) {
      const t6 = `${n5}-i${z4(s5)}-css`;
      h6.add(t6), r5.rules.inline.cache.has(t6) || (r5.rules.inline.cache.add(t6), $4(s5, [`.${t6}`], [], e5, (e6) => {
        d6.inline.apply(e6);
      }));
    }
    for (const e6 of String(l7.className || "").trim().split(/\s+/))
      e6 && h6.add(e6);
    const f5 = p7.className = [...h6].join(" ");
    return { type: t5.type, className: f5, selector: g6, props: p7, toString: () => f5, deferredInjector: c5 };
  };
  return s3(p6, { className: n5, selector: g6, [l5]: t5, toString: () => (r5.rules.styled.cache.has(n5) || p6(), n5) });
};
var L4 = (e5) => {
  let t5 = "";
  const r5 = [], n5 = {}, i4 = [];
  for (const [o5, , , , l7, s5] of e5) {
    "" === t5 && (t5 = o5), r5.push(o5), i4.push(...s5);
    for (const e6 in l7) {
      const t6 = l7[e6];
      (void 0 === n5[e6] || "undefined" !== t6 || s5.includes(t6)) && (n5[e6] = t6);
    }
  }
  return [t5, r5, n5, new Set(i4)];
};
var O5 = (e5, t5, r5, n5) => {
  const i4 = [];
  e:
    for (let [o5, l7, s5] of e5) {
      if (s5)
        continue;
      let e6, a7 = 0, c5 = false;
      for (e6 in o5) {
        const n6 = o5[e6];
        let i5 = t5[e6];
        if (i5 !== n6) {
          if ("object" != typeof i5 || !i5)
            continue e;
          {
            let e7, t6, o6 = 0;
            for (const l8 in i5) {
              if (n6 === String(i5[l8])) {
                if ("@initial" !== l8) {
                  const e8 = l8.slice(1);
                  (t6 = t6 || []).push(e8 in r5 ? r5[e8] : l8.replace(/^@media ?/, "")), c5 = true;
                }
                a7 += o6, e7 = true;
              }
              ++o6;
            }
            if (t6 && t6.length && (l7 = { ["@media " + t6.join(", ")]: l7 }), !e7)
              continue e;
          }
        }
      }
      (i4[a7] = i4[a7] || []).push([n5 ? "cv" : `${e6}-${o5[e6]}`, l7, c5]);
    }
  return i4;
};
var A5 = {};
var N3 = o3();
var D5 = (e5, t5) => N3(e5, () => (...r5) => {
  const n5 = () => {
    for (let n6 of r5) {
      n6 = "object" == typeof n6 && n6 || {};
      let r6 = z4(n6);
      if (!t5.rules.global.cache.has(r6)) {
        if (t5.rules.global.cache.add(r6), "@import" in n6) {
          let e6 = [].indexOf.call(t5.sheet.cssRules, t5.rules.themed.group) - 1;
          for (let r7 of [].concat(n6["@import"]))
            r7 = r7.includes('"') || r7.includes("'") ? r7 : `"${r7}"`, t5.sheet.insertRule(`@import ${r7};`, e6++);
          delete n6["@import"];
        }
        $4(n6, [], [], e5, (e6) => {
          t5.rules.global.apply(e6);
        });
      }
    }
    return "";
  };
  return s3(n5, { toString: n5 });
});
var H4 = o3();
var V6 = (e5, t5) => H4(e5, () => (r5) => {
  const n5 = `${S3(e5.prefix)}k-${z4(r5)}`, i4 = () => {
    if (!t5.rules.global.cache.has(n5)) {
      t5.rules.global.cache.add(n5);
      const i5 = [];
      $4(r5, [], [], e5, (e6) => i5.push(e6));
      const o5 = `@keyframes ${n5}{${i5.join("")}}`;
      t5.rules.global.apply(o5);
    }
    return n5;
  };
  return s3(i4, { get name() {
    return i4();
  }, toString: i4 });
});
var G4 = class {
  constructor(e5, t5, r5, n5) {
    this.token = null == e5 ? "" : String(e5), this.value = null == t5 ? "" : String(t5), this.scale = null == r5 ? "" : String(r5), this.prefix = null == n5 ? "" : String(n5);
  }
  get computedValue() {
    return "var(" + this.variable + ")";
  }
  get variable() {
    return "--" + S3(this.prefix) + S3(this.scale) + this.token;
  }
  toString() {
    return this.computedValue;
  }
};
var F4 = o3();
var J2 = (e5, t5) => F4(e5, () => (r5, n5) => {
  n5 = "object" == typeof r5 && r5 || Object(n5);
  const i4 = `.${r5 = (r5 = "string" == typeof r5 ? r5 : "") || `${S3(e5.prefix)}t-${z4(n5)}`}`, o5 = {}, l7 = [];
  for (const t6 in n5) {
    o5[t6] = {};
    for (const r6 in n5[t6]) {
      const i5 = `--${S3(e5.prefix)}${t6}-${r6}`, s6 = k5(String(n5[t6][r6]), e5.prefix, t6);
      o5[t6][r6] = new G4(r6, s6, t6, e5.prefix), l7.push(`${i5}:${s6}`);
    }
  }
  const s5 = () => {
    if (l7.length && !t5.rules.themed.cache.has(r5)) {
      t5.rules.themed.cache.add(r5);
      const i5 = `${n5 === e5.theme ? ":root," : ""}.${r5}{${l7.join(";")}}`;
      t5.rules.themed.apply(i5);
    }
    return r5;
  };
  return { ...o5, get className() {
    return s5();
  }, selector: i4, toString: s5 };
});
var U3 = o3();
var X2;
var Y2 = o3();
var q3 = (e5) => {
  const t5 = ((e6) => {
    let t6 = false;
    const r5 = U3(e6, (e7) => {
      t6 = true;
      const r6 = "prefix" in (e7 = "object" == typeof e7 && e7 || {}) ? String(e7.prefix) : "", i4 = "object" == typeof e7.media && e7.media || {}, o5 = "object" == typeof e7.root ? e7.root || null : globalThis.document || null, l7 = "object" == typeof e7.theme && e7.theme || {}, s5 = { prefix: r6, media: i4, theme: l7, themeMap: "object" == typeof e7.themeMap && e7.themeMap || { ...n3 }, utils: "object" == typeof e7.utils && e7.utils || {} }, a7 = E4(o5), c5 = { css: M2(s5, a7), globalCss: D5(s5, a7), keyframes: V6(s5, a7), createTheme: J2(s5, a7), reset() {
        a7.reset(), c5.theme.toString();
      }, theme: {}, sheet: a7, config: s5, prefix: r6, getCssText: a7.toString, toString: a7.toString };
      return String(c5.theme = c5.createTheme(l7)), c5;
    });
    return t6 || r5.reset(), r5;
  })(e5);
  return t5.styled = (({ config: e6, sheet: t6 }) => Y2(e6, () => {
    const r5 = M2(e6, t6);
    return (...e7) => {
      const t7 = r5(...e7), n5 = t7[l5].type, i4 = import_react31.default.forwardRef((e8, r6) => {
        const i5 = e8 && e8.as || n5, { props: o5, deferredInjector: l7 } = t7(e8);
        return delete o5.as, o5.ref = r6, l7 ? import_react31.default.createElement(import_react31.default.Fragment, null, import_react31.default.createElement(i5, o5), import_react31.default.createElement(l7, null)) : import_react31.default.createElement(i5, o5);
      });
      return i4.className = t7.className, i4.displayName = `Styled.${n5.displayName || n5.name || n5}`, i4.selector = t7.selector, i4.toString = () => t7.selector, i4[l5] = t7[l5], i4;
    };
  }))(t5), t5;
};
var K4 = () => X2 || (X2 = q3());
var re2 = (...e5) => K4().styled(...e5);

// src/components/Tldraw/styles/stitches.config.ts
var { styled, createTheme } = q3({
  themeMap: {
    ...n3
  },
  theme: {
    colors: {
      bounds: "rgba(65, 132, 244, 1.000)",
      boundsBg: "rgba(65, 132, 244, 0.05)",
      hover: "#ececec",
      overlay: "rgba(0, 0, 0, 0.15)",
      overlayContrast: "rgba(255, 255, 255, 0.15)",
      panel: "#fefefe",
      panelContrast: "#ffffff",
      selected: "rgba(66, 133, 244, 1.000)",
      selectedContrast: "#fefefe",
      text: "#333333",
      tooltip: "#1d1d1d",
      tooltipContrast: "#ffffff",
      warn: "rgba(255, 100, 100, 1)",
      canvas: "rgb(248, 249, 250)"
    },
    shadows: {
      2: "0px 1px 1px rgba(0, 0, 0, 0.14)",
      3: "0px 2px 3px rgba(0, 0, 0, 0.14)",
      4: "0px 4px 5px -1px rgba(0, 0, 0, 0.14)",
      8: "0px 12px 17px rgba(0, 0, 0, 0.14)",
      12: "0px 12px 17px rgba(0, 0, 0, 0.14)",
      24: "0px 24px 38px rgba(0, 0, 0, 0.14)",
      key: "1px 1px rgba(0,0,0,1)",
      panel: `0px 0px 16px -1px rgba(0, 0, 0, 0.05), 
        0px 0px 16px -8px rgba(0, 0, 0, 0.05), 
        0px 0px 16px -12px rgba(0, 0, 0, 0.12),
        0px 0px 2px 0px rgba(0, 0, 0, 0.08)`
    },
    space: {
      0: "2px",
      1: "3px",
      2: "4px",
      3: "8px",
      4: "12px",
      5: "16px",
      6: "32px",
      7: "48px"
    },
    fontSizes: {
      0: "10px",
      1: "12px",
      2: "13px",
      3: "16px",
      4: "18px"
    },
    fonts: {
      ui: '"Recursive", system-ui, sans-serif',
      body: '"Recursive", system-ui, sans-serif',
      mono: '"Recursive Mono", monospace'
    },
    fontWeights: {},
    lineHeights: {},
    letterSpacings: {},
    sizes: {},
    borderWidths: {
      0: "$1"
    },
    borderStyles: {},
    radii: {
      0: "2px",
      1: "4px",
      2: "8px",
      3: "12px",
      4: "16px"
    },
    zIndices: {},
    transitions: {}
  },
  media: {
    micro: "(max-width: 370px)",
    sm: "(min-width: 640px)",
    md: "(min-width: 768px)",
    lg: "(min-width: 1024px)"
  },
  utils: {
    zStrokeWidth: () => (value) => {
      if (Array.isArray(value)) {
        return {
          strokeWidth: `calc(${value[0]}px / var(--camera-zoom))`
        };
      }
      return {
        strokeWidth: `calc(${value}px / var(--camera-zoom))`
      };
    }
  }
});

// src/components/Tldraw/components/Primitives/Divider/Divider.tsx
var Divider = styled("hr", {
  height: 0,
  paddingTop: 1,
  width: "calc(100%+8px)",
  backgroundColor: "$hover",
  border: "none",
  margin: "$2 -4px"
});

// src/components/Tldraw/components/Primitives/MenuContent/MenuContent.ts
var MenuContent = styled("div", {
  position: "relative",
  overflow: "hidden",
  userSelect: "none",
  display: "flex",
  flexDirection: "column",
  zIndex: 99997,
  minWidth: 180,
  pointerEvents: "all",
  backgroundColor: "$panel",
  border: "1px solid $panelContrast",
  boxShadow: "$panel",
  padding: "$2 $2",
  borderRadius: "$3",
  font: "$ui",
  maxHeight: "100vh",
  overflowY: "auto",
  overflowX: "hidden",
  "&::webkit-scrollbar": {
    display: "none"
  },
  "-ms-overflow-style": "none",
  scrollbarWidth: "none",
  variants: {
    size: {
      small: {
        minWidth: 72
      }
    },
    overflow: {
      true: {
        maxHeight: "60vh"
      }
    }
  }
});

// node_modules/.pnpm/@radix-ui+react-dropdown-menu@2.0.5_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs
var import_react33 = require("react");
var $d08ef79370b62062$var$DROPDOWN_MENU_NAME = "DropdownMenu";
var [$d08ef79370b62062$var$createDropdownMenuContext, $d08ef79370b62062$export$c0623cd925aeb687] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d08ef79370b62062$var$DROPDOWN_MENU_NAME, [
  $6cc32821e9371a1c$export$4027731b685e72eb
]);
var $d08ef79370b62062$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb();
var [$d08ef79370b62062$var$DropdownMenuProvider, $d08ef79370b62062$var$useDropdownMenuContext] = $d08ef79370b62062$var$createDropdownMenuContext($d08ef79370b62062$var$DROPDOWN_MENU_NAME);
var $d08ef79370b62062$export$e44a253a59704894 = (props) => {
  const { __scopeDropdownMenu, children, dir, open: openProp, defaultOpen, onOpenChange, modal = true } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  const triggerRef = (0, import_react33.useRef)(null);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_react33.createElement)($d08ef79370b62062$var$DropdownMenuProvider, {
    scope: __scopeDropdownMenu,
    triggerId: $1746a345f3d73bb7$export$f680877a34711e37(),
    triggerRef,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    open,
    onOpenChange: setOpen,
    onOpenToggle: (0, import_react33.useCallback)(
      () => setOpen(
        (prevOpen) => !prevOpen
      ),
      [
        setOpen
      ]
    ),
    modal
  }, /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$be92b6f5f03c0fe9, _extends({}, menuScope, {
    open,
    onOpenChange: setOpen,
    dir,
    modal
  }), children));
};
var $d08ef79370b62062$var$TRIGGER_NAME = "DropdownMenuTrigger";
var $d08ef79370b62062$export$d2469213b3befba9 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
  const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$TRIGGER_NAME, __scopeDropdownMenu);
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$b688253958b8dfe7, _extends({
    asChild: true
  }, menuScope), /* @__PURE__ */ (0, import_react33.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    id: context.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": context.open,
    "aria-controls": context.open ? context.contentId : void 0,
    "data-state": context.open ? "open" : "closed",
    "data-disabled": disabled ? "" : void 0,
    disabled
  }, triggerProps, {
    ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, context.triggerRef),
    onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, (event) => {
      if (!disabled && event.button === 0 && event.ctrlKey === false) {
        context.onOpenToggle();
        if (!context.open)
          event.preventDefault();
      }
    }),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      if (disabled)
        return;
      if ([
        "Enter",
        " "
      ].includes(event.key))
        context.onOpenToggle();
      if (event.key === "ArrowDown")
        context.onOpenChange(true);
      if ([
        "Enter",
        " ",
        "ArrowDown"
      ].includes(event.key))
        event.preventDefault();
    })
  })));
});
var $d08ef79370b62062$export$cd369b4d4d54efc9 = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$602eac185826482c, _extends({}, menuScope, portalProps));
};
var $d08ef79370b62062$var$CONTENT_NAME = "DropdownMenuContent";
var $d08ef79370b62062$export$6e76d93a37c01248 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...contentProps } = props;
  const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$CONTENT_NAME, __scopeDropdownMenu);
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  const hasInteractedOutsideRef = (0, import_react33.useRef)(false);
  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$7c6e2c02157bb7d2, _extends({
    id: context.contentId,
    "aria-labelledby": context.triggerId
  }, menuScope, contentProps, {
    ref: forwardedRef,
    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
      var _context$triggerRef$c;
      if (!hasInteractedOutsideRef.current)
        (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
      hasInteractedOutsideRef.current = false;
      event.preventDefault();
    }),
    onInteractOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onInteractOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      if (!context.modal || isRightClick)
        hasInteractedOutsideRef.current = true;
    }),
    style: {
      ...props.style,
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
});
var $d08ef79370b62062$export$ed97964d1871885d = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$6d08773d2e66f8f2, _extends({}, menuScope, itemProps, {
    ref: forwardedRef
  }));
});
var $d08ef79370b62062$export$53a69729da201fa9 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$16ce288f89fa631c, _extends({}, menuScope, checkboxItemProps, {
    ref: forwardedRef
  }));
});
var $d08ef79370b62062$export$3323ad73d55f587e = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$a98f0dcb43a68a25, _extends({}, menuScope, radioGroupProps, {
    ref: forwardedRef
  }));
});
var $d08ef79370b62062$export$e4f69b41b1637536 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$371ab307eab489c0, _extends({}, menuScope, radioItemProps, {
    ref: forwardedRef
  }));
});
var $d08ef79370b62062$export$42355ae145153fb6 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$c3468e2714d175fa, _extends({}, menuScope, itemIndicatorProps, {
    ref: forwardedRef
  }));
});
var $d08ef79370b62062$export$da160178fd3bc7e9 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$1ff3c3f08ae963c0, _extends({}, menuScope, separatorProps, {
    ref: forwardedRef
  }));
});
var $d08ef79370b62062$export$34b8980744021ec5 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...arrowProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$21b07c8f274aebd5, _extends({}, menuScope, arrowProps, {
    ref: forwardedRef
  }));
});
var $d08ef79370b62062$export$2f307d81a64f5442 = (props) => {
  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$d7a01e11500dfb6f, _extends({}, menuScope, {
    open,
    onOpenChange: setOpen
  }), children);
};
var $d08ef79370b62062$export$21dcb7ec56f874cf = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$2ea8a7a591ac5eac, _extends({}, menuScope, subTriggerProps, {
    ref: forwardedRef
  }));
});
var $d08ef79370b62062$export$f34ec8bc2482cc5f = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$6d4de93b380beddf, _extends({}, menuScope, subContentProps, {
    ref: forwardedRef,
    style: {
      ...props.style,
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
});
var $d08ef79370b62062$export$be92b6f5f03c0fe9 = $d08ef79370b62062$export$e44a253a59704894;
var $d08ef79370b62062$export$41fb9f06171c75f4 = $d08ef79370b62062$export$d2469213b3befba9;
var $d08ef79370b62062$export$602eac185826482c = $d08ef79370b62062$export$cd369b4d4d54efc9;
var $d08ef79370b62062$export$7c6e2c02157bb7d2 = $d08ef79370b62062$export$6e76d93a37c01248;
var $d08ef79370b62062$export$6d08773d2e66f8f2 = $d08ef79370b62062$export$ed97964d1871885d;
var $d08ef79370b62062$export$16ce288f89fa631c = $d08ef79370b62062$export$53a69729da201fa9;
var $d08ef79370b62062$export$a98f0dcb43a68a25 = $d08ef79370b62062$export$3323ad73d55f587e;
var $d08ef79370b62062$export$371ab307eab489c0 = $d08ef79370b62062$export$e4f69b41b1637536;
var $d08ef79370b62062$export$c3468e2714d175fa = $d08ef79370b62062$export$42355ae145153fb6;
var $d08ef79370b62062$export$1ff3c3f08ae963c0 = $d08ef79370b62062$export$da160178fd3bc7e9;
var $d08ef79370b62062$export$21b07c8f274aebd5 = $d08ef79370b62062$export$34b8980744021ec5;
var $d08ef79370b62062$export$d7a01e11500dfb6f = $d08ef79370b62062$export$2f307d81a64f5442;
var $d08ef79370b62062$export$2ea8a7a591ac5eac = $d08ef79370b62062$export$21dcb7ec56f874cf;
var $d08ef79370b62062$export$6d4de93b380beddf = $d08ef79370b62062$export$f34ec8bc2482cc5f;

// src/components/Tldraw/components/Primitives/RowButton/RowButton.tsx
var React9 = __toESM(require("react"));

// src/components/Tldraw/components/Primitives/Kbd/Kbd.tsx
var import_jsx_runtime2 = require("react/jsx-runtime");
var commandKey = () => C3.isDarwin() ? "\u2318" : "Ctrl";
function Kbd({ variant, children }) {
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(StyledKbd, { variant, children: children.split("").map((k7, index2) => {
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { children: k7.replace("#", commandKey()) }, index2);
  }) });
}
var StyledKbd = styled("kbd", {
  marginLeft: "$3",
  textShadow: "$2",
  textAlign: "center",
  fontSize: "$0",
  fontFamily: "$ui",
  color: "$text",
  background: "none",
  fontWeight: 400,
  gap: "$1",
  display: "flex",
  alignItems: "center",
  "& > span": {
    padding: "$0",
    borderRadius: "$0",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  variants: {
    variant: {
      tooltip: {
        "& > span": {
          color: "$tooltipContrast",
          background: "$overlayContrast",
          boxShadow: "$key",
          width: "20px",
          height: "20px"
        }
      },
      menu: {}
    }
  }
});

// src/components/Tldraw/components/Primitives/SmallIcon/SmallIcon.tsx
var SmallIcon = styled("div", {
  height: "100%",
  borderRadius: "4px",
  marginRight: "1px",
  width: "fit-content",
  display: "grid",
  alignItems: "center",
  justifyContent: "center",
  outline: "none",
  border: "none",
  pointerEvents: "all",
  cursor: "pointer",
  color: "currentColor",
  "& svg": {
    height: 16,
    width: 16,
    strokeWidth: 1
  },
  "& > *": {
    gridRow: 1,
    gridColumn: 1
  }
});

// src/components/Tldraw/components/breakpoints.tsx
var breakpoints = {
  "@initial": "mobile",
  "@micro": "micro",
  "@sm": "small",
  "@md": "medium",
  "@lg": "large"
};

// src/components/Tldraw/components/Primitives/RowButton/RowButton.tsx
var import_jsx_runtime3 = require("react/jsx-runtime");
var RowButton = React9.forwardRef(
  ({ onClick, isActive = false, isWarning = false, hasIndicator = false, hasArrow = false, disabled = false, variant, kbd, children, ...rest }, reference) => {
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      StyledRowButton,
      {
        ref: reference,
        bp: breakpoints,
        isWarning,
        isActive,
        disabled,
        onClick,
        variant,
        ...rest,
        children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(StyledRowButtonInner, { children: [
          children,
          kbd ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Kbd, { variant: "menu", children: kbd }) : void 0,
          hasIndicator && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)($d08ef79370b62062$export$c3468e2714d175fa, { dir: "ltr", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(SmallIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(CheckIcon, {}) }) }),
          hasArrow && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(SmallIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(ChevronRightIcon, {}) })
        ] })
      }
    );
  }
);
var StyledRowButtonInner = styled("div", {
  height: "100%",
  width: "100%",
  backgroundColor: "$panel",
  borderRadius: "$2",
  display: "flex",
  gap: "$1",
  flexDirection: "row",
  alignItems: "center",
  padding: "0 $3",
  justifyContent: "space-between",
  border: "1px solid transparent",
  "& svg": {
    position: "relative",
    stroke: "$overlay",
    strokeWidth: 1,
    zIndex: 1
  },
  [`& > ${SmallIcon}`]: {
    paddingLeft: "$3"
  }
});
var StyledRowButton = styled("button", {
  position: "relative",
  width: "100%",
  background: "none",
  border: "none",
  cursor: "pointer",
  height: 32,
  minHeight: 32,
  outline: "none",
  color: "$text",
  fontFamily: "$ui",
  fontWeight: 400,
  fontSize: "$1",
  borderRadius: 4,
  userSelect: "none",
  margin: 0,
  padding: "0 0",
  "&[data-disabled]": {
    opacity: 0.3
  },
  "&:disabled": {
    opacity: 0.3
  },
  [`&:focus:not(:disabled) ${StyledRowButtonInner}`]: {
    backgroundColor: "$hover"
  },
  "& a": {
    textDecoration: "none",
    color: "$text"
  },
  variants: {
    bp: {
      mobile: {},
      small: {}
    },
    variant: {
      styleMenu: {
        margin: "$1 0 $1 0"
      },
      wide: {
        gridColumn: "1 / span 4"
      }
    },
    size: {
      icon: {
        padding: "4px ",
        width: "auto"
      }
    },
    isWarning: {
      true: {
        color: "$warn"
      }
    },
    isActive: {
      true: {
        backgroundColor: "$hover"
      },
      false: {}
    }
  }
});

// src/components/Tldraw/components/Primitives/ToolButton/ToolButton.tsx
var React15 = __toESM(require("react"));

// node_modules/.pnpm/@radix-ui+react-tooltip@1.0.6_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-tooltip/dist/index.mjs
var import_react35 = require("react");

// node_modules/.pnpm/@radix-ui+react-visually-hidden@1.0.3_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
var import_react34 = require("react");
var $ea1ef594cf570d83$export$439d29a4e110a164 = /* @__PURE__ */ (0, import_react34.forwardRef)((props, forwardedRef) => {
  return /* @__PURE__ */ (0, import_react34.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({}, props, {
    ref: forwardedRef,
    style: {
      // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
      position: "absolute",
      border: 0,
      width: 1,
      height: 1,
      padding: 0,
      margin: -1,
      overflow: "hidden",
      clip: "rect(0, 0, 0, 0)",
      whiteSpace: "nowrap",
      wordWrap: "normal",
      ...props.style
    }
  }));
});
var $ea1ef594cf570d83$export$be92b6f5f03c0fe9 = $ea1ef594cf570d83$export$439d29a4e110a164;

// node_modules/.pnpm/@radix-ui+react-tooltip@1.0.6_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-tooltip/dist/index.mjs
var [$a093c7e1ec25a057$var$createTooltipContext, $a093c7e1ec25a057$export$1c540a2224f0d865] = $c512c27ab02ef895$export$50c7b4e9d9f19c1("Tooltip", [
  $cf1ac5d9fe0e8206$export$722aac194ae923
]);
var $a093c7e1ec25a057$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
var $a093c7e1ec25a057$var$PROVIDER_NAME = "TooltipProvider";
var $a093c7e1ec25a057$var$DEFAULT_DELAY_DURATION = 700;
var $a093c7e1ec25a057$var$TOOLTIP_OPEN = "tooltip.open";
var [$a093c7e1ec25a057$var$TooltipProviderContextProvider, $a093c7e1ec25a057$var$useTooltipProviderContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PROVIDER_NAME);
var $a093c7e1ec25a057$export$f78649fb9ca566b8 = (props) => {
  const { __scopeTooltip, delayDuration = $a093c7e1ec25a057$var$DEFAULT_DELAY_DURATION, skipDelayDuration = 300, disableHoverableContent = false, children } = props;
  const [isOpenDelayed, setIsOpenDelayed] = (0, import_react35.useState)(true);
  const isPointerInTransitRef = (0, import_react35.useRef)(false);
  const skipDelayTimerRef = (0, import_react35.useRef)(0);
  (0, import_react35.useEffect)(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$TooltipProviderContextProvider, {
    scope: __scopeTooltip,
    isOpenDelayed,
    delayDuration,
    onOpen: (0, import_react35.useCallback)(() => {
      window.clearTimeout(skipDelayTimerRef.current);
      setIsOpenDelayed(false);
    }, []),
    onClose: (0, import_react35.useCallback)(() => {
      window.clearTimeout(skipDelayTimerRef.current);
      skipDelayTimerRef.current = window.setTimeout(
        () => setIsOpenDelayed(true),
        skipDelayDuration
      );
    }, [
      skipDelayDuration
    ]),
    isPointerInTransitRef,
    onPointerInTransitChange: (0, import_react35.useCallback)((inTransit) => {
      isPointerInTransitRef.current = inTransit;
    }, []),
    disableHoverableContent
  }, children);
};
var $a093c7e1ec25a057$var$TOOLTIP_NAME = "Tooltip";
var [$a093c7e1ec25a057$var$TooltipContextProvider, $a093c7e1ec25a057$var$useTooltipContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME);
var $a093c7e1ec25a057$export$28c660c63b792dea = (props) => {
  const { __scopeTooltip, children, open: openProp, defaultOpen = false, onOpenChange, disableHoverableContent: disableHoverableContentProp, delayDuration: delayDurationProp } = props;
  const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
  const [trigger, setTrigger] = (0, import_react35.useState)(null);
  const contentId = $1746a345f3d73bb7$export$f680877a34711e37();
  const openTimerRef = (0, import_react35.useRef)(0);
  const disableHoverableContent = disableHoverableContentProp !== null && disableHoverableContentProp !== void 0 ? disableHoverableContentProp : providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp !== null && delayDurationProp !== void 0 ? delayDurationProp : providerContext.delayDuration;
  const wasOpenDelayedRef = (0, import_react35.useRef)(false);
  const [open1 = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: (open) => {
      if (open) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent($a093c7e1ec25a057$var$TOOLTIP_OPEN));
      } else
        providerContext.onClose();
      onOpenChange === null || onOpenChange === void 0 || onOpenChange(open);
    }
  });
  const stateAttribute = (0, import_react35.useMemo)(() => {
    return open1 ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [
    open1
  ]);
  const handleOpen = (0, import_react35.useCallback)(() => {
    window.clearTimeout(openTimerRef.current);
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [
    setOpen
  ]);
  const handleClose = (0, import_react35.useCallback)(() => {
    window.clearTimeout(openTimerRef.current);
    setOpen(false);
  }, [
    setOpen
  ]);
  const handleDelayedOpen = (0, import_react35.useCallback)(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
    }, delayDuration);
  }, [
    delayDuration,
    setOpen
  ]);
  (0, import_react35.useEffect)(() => {
    return () => window.clearTimeout(openTimerRef.current);
  }, []);
  return /* @__PURE__ */ (0, import_react35.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$TooltipContextProvider, {
    scope: __scopeTooltip,
    contentId,
    open: open1,
    stateAttribute,
    trigger,
    onTriggerChange: setTrigger,
    onTriggerEnter: (0, import_react35.useCallback)(() => {
      if (providerContext.isOpenDelayed)
        handleDelayedOpen();
      else
        handleOpen();
    }, [
      providerContext.isOpenDelayed,
      handleDelayedOpen,
      handleOpen
    ]),
    onTriggerLeave: (0, import_react35.useCallback)(() => {
      if (disableHoverableContent)
        handleClose();
      else
        window.clearTimeout(openTimerRef.current);
    }, [
      handleClose,
      disableHoverableContent
    ]),
    onOpen: handleOpen,
    onClose: handleClose,
    disableHoverableContent
  }, children));
};
var $a093c7e1ec25a057$var$TRIGGER_NAME = "TooltipTrigger";
var $a093c7e1ec25a057$export$8c610744efcf8a1d = /* @__PURE__ */ (0, import_react35.forwardRef)((props, forwardedRef) => {
  const { __scopeTooltip, ...triggerProps } = props;
  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$TRIGGER_NAME, __scopeTooltip);
  const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$TRIGGER_NAME, __scopeTooltip);
  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
  const ref = (0, import_react35.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref, context.onTriggerChange);
  const isPointerDownRef = (0, import_react35.useRef)(false);
  const hasPointerMoveOpenedRef = (0, import_react35.useRef)(false);
  const handlePointerUp = (0, import_react35.useCallback)(
    () => isPointerDownRef.current = false,
    []
  );
  (0, import_react35.useEffect)(() => {
    return () => document.removeEventListener("pointerup", handlePointerUp);
  }, [
    handlePointerUp
  ]);
  return /* @__PURE__ */ (0, import_react35.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({
    asChild: true
  }, popperScope), /* @__PURE__ */ (0, import_react35.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    // We purposefully avoid adding `type=button` here because tooltip triggers are also
    // commonly anchors and the anchor `type` attribute signifies MIME type.
    "aria-describedby": context.open ? context.contentId : void 0,
    "data-state": context.stateAttribute
  }, triggerProps, {
    ref: composedRefs,
    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, (event) => {
      if (event.pointerType === "touch")
        return;
      if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
        context.onTriggerEnter();
        hasPointerMoveOpenedRef.current = true;
      }
    }),
    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, () => {
      context.onTriggerLeave();
      hasPointerMoveOpenedRef.current = false;
    }),
    onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, () => {
      isPointerDownRef.current = true;
      document.addEventListener("pointerup", handlePointerUp, {
        once: true
      });
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, () => {
      if (!isPointerDownRef.current)
        context.onOpen();
    }),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, context.onClose),
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onClose)
  })));
});
var $a093c7e1ec25a057$var$PORTAL_NAME = "TooltipPortal";
var [$a093c7e1ec25a057$var$PortalProvider, $a093c7e1ec25a057$var$usePortalContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PORTAL_NAME, {
  forceMount: void 0
});
var $a093c7e1ec25a057$var$CONTENT_NAME = "TooltipContent";
var $a093c7e1ec25a057$export$e9003e2be37ec060 = /* @__PURE__ */ (0, import_react35.forwardRef)((props, forwardedRef) => {
  const portalContext = $a093c7e1ec25a057$var$usePortalContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
  const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
  return /* @__PURE__ */ (0, import_react35.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, context.disableHoverableContent ? /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$TooltipContentImpl, _extends({
    side
  }, contentProps, {
    ref: forwardedRef
  })) : /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$TooltipContentHoverable, _extends({
    side
  }, contentProps, {
    ref: forwardedRef
  })));
});
var $a093c7e1ec25a057$var$TooltipContentHoverable = /* @__PURE__ */ (0, import_react35.forwardRef)((props, forwardedRef) => {
  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
  const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
  const ref = (0, import_react35.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = (0, import_react35.useState)(null);
  const { trigger, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = (0, import_react35.useCallback)(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [
    onPointerInTransitChange
  ]);
  const handleCreateGraceArea = (0, import_react35.useCallback)((event, hoverTarget) => {
    const currentTarget = event.currentTarget;
    const exitPoint = {
      x: event.clientX,
      y: event.clientY
    };
    const exitSide = $a093c7e1ec25a057$var$getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
    const paddedExitPoints = $a093c7e1ec25a057$var$getPaddedExitPoints(exitPoint, exitSide);
    const hoverTargetPoints = $a093c7e1ec25a057$var$getPointsFromRect(hoverTarget.getBoundingClientRect());
    const graceArea = $a093c7e1ec25a057$var$getHull([
      ...paddedExitPoints,
      ...hoverTargetPoints
    ]);
    setPointerGraceArea(graceArea);
    onPointerInTransitChange(true);
  }, [
    onPointerInTransitChange
  ]);
  (0, import_react35.useEffect)(() => {
    return () => handleRemoveGraceArea();
  }, [
    handleRemoveGraceArea
  ]);
  (0, import_react35.useEffect)(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [
    trigger,
    content,
    handleCreateGraceArea,
    handleRemoveGraceArea
  ]);
  (0, import_react35.useEffect)(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = {
          x: event.clientX,
          y: event.clientY
        };
        const hasEnteredTarget = (trigger === null || trigger === void 0 ? void 0 : trigger.contains(target)) || (content === null || content === void 0 ? void 0 : content.contains(target));
        const isPointerOutsideGraceArea = !$a093c7e1ec25a057$var$isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget)
          handleRemoveGraceArea();
        else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [
    trigger,
    content,
    pointerGraceArea,
    onClose,
    handleRemoveGraceArea
  ]);
  return /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$TooltipContentImpl, _extends({}, props, {
    ref: composedRefs
  }));
});
var [$a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider, $a093c7e1ec25a057$var$useVisuallyHiddenContentContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME, {
  isInside: false
});
var $a093c7e1ec25a057$var$TooltipContentImpl = /* @__PURE__ */ (0, import_react35.forwardRef)((props, forwardedRef) => {
  const { __scopeTooltip, children, "aria-label": ariaLabel, onEscapeKeyDown, onPointerDownOutside, ...contentProps } = props;
  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, __scopeTooltip);
  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
  const { onClose } = context;
  (0, import_react35.useEffect)(() => {
    document.addEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN, onClose);
    return () => document.removeEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN, onClose);
  }, [
    onClose
  ]);
  (0, import_react35.useEffect)(() => {
    if (context.trigger) {
      const handleScroll2 = (event) => {
        const target = event.target;
        if (target !== null && target !== void 0 && target.contains(context.trigger))
          onClose();
      };
      window.addEventListener("scroll", handleScroll2, {
        capture: true
      });
      return () => window.removeEventListener("scroll", handleScroll2, {
        capture: true
      });
    }
  }, [
    context.trigger,
    onClose
  ]);
  return /* @__PURE__ */ (0, import_react35.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents: false,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside: (event) => event.preventDefault(),
    onDismiss: onClose
  }, /* @__PURE__ */ (0, import_react35.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({
    "data-state": context.stateAttribute
  }, popperScope, contentProps, {
    ref: forwardedRef,
    style: {
      ...contentProps.style,
      "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
      "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
      "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }), /* @__PURE__ */ (0, import_react35.createElement)($5e63c961fc1ce211$export$d9f1ccf0bdb05d45, null, children), /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider, {
    scope: __scopeTooltip,
    isInside: true
  }, /* @__PURE__ */ (0, import_react35.createElement)($ea1ef594cf570d83$export$be92b6f5f03c0fe9, {
    id: context.contentId,
    role: "tooltip"
  }, ariaLabel || children))));
});
var $a093c7e1ec25a057$var$ARROW_NAME = "TooltipArrow";
var $a093c7e1ec25a057$export$c27ee0ad710f7559 = /* @__PURE__ */ (0, import_react35.forwardRef)((props, forwardedRef) => {
  const { __scopeTooltip, ...arrowProps } = props;
  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
  const visuallyHiddenContentContext = $a093c7e1ec25a057$var$useVisuallyHiddenContentContext($a093c7e1ec25a057$var$ARROW_NAME, __scopeTooltip);
  return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ (0, import_react35.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {
    ref: forwardedRef
  }));
});
function $a093c7e1ec25a057$var$getExitSideFromRect(point, rect) {
  const top2 = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top2, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top2:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function $a093c7e1ec25a057$var$getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push({
        x: exitPoint.x - padding,
        y: exitPoint.y + padding
      }, {
        x: exitPoint.x + padding,
        y: exitPoint.y + padding
      });
      break;
    case "bottom":
      paddedExitPoints.push({
        x: exitPoint.x - padding,
        y: exitPoint.y - padding
      }, {
        x: exitPoint.x + padding,
        y: exitPoint.y - padding
      });
      break;
    case "left":
      paddedExitPoints.push({
        x: exitPoint.x + padding,
        y: exitPoint.y - padding
      }, {
        x: exitPoint.x + padding,
        y: exitPoint.y + padding
      });
      break;
    case "right":
      paddedExitPoints.push({
        x: exitPoint.x - padding,
        y: exitPoint.y - padding
      }, {
        x: exitPoint.x - padding,
        y: exitPoint.y + padding
      });
      break;
  }
  return paddedExitPoints;
}
function $a093c7e1ec25a057$var$getPointsFromRect(rect) {
  const { top: top2, right, bottom, left } = rect;
  return [
    {
      x: left,
      y: top2
    },
    {
      x: right,
      y: top2
    },
    {
      x: right,
      y: bottom
    },
    {
      x: left,
      y: bottom
    }
  ];
}
function $a093c7e1ec25a057$var$isPointInPolygon(point, polygon) {
  const { x: x5, y: y6 } = point;
  let inside = false;
  for (let i4 = 0, j4 = polygon.length - 1; i4 < polygon.length; j4 = i4++) {
    const xi = polygon[i4].x;
    const yi = polygon[i4].y;
    const xj = polygon[j4].x;
    const yj = polygon[j4].y;
    const intersect = yi > y6 !== yj > y6 && x5 < (xj - xi) * (y6 - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function $a093c7e1ec25a057$var$getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a7, b6) => {
    if (a7.x < b6.x)
      return -1;
    else if (a7.x > b6.x)
      return 1;
    else if (a7.y < b6.y)
      return -1;
    else if (a7.y > b6.y)
      return 1;
    else
      return 0;
  });
  return $a093c7e1ec25a057$var$getHullPresorted(newPoints);
}
function $a093c7e1ec25a057$var$getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i4 = 0; i4 < points.length; i4++) {
    const p6 = points[i4];
    while (upperHull.length >= 2) {
      const q4 = upperHull[upperHull.length - 1];
      const r5 = upperHull[upperHull.length - 2];
      if ((q4.x - r5.x) * (p6.y - r5.y) >= (q4.y - r5.y) * (p6.x - r5.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p6);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i1 = points.length - 1; i1 >= 0; i1--) {
    const p6 = points[i1];
    while (lowerHull.length >= 2) {
      const q4 = lowerHull[lowerHull.length - 1];
      const r5 = lowerHull[lowerHull.length - 2];
      if ((q4.x - r5.x) * (p6.y - r5.y) >= (q4.y - r5.y) * (p6.x - r5.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p6);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y)
    return upperHull;
  else
    return upperHull.concat(lowerHull);
}
var $a093c7e1ec25a057$export$2881499e37b75b9a = $a093c7e1ec25a057$export$f78649fb9ca566b8;
var $a093c7e1ec25a057$export$be92b6f5f03c0fe9 = $a093c7e1ec25a057$export$28c660c63b792dea;
var $a093c7e1ec25a057$export$41fb9f06171c75f4 = $a093c7e1ec25a057$export$8c610744efcf8a1d;
var $a093c7e1ec25a057$export$7c6e2c02157bb7d2 = $a093c7e1ec25a057$export$e9003e2be37ec060;
var $a093c7e1ec25a057$export$21b07c8f274aebd5 = $a093c7e1ec25a057$export$c27ee0ad710f7559;

// src/components/Tldraw/components/Primitives/Tooltip/Tooltip.tsx
var import_jsx_runtime4 = require("react/jsx-runtime");
function Tooltip({ children, label, kbd: kbdProperty, id, side = "top" }) {
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { id, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)($a093c7e1ec25a057$export$2881499e37b75b9a, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)($a093c7e1ec25a057$export$be92b6f5f03c0fe9, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)($a093c7e1ec25a057$export$41fb9f06171c75f4, { dir: "ltr", asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { children }) }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(StyledContent, { dir: "ltr", side, sideOffset: 8, children: [
      label,
      kbdProperty ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Kbd, { variant: "tooltip", children: kbdProperty }) : null,
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(StyledArrow, {})
    ] })
  ] }) }) });
}
var StyledContent = styled($a093c7e1ec25a057$export$7c6e2c02157bb7d2, {
  borderRadius: 3,
  padding: "$3 $3 $3 $3",
  fontSize: "$1",
  backgroundColor: "$tooltip",
  color: "$tooltipContrast",
  boxShadow: "$3",
  display: "flex",
  alignItems: "center",
  fontFamily: "$ui",
  userSelect: "none"
});
var StyledArrow = styled($a093c7e1ec25a057$export$21b07c8f274aebd5, {
  fill: "$tooltip",
  margin: "0 8px"
});

// src/components/Tldraw/hooks/useFileSystem.ts
var React10 = __toESM(require("react"));

// src/components/Tldraw/hooks/useFileSystemHandlers.ts
var React11 = __toESM(require("react"));
function useFileSystemHandlers() {
  const app = useTldrawApp();
  const onOpenMedia = React11.useCallback(
    (event) => {
      if (event !== void 0 && app.callbacks.onOpenMedia !== void 0)
        event.preventDefault();
      app.callbacks.onOpenMedia?.(app);
    },
    [app]
  );
  return {
    onOpenMedia
  };
}

// src/components/Tldraw/hooks/useKeyboardShortcuts.tsx
var React12 = __toESM(require("react"));

// node_modules/.pnpm/react-hotkeys-hook@4.4.0_react-dom@18.2.0_react@18.2.0/node_modules/react-hotkeys-hook/dist/react-hotkeys-hook.esm.js
var import_react36 = require("react");
var import_jsx_runtime5 = require("react/jsx-runtime");
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
var reservedModifierKeywords = ["shift", "alt", "meta", "mod", "ctrl"];
var mappedKeys = {
  esc: "escape",
  "return": "enter",
  ".": "period",
  ",": "comma",
  "-": "slash",
  " ": "space",
  "`": "backquote",
  "#": "backslash",
  "+": "bracketright",
  ShiftLeft: "shift",
  ShiftRight: "shift",
  AltLeft: "alt",
  AltRight: "alt",
  MetaLeft: "meta",
  MetaRight: "meta",
  OSLeft: "meta",
  OSRight: "meta",
  ControlLeft: "ctrl",
  ControlRight: "ctrl"
};
function mapKey(key) {
  return (mappedKeys[key] || key).trim().toLowerCase().replace(/key|digit|numpad|arrow/, "");
}
function isHotkeyModifier(key) {
  return reservedModifierKeywords.includes(key);
}
function parseKeysHookInput(keys, splitKey) {
  if (splitKey === void 0) {
    splitKey = ",";
  }
  return keys.split(splitKey);
}
function parseHotkey(hotkey, combinationKey, description) {
  if (combinationKey === void 0) {
    combinationKey = "+";
  }
  var keys = hotkey.toLocaleLowerCase().split(combinationKey).map(function(k7) {
    return mapKey(k7);
  });
  var modifiers = {
    alt: keys.includes("alt"),
    ctrl: keys.includes("ctrl") || keys.includes("control"),
    shift: keys.includes("shift"),
    meta: keys.includes("meta"),
    mod: keys.includes("mod")
  };
  var singleCharKeys = keys.filter(function(k7) {
    return !reservedModifierKeywords.includes(k7);
  });
  return _extends2({}, modifiers, {
    keys: singleCharKeys,
    description
  });
}
(function() {
  if (typeof document !== "undefined") {
    document.addEventListener("keydown", function(e5) {
      if (e5.key === void 0) {
        return;
      }
      pushToCurrentlyPressedKeys([mapKey(e5.key), mapKey(e5.code)]);
    });
    document.addEventListener("keyup", function(e5) {
      if (e5.key === void 0) {
        return;
      }
      removeFromCurrentlyPressedKeys([mapKey(e5.key), mapKey(e5.code)]);
    });
  }
  if (typeof window !== "undefined") {
    window.addEventListener("blur", function() {
      currentlyPressedKeys.clear();
    });
  }
})();
var currentlyPressedKeys = /* @__PURE__ */ new Set();
function isHotkeyPressed(key, splitKey) {
  if (splitKey === void 0) {
    splitKey = ",";
  }
  var hotkeyArray = Array.isArray(key) ? key : key.split(splitKey);
  return hotkeyArray.every(function(hotkey) {
    return currentlyPressedKeys.has(hotkey.trim().toLowerCase());
  });
}
function pushToCurrentlyPressedKeys(key) {
  var hotkeyArray = Array.isArray(key) ? key : [key];
  if (currentlyPressedKeys.has("meta")) {
    currentlyPressedKeys.forEach(function(key2) {
      return !isHotkeyModifier(key2) && currentlyPressedKeys["delete"](key2.toLowerCase());
    });
  }
  hotkeyArray.forEach(function(hotkey) {
    return currentlyPressedKeys.add(hotkey.toLowerCase());
  });
}
function removeFromCurrentlyPressedKeys(key) {
  var hotkeyArray = Array.isArray(key) ? key : [key];
  if (key === "meta") {
    currentlyPressedKeys.clear();
  } else {
    hotkeyArray.forEach(function(hotkey) {
      return currentlyPressedKeys["delete"](hotkey.toLowerCase());
    });
  }
}
function maybePreventDefault(e5, hotkey, preventDefault2) {
  if (typeof preventDefault2 === "function" && preventDefault2(e5, hotkey) || preventDefault2 === true) {
    e5.preventDefault();
  }
}
function isHotkeyEnabled(e5, hotkey, enabled) {
  if (typeof enabled === "function") {
    return enabled(e5, hotkey);
  }
  return enabled === true || enabled === void 0;
}
function isKeyboardEventTriggeredByInput(ev) {
  return isHotkeyEnabledOnTag(ev, ["input", "textarea", "select"]);
}
function isHotkeyEnabledOnTag(_ref, enabledOnTags) {
  var target = _ref.target;
  if (enabledOnTags === void 0) {
    enabledOnTags = false;
  }
  var targetTagName = target && target.tagName;
  if (enabledOnTags instanceof Array) {
    return Boolean(targetTagName && enabledOnTags && enabledOnTags.some(function(tag) {
      return tag.toLowerCase() === targetTagName.toLowerCase();
    }));
  }
  return Boolean(targetTagName && enabledOnTags && enabledOnTags === true);
}
function isScopeActive(activeScopes, scopes) {
  if (activeScopes.length === 0 && scopes) {
    console.warn('A hotkey has the "scopes" option set, however no active scopes were found. If you want to use the global scopes feature, you need to wrap your app in a <HotkeysProvider>');
    return true;
  }
  if (!scopes) {
    return true;
  }
  return activeScopes.some(function(scope) {
    return scopes.includes(scope);
  }) || activeScopes.includes("*");
}
var isHotkeyMatchingKeyboardEvent = function isHotkeyMatchingKeyboardEvent2(e5, hotkey, ignoreModifiers) {
  if (ignoreModifiers === void 0) {
    ignoreModifiers = false;
  }
  var alt = hotkey.alt, meta = hotkey.meta, mod = hotkey.mod, shift = hotkey.shift, ctrl = hotkey.ctrl, keys = hotkey.keys;
  var pressedKeyUppercase = e5.key, code = e5.code, ctrlKey = e5.ctrlKey, metaKey = e5.metaKey, shiftKey = e5.shiftKey, altKey = e5.altKey;
  var keyCode = mapKey(code);
  var pressedKey = pressedKeyUppercase.toLowerCase();
  if (!ignoreModifiers) {
    if (alt === !altKey && pressedKey !== "alt") {
      return false;
    }
    if (shift === !shiftKey && pressedKey !== "shift") {
      return false;
    }
    if (mod) {
      if (!metaKey && !ctrlKey) {
        return false;
      }
    } else {
      if (meta === !metaKey && pressedKey !== "meta" && pressedKey !== "os") {
        return false;
      }
      if (ctrl === !ctrlKey && pressedKey !== "ctrl" && pressedKey !== "control") {
        return false;
      }
    }
  }
  if (keys && keys.length === 1 && (keys.includes(pressedKey) || keys.includes(keyCode))) {
    return true;
  } else if (keys) {
    return isHotkeyPressed(keys);
  } else if (!keys) {
    return true;
  }
  return false;
};
var BoundHotkeysProxyProvider = /* @__PURE__ */ (0, import_react36.createContext)(void 0);
var useBoundHotkeysProxy = function useBoundHotkeysProxy2() {
  return (0, import_react36.useContext)(BoundHotkeysProxyProvider);
};
function deepEqual2(x5, y6) {
  return x5 && y6 && typeof x5 === "object" && typeof y6 === "object" ? Object.keys(x5).length === Object.keys(y6).length && //@ts-ignore
  Object.keys(x5).reduce(function(isEqual, key) {
    return isEqual && deepEqual2(x5[key], y6[key]);
  }, true) : x5 === y6;
}
var HotkeysContext = /* @__PURE__ */ (0, import_react36.createContext)({
  hotkeys: [],
  enabledScopes: [],
  toggleScope: function toggleScope() {
  },
  enableScope: function enableScope() {
  },
  disableScope: function disableScope() {
  }
});
var useHotkeysContext = function useHotkeysContext2() {
  return (0, import_react36.useContext)(HotkeysContext);
};
function useDeepEqualMemo(value) {
  var ref = (0, import_react36.useRef)(void 0);
  if (!deepEqual2(ref.current, value)) {
    ref.current = value;
  }
  return ref.current;
}
var stopPropagation = function stopPropagation2(e5) {
  e5.stopPropagation();
  e5.preventDefault();
  e5.stopImmediatePropagation();
};
var useSafeLayoutEffect = typeof window !== "undefined" ? import_react36.useLayoutEffect : import_react36.useEffect;
function useHotkeys(keys, callback, options, dependencies) {
  var ref = (0, import_react36.useRef)(null);
  var hasTriggeredRef = (0, import_react36.useRef)(false);
  var _options = !(options instanceof Array) ? options : !(dependencies instanceof Array) ? dependencies : void 0;
  var _keys = keys instanceof Array ? keys.join(_options == null ? void 0 : _options.splitKey) : keys;
  var _deps = options instanceof Array ? options : dependencies instanceof Array ? dependencies : void 0;
  var memoisedCB = (0, import_react36.useCallback)(callback, _deps != null ? _deps : []);
  var cbRef = (0, import_react36.useRef)(memoisedCB);
  if (_deps) {
    cbRef.current = memoisedCB;
  } else {
    cbRef.current = callback;
  }
  var memoisedOptions = useDeepEqualMemo(_options);
  var _useHotkeysContext = useHotkeysContext(), enabledScopes = _useHotkeysContext.enabledScopes;
  var proxy = useBoundHotkeysProxy();
  useSafeLayoutEffect(function() {
    if ((memoisedOptions == null ? void 0 : memoisedOptions.enabled) === false || !isScopeActive(enabledScopes, memoisedOptions == null ? void 0 : memoisedOptions.scopes)) {
      return;
    }
    var listener = function listener2(e5, isKeyUp) {
      var _e$target;
      if (isKeyUp === void 0) {
        isKeyUp = false;
      }
      if (isKeyboardEventTriggeredByInput(e5) && !isHotkeyEnabledOnTag(e5, memoisedOptions == null ? void 0 : memoisedOptions.enableOnFormTags)) {
        return;
      }
      if (memoisedOptions != null && memoisedOptions.ignoreEventWhen != null && memoisedOptions.ignoreEventWhen(e5)) {
        return;
      }
      if (ref.current !== null && document.activeElement !== ref.current && !ref.current.contains(document.activeElement)) {
        stopPropagation(e5);
        return;
      }
      if ((_e$target = e5.target) != null && _e$target.isContentEditable && !(memoisedOptions != null && memoisedOptions.enableOnContentEditable)) {
        return;
      }
      parseKeysHookInput(_keys, memoisedOptions == null ? void 0 : memoisedOptions.splitKey).forEach(function(key) {
        var _hotkey$keys;
        var hotkey = parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.combinationKey);
        if (isHotkeyMatchingKeyboardEvent(e5, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.ignoreModifiers) || (_hotkey$keys = hotkey.keys) != null && _hotkey$keys.includes("*")) {
          if (isKeyUp && hasTriggeredRef.current) {
            return;
          }
          maybePreventDefault(e5, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.preventDefault);
          if (!isHotkeyEnabled(e5, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.enabled)) {
            stopPropagation(e5);
            return;
          }
          cbRef.current(e5, hotkey);
          if (!isKeyUp) {
            hasTriggeredRef.current = true;
          }
        }
      });
    };
    var handleKeyDown = function handleKeyDown2(event) {
      if (event.key === void 0) {
        return;
      }
      pushToCurrentlyPressedKeys(mapKey(event.code));
      if ((memoisedOptions == null ? void 0 : memoisedOptions.keydown) === void 0 && (memoisedOptions == null ? void 0 : memoisedOptions.keyup) !== true || memoisedOptions != null && memoisedOptions.keydown) {
        listener(event);
      }
    };
    var handleKeyUp = function handleKeyUp2(event) {
      if (event.key === void 0) {
        return;
      }
      removeFromCurrentlyPressedKeys(mapKey(event.code));
      hasTriggeredRef.current = false;
      if (memoisedOptions != null && memoisedOptions.keyup) {
        listener(event, true);
      }
    };
    var domNode = ref.current || (_options == null ? void 0 : _options.document) || document;
    domNode.addEventListener("keyup", handleKeyUp);
    domNode.addEventListener("keydown", handleKeyDown);
    if (proxy) {
      parseKeysHookInput(_keys, memoisedOptions == null ? void 0 : memoisedOptions.splitKey).forEach(function(key) {
        return proxy.addHotkey(parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.combinationKey, memoisedOptions == null ? void 0 : memoisedOptions.description));
      });
    }
    return function() {
      domNode.removeEventListener("keyup", handleKeyUp);
      domNode.removeEventListener("keydown", handleKeyDown);
      if (proxy) {
        parseKeysHookInput(_keys, memoisedOptions == null ? void 0 : memoisedOptions.splitKey).forEach(function(key) {
          return proxy.removeHotkey(parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.combinationKey, memoisedOptions == null ? void 0 : memoisedOptions.description));
        });
      }
    };
  }, [_keys, memoisedOptions, enabledScopes]);
  return ref;
}

// src/components/Tldraw/types.ts
var TDEventHandler = class {
  onPinchStart;
  onPinchEnd;
  onPinch;
  onKeyDown;
  onKeyUp;
  onPointerMove;
  onPointerUp;
  onPan;
  onZoom;
  onPointerDown;
  onPointCanvas;
  onDoubleClickCanvas;
  onRightPointCanvas;
  onDragCanvas;
  onReleaseCanvas;
  onPointShape;
  onDoubleClickShape;
  onRightPointShape;
  onDragShape;
  onHoverShape;
  onUnhoverShape;
  onReleaseShape;
  onPointBounds;
  onDoubleClickBounds;
  onRightPointBounds;
  onDragBounds;
  onHoverBounds;
  onUnhoverBounds;
  onReleaseBounds;
  onPointBoundsHandle;
  onDoubleClickBoundsHandle;
  onRightPointBoundsHandle;
  onDragBoundsHandle;
  onHoverBoundsHandle;
  onUnhoverBoundsHandle;
  onReleaseBoundsHandle;
  onPointHandle;
  onDoubleClickHandle;
  onRightPointHandle;
  onDragHandle;
  onHoverHandle;
  onUnhoverHandle;
  onReleaseHandle;
  onShapeBlur;
  onShapeClone;
};
var SizeStyle = /* @__PURE__ */ ((SizeStyle2) => {
  SizeStyle2["Large"] = "large";
  SizeStyle2["Medium"] = "medium";
  SizeStyle2["Small"] = "small";
  return SizeStyle2;
})(SizeStyle || {});
var DashStyle = /* @__PURE__ */ ((DashStyle2) => {
  DashStyle2["Dashed"] = "dashed";
  DashStyle2["Dotted"] = "dotted";
  DashStyle2["Draw"] = "draw";
  DashStyle2["Solid"] = "solid";
  return DashStyle2;
})(DashStyle || {});
var AlignStyle = /* @__PURE__ */ ((AlignStyle2) => {
  AlignStyle2["End"] = "end";
  AlignStyle2["Justify"] = "justify";
  AlignStyle2["Middle"] = "middle";
  AlignStyle2["Start"] = "start";
  return AlignStyle2;
})(AlignStyle || {});
var FontStyle = /* @__PURE__ */ ((FontStyle2) => {
  FontStyle2["Mono"] = "mono";
  FontStyle2["Sans"] = "sans";
  FontStyle2["Script"] = "script";
  FontStyle2["Serif"] = "serif";
  return FontStyle2;
})(FontStyle || {});
var TDExportBackground = /* @__PURE__ */ ((TDExportBackground2) => {
  TDExportBackground2["Auto"] = "auto";
  TDExportBackground2["Dark"] = "dark";
  TDExportBackground2["Light"] = "light";
  TDExportBackground2["Transparent"] = "transparent";
  return TDExportBackground2;
})(TDExportBackground || {});

// src/components/Tldraw/state/shapes/StickyUtil/constants.ts
var STICKY_TEXT_AREA_CLASS_NAME = "tl-sticky-edit-text-area";

// src/components/Tldraw/hooks/useKeyboardShortcuts.tsx
function useKeyboardShortcuts(reference) {
  const app = useTldrawApp();
  const hotKeySetting = {};
  const canHandleEvent = React12.useCallback(
    (ignoreMenus = false) => {
      const containerElement = reference.current;
      if (!app.isMouseInBound)
        return false;
      if (document.activeElement?.classList?.contains(STICKY_TEXT_AREA_CLASS_NAME))
        return false;
      if (ignoreMenus && (app.isMenuOpen || app.settings.keepStyleMenuOpen))
        return true;
      return containerElement !== null && (document.activeElement === containerElement || containerElement.contains(document.activeElement));
    },
    [reference, app]
  );
  React12.useEffect(() => {
    if (!app)
      return;
    const handleCut = (event) => {
      if (!canHandleEvent(true))
        return;
      if (app.readOnly) {
        app.copy(void 0, event);
        return;
      }
      app.cut(void 0, event);
    };
    const handleCopy = (event) => {
      if (!canHandleEvent(true))
        return;
      app.copy(void 0, event);
    };
    const handlePaste = (event) => {
      if (!canHandleEvent(true))
        return;
      if (app.readOnly)
        return;
      void app.paste(void 0, event);
    };
    reference.current?.addEventListener("cut", handleCut);
    reference.current?.addEventListener("copy", handleCopy);
    reference.current?.addEventListener("paste", handlePaste);
    return () => {
      reference.current?.removeEventListener("cut", handleCut);
      reference.current?.removeEventListener("copy", handleCopy);
      reference.current?.removeEventListener("paste", handlePaste);
    };
  }, [app]);
  useHotkeys(
    "v,1",
    () => {
      if (!canHandleEvent(true))
        return;
      app.selectTool("select");
    },
    hotKeySetting,
    [app, reference.current]
  ).current = reference.current;
  useHotkeys(
    "d,p,2",
    () => {
      if (!canHandleEvent(true))
        return;
      app.selectTool("draw" /* Draw */);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "e,3",
    () => {
      if (!canHandleEvent(true))
        return;
      app.selectTool("erase");
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "r,4",
    () => {
      if (!canHandleEvent(true))
        return;
      app.selectTool("rectangle" /* Rectangle */);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "o,5",
    () => {
      if (!canHandleEvent(true))
        return;
      app.selectTool("ellipse" /* Ellipse */);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "g,6",
    () => {
      if (!canHandleEvent())
        return;
      app.selectTool("triangle" /* Triangle */);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "l,7",
    () => {
      if (!canHandleEvent(true))
        return;
      app.selectTool("line" /* Line */);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "a,8",
    () => {
      if (!canHandleEvent(true))
        return;
      app.selectTool("arrow" /* Arrow */);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "t,9",
    () => {
      if (!canHandleEvent(true))
        return;
      app.selectTool("text" /* Text */);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "s,0",
    () => {
      if (!canHandleEvent(true))
        return;
      app.selectTool("sticky" /* Sticky */);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "ctrl+.,\u2318+.",
    () => {
      if (!canHandleEvent(true))
        return;
      app.toggleFocusMode();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "ctrl+shift+g,\u2318+shift+g",
    () => {
      if (!canHandleEvent(true))
        return;
      app.toggleGrid();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  const { onOpenMedia } = useFileSystemHandlers();
  useHotkeys(
    "ctrl+u,\u2318+u",
    (event) => {
      if (!canHandleEvent())
        return;
      onOpenMedia(event);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "\u2318+z,ctrl+z",
    (event) => {
      event?.preventDefault();
      event?.stopPropagation();
      if (!canHandleEvent(true))
        return;
      if (app.session === void 0) {
        app.undo();
      } else {
        app.cancelSession();
      }
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "ctrl+shift+z,\u2318+shift+z",
    () => {
      if (!canHandleEvent(true))
        return;
      if (app.session === void 0) {
        app.redo();
      } else {
        app.cancelSession();
      }
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "\u2318+u,ctrl+u",
    () => {
      if (!canHandleEvent())
        return;
      app.undoSelect();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "ctrl+shift-u,\u2318+shift+u",
    () => {
      if (!canHandleEvent())
        return;
      app.redoSelect();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "ctrl+=,\u2318+=,ctrl+num_add,\u2318+num_add",
    (event) => {
      if (!canHandleEvent(true))
        return;
      app.zoomIn();
      event?.preventDefault();
      event?.stopPropagation();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "ctrl+-,\u2318+-,ctrl+num_subtract,\u2318+num_subtract",
    (event) => {
      if (!canHandleEvent(true))
        return;
      app.zoomOut();
      event?.preventDefault();
      event?.stopPropagation();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "shift+0,ctrl+numpad_0,\u2318+numpad_0",
    () => {
      if (!canHandleEvent(true))
        return;
      app.resetZoom();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "shift+1",
    () => {
      if (!canHandleEvent(true))
        return;
      app.zoomToFit();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "shift+2",
    () => {
      if (!canHandleEvent(true))
        return;
      app.zoomToSelection();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "ctrl+d,\u2318+d",
    (event) => {
      if (!canHandleEvent())
        return;
      app.duplicate();
      event?.preventDefault();
      event?.stopPropagation();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "shift+h",
    () => {
      if (!canHandleEvent(true))
        return;
      app.flipHorizontal();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "shift+v",
    () => {
      if (!canHandleEvent(true))
        return;
      app.flipVertical();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "escape",
    () => {
      if (!canHandleEvent(true))
        return;
      app.cancel();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "backspace,del",
    () => {
      if (!canHandleEvent())
        return;
      app.delete();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "\u2318+a,ctrl+a",
    (event) => {
      if (!canHandleEvent(true))
        return;
      event.preventDefault();
      app.selectAll();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "up",
    () => {
      if (!canHandleEvent())
        return;
      app.nudge([0, -1], false);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "right",
    () => {
      if (!canHandleEvent())
        return;
      app.nudge([1, 0], false);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "down",
    () => {
      if (!canHandleEvent())
        return;
      app.nudge([0, 1], false);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "left",
    () => {
      if (!canHandleEvent())
        return;
      app.nudge([-1, 0], false);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "shift+up",
    () => {
      if (!canHandleEvent())
        return;
      app.nudge([0, -1], true);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "shift+right",
    () => {
      if (!canHandleEvent())
        return;
      app.nudge([1, 0], true);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "shift+down",
    () => {
      if (!canHandleEvent())
        return;
      app.nudge([0, 1], true);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "shift+left",
    () => {
      if (!canHandleEvent())
        return;
      app.nudge([-1, 0], true);
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "\u2318+shift+l,ctrl+shift+l",
    () => {
      if (!canHandleEvent())
        return;
      app.toggleLocked();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "\u2318+g,ctrl+g",
    (event) => {
      if (!canHandleEvent())
        return;
      event?.preventDefault();
      event?.stopPropagation();
      app.group();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "\u2318+shift+g,ctrl+shift+g",
    (event) => {
      if (!canHandleEvent())
        return;
      event?.preventDefault();
      event?.stopPropagation();
      app.ungroup();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "[",
    () => {
      if (!canHandleEvent(true))
        return;
      app.moveBackward();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "]",
    () => {
      if (!canHandleEvent(true))
        return;
      app.moveForward();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "shift+[",
    () => {
      if (!canHandleEvent(true))
        return;
      app.moveToBack();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "shift+]",
    () => {
      if (!canHandleEvent(true))
        return;
      app.moveToFront();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "ctrl+shift+backspace,\u2318+shift+backspace",
    (event) => {
      if (!canHandleEvent())
        return;
      if (app.settings.isDebugMode) {
        app.resetDocument();
      }
      event?.preventDefault();
      event?.stopPropagation();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "alt+command+l,alt+ctrl+l",
    (event) => {
      if (!canHandleEvent(true))
        return;
      app.style({ textAlign: "start" /* Start */ });
      event?.preventDefault();
      event?.stopPropagation();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "alt+command+t,alt+ctrl+t",
    (event) => {
      if (!canHandleEvent(true))
        return;
      app.style({ textAlign: "middle" /* Middle */ });
      event?.preventDefault();
      event?.stopPropagation();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
  useHotkeys(
    "alt+command+r,alt+ctrl+r",
    (event) => {
      if (!canHandleEvent(true))
        return;
      app.style({ textAlign: "end" /* End */ });
      event?.preventDefault();
      event?.stopPropagation();
    },
    hotKeySetting,
    [app]
  ).current = reference.current;
}

// src/components/Tldraw/hooks/useTldrawApp.tsx
var React13 = __toESM(require("react"));
var TldrawContext = React13.createContext({});
var useForceUpdate = () => {
  const [_state, setState] = React13.useState(0);
  React13.useEffect(() => setState(1));
};
function useTldrawApp() {
  const context = React13.useContext(TldrawContext);
  return context;
}
var ContainerContext = React13.createContext({});
function useContainer() {
  const context = React13.useContext(ContainerContext);
  useForceUpdate();
  return context;
}

// src/components/Tldraw/hooks/useDialog.ts
var React14 = __toESM(require("react"));
var AlertDialogContext = React14.createContext({});
var useDialog = () => {
  const context = React14.useContext(AlertDialogContext);
  if (!context)
    throw new Error("useCtx must be inside a Provider with a value");
  return context;
};

// src/components/Tldraw/components/Primitives/ToolButton/ToolButton.tsx
var import_jsx_runtime6 = require("react/jsx-runtime");
var ToolButton = React15.forwardRef(
  ({ onSelect, onClick, onDoubleClick, variant, children, isToolLocked = false, disabled = false, isActive = false, onKeyDown, id, ...rest }, reference) => {
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
      StyledToolButton,
      {
        ref: reference,
        isActive,
        variant,
        onClick,
        disabled,
        onPointerDown: onSelect,
        onDoubleClick,
        onKeyDown,
        bp: breakpoints,
        id,
        ...rest,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(StyledToolButtonInner, { children }),
          isToolLocked && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ToolLockIndicator, {})
        ]
      }
    );
  }
);
function ToolButtonWithTooltip({ label, kbd, isLocked, ...rest }) {
  const app = useTldrawApp();
  const handleDoubleClick = React15.useCallback(() => {
    app.toggleToolLock();
  }, []);
  const handleKeyDown = React15.useCallback((e5) => {
    if (e5.key === " " && app.isForcePanning) {
      e5.preventDefault();
    }
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Tooltip, { label: label[0].toUpperCase() + label.slice(1), kbd, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ToolButton, { ...rest, variant: "primary", isToolLocked: isLocked && rest.isActive, onDoubleClick: handleDoubleClick, onKeyDown: handleKeyDown }) });
}
var StyledToolButtonInner = styled("div", {
  position: "relative",
  height: "100%",
  width: "100%",
  backgroundColor: "$panel",
  borderRadius: "$2",
  margin: "0",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  fontFamily: "$ui",
  color: "inherit",
  userSelect: "none",
  boxSizing: "border-box",
  border: "1px solid transparent",
  "-webkit-tap-highlight-color": "transparent",
  "tap-highlight-color": "transparent"
});
var StyledToolButton = styled("button", {
  position: "relative",
  color: "$text",
  fontSize: "$0",
  background: "none",
  margin: "0",
  padding: "$2",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  outline: "none",
  cursor: "pointer",
  pointerEvents: "all",
  height: "40px",
  width: "40px",
  border: "1px solid $panel",
  "-webkit-tap-highlight-color": "transparent",
  "tap-highlight-color": "transparent",
  [`&:disabled ${StyledToolButtonInner}`]: {
    opacity: 0.618
  },
  variants: {
    variant: {
      primary: {
        marginTop: "0"
      },
      icon: {
        [`& ${StyledToolButtonInner}`]: {
          display: "grid",
          "& > *": {
            gridRow: 1,
            gridColumn: 1
          }
        }
      },
      text: {
        width: "auto",
        [`& ${StyledToolButtonInner}`]: {
          fontSize: "$1",
          padding: "0 $3",
          gap: "$3"
        }
      },
      circle: {
        padding: 0,
        height: 32,
        width: 32,
        border: "none",
        [`& ${StyledToolButtonInner}`]: {
          border: "1px solid $panelContrast",
          borderRadius: "100%",
          boxShadow: "$panel"
        },
        [`& ${StyledToolButtonInner} > svg`]: {
          width: 14,
          height: 14
        }
      }
    },
    isActive: {
      true: {},
      false: {}
    },
    bp: {
      mobile: {
        padding: 0
      },
      small: {}
    }
  },
  compoundVariants: [
    {
      variant: "primary",
      bp: "mobile",
      css: {
        height: 40,
        width: 36,
        [`& ${StyledToolButtonInner} > svg`]: {
          width: 16,
          height: 16
        }
      }
    },
    {
      variant: "primary",
      bp: "small",
      css: {
        height: "44px",
        width: "44px",
        [`& ${StyledToolButtonInner} > svg`]: {
          width: 20,
          height: 20
        }
      }
    },
    {
      isActive: true,
      css: {
        [`${StyledToolButtonInner}`]: {
          backgroundColor: "$selected",
          color: "$selectedContrast"
        }
      }
    },
    {
      isActive: false,
      bp: "small",
      css: {
        [`&:hover:not(:disabled) ${StyledToolButtonInner}`]: {
          backgroundColor: "$hover"
        },
        [`&:focus:not(:disabled) ${StyledToolButtonInner}`]: {
          backgroundColor: "$hover"
        }
      }
    }
  ]
});
var ToolLockIndicator = styled("div", {
  position: "absolute",
  width: 10,
  height: 10,
  backgroundColor: "$selected",
  borderRadius: "100%",
  bottom: -2,
  border: "2px solid $panel",
  zIndex: 100
});

// src/components/Tldraw/components/ContextMenu/ContextMenu.tsx
var import_jsx_runtime7 = require("react/jsx-runtime");
var numberOfSelectedIdsSelector = (s5) => {
  return s5.document.pageStates[s5.appState.currentPageId].selectedIds.length;
};
var isDebugModeSelector = (s5) => {
  return s5.settings.isDebugMode;
};
var hasGroupSelectedSelector = (s5) => {
  return s5.document.pageStates[s5.appState.currentPageId].selectedIds.some((id) => s5.document.pages[s5.appState.currentPageId].shapes[id].children !== void 0);
};
var preventDefault = (e5) => e5.stopPropagation();
var _ContextMenu = ({ onBlur, children }) => {
  const container = useContainer();
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)($1b0217ee4a91d156$export$be92b6f5f03c0fe9, { dir: "ltr", children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$41fb9f06171c75f4, { dir: "ltr", children }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$602eac185826482c, { container: container.current, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$7c6e2c02157bb7d2, { onEscapeKeyDown: preventDefault, tabIndex: -1, onBlur, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(MenuContent, { id: "TD-ContextMenu", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(InnerMenu, {}) }) }) })
  ] });
};
var InnerMenu = React16.memo(function InnerMenu2() {
  const app = useTldrawApp();
  const intl = useIntl();
  const numberOfSelectedIds = app.useStore(numberOfSelectedIdsSelector);
  const isDebugMode = app.useStore(isDebugModeSelector);
  const hasGroupSelected = app.useStore(hasGroupSelectedSelector);
  const handleFlipHorizontal = React16.useCallback(() => {
    app.flipHorizontal();
  }, [app]);
  const handleFlipVertical = React16.useCallback(() => {
    app.flipVertical();
  }, [app]);
  const handleDuplicate = React16.useCallback(() => {
    app.duplicate();
  }, [app]);
  const handleLock = React16.useCallback(() => {
    app.toggleLocked();
  }, [app]);
  const handleGroup = React16.useCallback(() => {
    app.group();
  }, [app]);
  const handleMoveToBack = React16.useCallback(() => {
    app.moveToBack();
  }, [app]);
  const handleMoveBackward = React16.useCallback(() => {
    app.moveBackward();
  }, [app]);
  const handleMoveForward = React16.useCallback(() => {
    app.moveForward();
  }, [app]);
  const handleMoveToFront = React16.useCallback(() => {
    app.moveToFront();
  }, [app]);
  const handleDelete = React16.useCallback(() => {
    app.delete();
  }, [app]);
  const handleCut = React16.useCallback(() => {
    app.cut();
  }, [app]);
  const handleCopy = React16.useCallback(() => {
    app.copy();
  }, [app]);
  const handlePaste = React16.useCallback(() => {
    app.paste();
  }, [app]);
  const handleCopySVG = React16.useCallback(() => {
    app.copyImage("svg" /* SVG */, { scale: 1, quality: 1, transparentBackground: false });
  }, [app]);
  const handleCopyPNG = React16.useCallback(() => {
    app.copyImage("png" /* PNG */, { scale: 2, quality: 1, transparentBackground: true });
  }, [app]);
  const handleUndo = React16.useCallback(() => {
    app.undo();
  }, [app]);
  const handleRedo = React16.useCallback(() => {
    app.redo();
  }, [app]);
  const handleExportPNG = React16.useCallback(async () => {
    app.exportImage("png" /* PNG */, { scale: 2, quality: 1 });
  }, [app]);
  const handleExportJPG = React16.useCallback(async () => {
    app.exportImage("jpeg" /* JPG */, { scale: 2, quality: 1 });
  }, [app]);
  const handleExportWEBP = React16.useCallback(async () => {
    app.exportImage("webp" /* WEBP */, { scale: 2, quality: 1 });
  }, [app]);
  const handleExportSVG = React16.useCallback(async () => {
    app.exportImage("svg" /* SVG */, { scale: 1, quality: 1 });
  }, [app]);
  const handleCopyJSON = React16.useCallback(async () => {
    app.copyJson();
  }, [app]);
  const handleExportJSON = React16.useCallback(async () => {
    app.exportJson();
  }, [app]);
  const hasSelection = numberOfSelectedIds > 0;
  const hasTwoOrMore = numberOfSelectedIds > 1;
  const hasThreeOrMore = numberOfSelectedIds > 2;
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children: hasSelection ? /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleDuplicate, kbd: "#D", id: "TD-ContextMenu-Duplicate", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "duplicate" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleFlipHorizontal, kbd: "\u21E7H", id: "TD-ContextMenu-Flip_Horizontal", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "flip.horizontal" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleFlipVertical, kbd: "\u21E7V", id: "TD-ContextMenu-Flip_Vertical", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "flip.vertical" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(CMRowButton, { onClick: handleLock, kbd: "#\u21E7L", id: "TD-ContextMenu- Lock_Unlock", children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "lock" }),
      " / ",
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "unlock" })
    ] }),
    (hasTwoOrMore || hasGroupSelected) && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Divider, {}),
    hasTwoOrMore && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleGroup, kbd: "#G", id: "TD-ContextMenu-Group", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "group" }) }),
    hasGroupSelected && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleGroup, kbd: "#G", id: "TD-ContextMenu-Ungroup", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "ungroup" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Divider, {}),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(ContextMenuSubMenu, { label: intl.formatMessage({ id: "move" }), id: "TD-ContextMenu-Move", children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleMoveToFront, kbd: "\u21E7]", id: "TD-ContextMenu-Move-To_Front", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "to.front" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleMoveForward, kbd: "]", id: "TD-ContextMenu-Move-Forward", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "forward" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleMoveBackward, kbd: "[", id: "TD-ContextMenu-Move-Backward", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "backward" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleMoveToBack, kbd: "\u21E7[", id: "TD-ContextMenu-Move-To_Back", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "back" }) })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(MoveToPageMenu, {}),
    hasTwoOrMore && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AlignDistributeSubMenu, { hasTwoOrMore, hasThreeOrMore }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Divider, {}),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleCut, kbd: "#X", id: "TD-ContextMenu-Cut", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "cut" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleCopy, kbd: "#C", id: "TD-ContextMenu-Copy", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "copy" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handlePaste, kbd: "#V", id: "TD-ContextMenu-Paste", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "paste" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Divider, {}),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(ContextMenuSubMenu, { label: `${intl.formatMessage({ id: "copy.as" })}...`, size: "small", id: "TD-ContextMenu-Copy-As", children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleCopySVG, id: "TD-ContextMenu-Copy-as-SVG", children: "SVG" }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleCopyPNG, id: "TD-ContextMenu-Copy-As-PNG", children: "PNG" }),
      isDebugMode && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleCopyJSON, id: "TD-ContextMenu-Copy_as_JSON", children: "JSON" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(ContextMenuSubMenu, { label: `${intl.formatMessage({ id: "export.as" })}...`, size: "small", id: "TD-ContextMenu-Export", children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleExportSVG, id: "TD-ContextMenu-Export-SVG", children: "SVG" }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleExportPNG, id: "TD-ContextMenu-Export-PNG", children: "PNG" }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleExportJPG, id: "TD-ContextMenu-Export-JPG", children: "JPG" }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleExportWEBP, id: "TD-ContextMenu-Export-WEBP", children: "WEBP" }),
      isDebugMode && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleExportJSON, id: "TD-ContextMenu-Export-JSON", children: "JSON" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Divider, {}),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleDelete, kbd: "\u232B", id: "TD-ContextMenu-Delete", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "delete" }) })
  ] }) : /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handlePaste, kbd: "#V", id: "TD-ContextMenu-Paste", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "paste" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleUndo, kbd: "#Z", id: "TD-ContextMenu-Undo", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "undo" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleRedo, kbd: "#\u21E7Z", id: "TD-ContextMenu-Redo", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "redo" }) })
  ] }) });
});
function AlignDistributeSubMenu({ hasThreeOrMore }) {
  const app = useTldrawApp();
  const alignTop = React16.useCallback(() => {
    app.align("top" /* Top */);
  }, [app]);
  const alignCenterVertical = React16.useCallback(() => {
    app.align("centerVertical" /* CenterVertical */);
  }, [app]);
  const alignBottom = React16.useCallback(() => {
    app.align("bottom" /* Bottom */);
  }, [app]);
  const stretchVertically = React16.useCallback(() => {
    app.stretch("vertical" /* Vertical */);
  }, [app]);
  const distributeVertically = React16.useCallback(() => {
    app.distribute("vertical" /* Vertical */);
  }, [app]);
  const alignLeft = React16.useCallback(() => {
    app.align("left" /* Left */);
  }, [app]);
  const alignCenterHorizontal = React16.useCallback(() => {
    app.align("centerHorizontal" /* CenterHorizontal */);
  }, [app]);
  const alignRight = React16.useCallback(() => {
    app.align("right" /* Right */);
  }, [app]);
  const stretchHorizontally = React16.useCallback(() => {
    app.stretch("horizontal" /* Horizontal */);
  }, [app]);
  const distributeHorizontally = React16.useCallback(() => {
    app.distribute("horizontal" /* Horizontal */);
  }, [app]);
  const container = useContainer();
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)($1b0217ee4a91d156$export$d7a01e11500dfb6f, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMSubTriggerButton, { id: "TD-ContextMenu-Align-Distribute-Trigger", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "align.distribute" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$602eac185826482c, { container: container.current, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$6d4de93b380beddf, { asChild: true, sideOffset: 4, alignOffset: -2, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(StyledGridContent, { numberOfSelected: hasThreeOrMore ? "threeOrMore" : "twoOrMore", children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: alignLeft, id: "TD-ContextMenu-Align_Distribute-AlignLeft", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AlignLeftIcon, {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: alignCenterHorizontal, id: "TD-ContextMenu-Align_Distribute-AlignCenterHorizontal", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AlignCenterHorizontallyIcon, {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: alignRight, id: "TD-ContextMenu-Align_Distribute-AlignRight", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AlignRightIcon, {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: stretchHorizontally, id: "TD-ContextMenu-Align_Distribute-StretchHorizontal", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(StretchHorizontallyIcon, {}) }),
      hasThreeOrMore && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: distributeHorizontally, id: "TD-ContextMenu-Align_Distribute-SpaceEvenlyHorizontal", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SpaceEvenlyHorizontallyIcon, {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: alignTop, id: "TD-ContextMenu-Align_Distribute-AlignTop", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AlignTopIcon, {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: alignCenterVertical, id: "TD-ContextMenu-Align_Distribute-AlignCenterVertical", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AlignCenterVerticallyIcon, {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: alignBottom, id: "TD-ContextMenu-Align_Distribute-AlignBottom", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AlignBottomIcon, {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: stretchVertically, id: "TD-ContextMenu-Align_Distribute-StretchVertical", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(StretchVerticallyIcon, {}) }),
      hasThreeOrMore && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: distributeVertically, id: "TD-ContextMenu-Align_Distribute-SpaceEvenlyVertical", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SpaceEvenlyVerticallyIcon, {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMArrow, { offset: 13 })
    ] }) }) })
  ] });
}
var StyledGridContent = styled(MenuContent, {
  display: "grid",
  variants: {
    numberOfSelected: {
      threeOrMore: {
        gridTemplateColumns: "repeat(5, auto)"
      },
      twoOrMore: {
        gridTemplateColumns: "repeat(4, auto)"
      }
    }
  }
});
var currentPageIdSelector = (s5) => s5.appState.currentPageId;
var documentPagesSelector = (s5) => s5.document.pages;
function MoveToPageMenu() {
  const app = useTldrawApp();
  const currentPageId = app.useStore(currentPageIdSelector);
  const documentPages = app.useStore(documentPagesSelector);
  const sorted = Object.values(documentPages).sort((a7, b6) => (a7.childIndex || 0) - (b6.childIndex || 0)).filter((a7) => a7.id !== currentPageId);
  const container = useContainer();
  if (sorted.length === 0)
    return null;
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)($1b0217ee4a91d156$export$d7a01e11500dfb6f, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMSubTriggerButton, { children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: "move.to.page" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$602eac185826482c, { container: container.current, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$6d4de93b380beddf, { sideOffset: 4, alignOffset: -2, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(MenuContent, { children: [
      sorted.map(({ id, name }, index2) => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { disabled: id === currentPageId, onClick: () => app.moveToPage(id), children: name || `Page ${index2}` }, id)),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMArrow, { offset: 13 })
    ] }) }) })
  ] });
}
function ContextMenuSubMenu({ children, label, size, id }) {
  const container = useContainer();
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)($1b0217ee4a91d156$export$d7a01e11500dfb6f, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMSubTriggerButton, { children: label }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$602eac185826482c, { container: container.current, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$6d4de93b380beddf, { sideOffset: 4, alignOffset: -2, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(MenuContent, { size, children: [
      children,
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMArrow, { offset: 13 })
    ] }) }) })
  ] });
}
var CMArrow = styled($1b0217ee4a91d156$export$f47d0a58228a61e2, {
  fill: "$panel"
});
function CMIconButton({ onSelect, ...rest }) {
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$16a26dc176a49100, { dir: "ltr", onSelect, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(ToolButton, { ...rest }) });
}
var CMRowButton = ({ id, ...rest }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$16a26dc176a49100, { asChild: true, id, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(RowButton, { ...rest }) });
};
var CMSubTriggerButton = ({ id, ...rest }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$2ea8a7a591ac5eac, { asChild: true, id, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(RowButton, { hasArrow: true, ...rest }) });
};
var ContextMenu = React16.memo(_ContextMenu);

// src/components/Tldraw/components/Primitives/IconButton/IconButton.tsx
var IconButton = styled("button", {
  position: "relative",
  height: "32px",
  width: "32px",
  backgroundColor: "$panel",
  borderRadius: "4px",
  padding: "0",
  margin: "0",
  outline: "none",
  border: "none",
  pointerEvents: "all",
  fontSize: "$0",
  color: "$text",
  cursor: "pointer",
  display: "grid",
  alignItems: "center",
  justifyContent: "center",
  "& > *": {
    gridRow: 1,
    gridColumn: 1
  },
  "&:disabled": {
    opacity: "0.5"
  },
  "& > span": {
    width: "100%",
    height: "100%",
    display: "flex",
    alignItems: "center"
  },
  variants: {
    bp: {
      mobile: {
        backgroundColor: "transparent"
      },
      small: {
        "&:hover:not(:disabled)": {
          backgroundColor: "$hover"
        }
      }
    },
    size: {
      small: {
        height: 32,
        width: 32,
        "& svg:nth-of-type(1)": {
          height: "16px",
          width: "16px"
        }
      },
      medium: {
        height: 44,
        width: 44,
        "& svg:nth-of-type(1)": {
          height: "18px",
          width: "18px"
        }
      },
      large: {
        height: 44,
        width: 44,
        "& svg:nth-of-type(1)": {
          height: "20px",
          width: "20px"
        }
      }
    },
    isActive: {
      true: {
        color: "$selected"
      }
    }
  }
});

// src/components/Tldraw/components/FocusButton/FocusButton.tsx
var import_jsx_runtime8 = require("react/jsx-runtime");
function FocusButton({ onSelect }) {
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(StyledButtonContainer, { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(IconButton, { onClick: onSelect, children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(DotFilledIcon, {}) }) });
}
var StyledButtonContainer = styled("div", {
  opacity: 1,
  zIndex: 100,
  backgroundColor: "transparent",
  "& svg": {
    color: "$text"
  },
  "&:hover svg": {
    color: "$text"
  }
});

// src/components/Tldraw/components/Loading/Loading.tsx
var import_jsx_runtime9 = require("react/jsx-runtime");
var loadingSelector = (s5) => s5.appState.isLoading;
function Loading() {
  const app = useTldrawApp();
  const isLoading = app.useStore(loadingSelector);
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(StyledLoadingPanelContainer, { hidden: !isLoading, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(FormattedMessage, { id: "loading", values: { dots: "..." } }) });
}
var StyledLoadingPanelContainer = styled("div", {
  position: "absolute",
  top: 0,
  left: "50%",
  transform: `translate(-50%, 0)`,
  borderBottomLeftRadius: "12px",
  borderBottomRightRadius: "12px",
  padding: "8px 16px",
  fontFamily: "var(--fonts-ui)",
  fontSize: "var(--fontSizes-1)",
  boxShadow: "var(--shadows-panel)",
  backgroundColor: "white",
  zIndex: 200,
  pointerEvents: "none",
  "& > div > *": {
    pointerEvents: "all"
  },
  variants: {
    transform: {
      hidden: {
        transform: `translate(-50%, 100%)`
      },
      visible: {
        transform: `translate(-50%, 0%)`
      }
    }
  }
});

// node_modules/.pnpm/@radix-ui+react-alert-dialog@1.0.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-alert-dialog/dist/index.mjs
var import_react38 = require("react");

// node_modules/.pnpm/@radix-ui+react-dialog@1.0.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-dialog/dist/index.mjs
var import_react37 = require("react");
var $5d3850c4d0b4e6c7$var$DIALOG_NAME = "Dialog";
var [$5d3850c4d0b4e6c7$var$createDialogContext, $5d3850c4d0b4e6c7$export$cc702773b8ea3e41] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($5d3850c4d0b4e6c7$var$DIALOG_NAME);
var [$5d3850c4d0b4e6c7$var$DialogProvider, $5d3850c4d0b4e6c7$var$useDialogContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$DIALOG_NAME);
var $5d3850c4d0b4e6c7$export$3ddf2d174ce01153 = (props) => {
  const { __scopeDialog, children, open: openProp, defaultOpen, onOpenChange, modal = true } = props;
  const triggerRef = (0, import_react37.useRef)(null);
  const contentRef = (0, import_react37.useRef)(null);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogProvider, {
    scope: __scopeDialog,
    triggerRef,
    contentRef,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    titleId: $1746a345f3d73bb7$export$f680877a34711e37(),
    descriptionId: $1746a345f3d73bb7$export$f680877a34711e37(),
    open,
    onOpenChange: setOpen,
    onOpenToggle: (0, import_react37.useCallback)(
      () => setOpen(
        (prevOpen) => !prevOpen
      ),
      [
        setOpen
      ]
    ),
    modal
  }, children);
};
var $5d3850c4d0b4e6c7$var$TRIGGER_NAME = "DialogTrigger";
var $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88 = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {
  const { __scopeDialog, ...triggerProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$TRIGGER_NAME, __scopeDialog);
  const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.triggerRef);
  return /* @__PURE__ */ (0, import_react37.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": context.open,
    "aria-controls": context.contentId,
    "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
  }, triggerProps, {
    ref: composedTriggerRef,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle)
  }));
});
var $5d3850c4d0b4e6c7$var$PORTAL_NAME = "DialogPortal";
var [$5d3850c4d0b4e6c7$var$PortalProvider, $5d3850c4d0b4e6c7$var$usePortalContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, {
  forceMount: void 0
});
var $5d3850c4d0b4e6c7$export$dad7c95542bacce0 = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, __scopeDialog);
  return /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$PortalProvider, {
    scope: __scopeDialog,
    forceMount
  }, import_react37.Children.map(
    children,
    (child) => /* @__PURE__ */ (0, import_react37.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
      present: forceMount || context.open
    }, /* @__PURE__ */ (0, import_react37.createElement)($f1701beae083dbae$export$602eac185826482c, {
      asChild: true,
      container
    }, child))
  ));
};
var $5d3850c4d0b4e6c7$var$OVERLAY_NAME = "DialogOverlay";
var $5d3850c4d0b4e6c7$export$bd1d06c79be19e17 = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {
  const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);
  const { forceMount = portalContext.forceMount, ...overlayProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);
  return context.modal ? /* @__PURE__ */ (0, import_react37.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogOverlayImpl, _extends({}, overlayProps, {
    ref: forwardedRef
  }))) : null;
});
var $5d3850c4d0b4e6c7$var$DialogOverlayImpl = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {
  const { __scopeDialog, ...overlayProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, __scopeDialog);
  return (
    // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
    // ie. when `Overlay` and `Content` are siblings
    /* @__PURE__ */ (0, import_react37.createElement)(Combination_default, {
      as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
      allowPinchZoom: true,
      shards: [
        context.contentRef
      ]
    }, /* @__PURE__ */ (0, import_react37.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
      "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
    }, overlayProps, {
      ref: forwardedRef,
      style: {
        pointerEvents: "auto",
        ...overlayProps.style
      }
    })))
  );
});
var $5d3850c4d0b4e6c7$var$CONTENT_NAME = "DialogContent";
var $5d3850c4d0b4e6c7$export$b6d9565de1e068cf = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {
  const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
  return /* @__PURE__ */ (0, import_react37.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, context.modal ? /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogContentModal, _extends({}, contentProps, {
    ref: forwardedRef
  })) : /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogContentNonModal, _extends({}, contentProps, {
    ref: forwardedRef
  })));
});
var $5d3850c4d0b4e6c7$var$DialogContentModal = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
  const contentRef = (0, import_react37.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.contentRef, contentRef);
  (0, import_react37.useEffect)(() => {
    const content = contentRef.current;
    if (content)
      return hideOthers(content);
  }, []);
  return /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends({}, props, {
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
      var _context$triggerRef$c;
      event.preventDefault();
      (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
    }),
    onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      if (isRightClick)
        event.preventDefault();
    }),
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocusOutside,
      (event) => event.preventDefault()
    )
  }));
});
var $5d3850c4d0b4e6c7$var$DialogContentNonModal = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
  const hasInteractedOutsideRef = (0, import_react37.useRef)(false);
  const hasPointerDownOutsideRef = (0, import_react37.useRef)(false);
  return /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends({}, props, {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      var _props$onCloseAutoFoc;
      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
      if (!event.defaultPrevented) {
        var _context$triggerRef$c2;
        if (!hasInteractedOutsideRef.current)
          (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
      hasPointerDownOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      var _props$onInteractOuts, _context$triggerRef$c3;
      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
      if (!event.defaultPrevented) {
        hasInteractedOutsideRef.current = true;
        if (event.detail.originalEvent.type === "pointerdown")
          hasPointerDownOutsideRef.current = true;
      }
      const target = event.target;
      const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
      if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current)
        event.preventDefault();
    }
  }));
});
var $5d3850c4d0b4e6c7$var$DialogContentImpl = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {
  const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, __scopeDialog);
  const contentRef = (0, import_react37.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
  return /* @__PURE__ */ (0, import_react37.createElement)(import_react37.Fragment, null, /* @__PURE__ */ (0, import_react37.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {
    asChild: true,
    loop: true,
    trapped: trapFocus,
    onMountAutoFocus: onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, /* @__PURE__ */ (0, import_react37.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, _extends({
    role: "dialog",
    id: context.contentId,
    "aria-describedby": context.descriptionId,
    "aria-labelledby": context.titleId,
    "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
  }, contentProps, {
    ref: composedRefs,
    onDismiss: () => context.onOpenChange(false)
  }))), false);
});
var $5d3850c4d0b4e6c7$var$TITLE_NAME = "DialogTitle";
var $5d3850c4d0b4e6c7$var$DESCRIPTION_NAME = "DialogDescription";
var $5d3850c4d0b4e6c7$export$94e94c2ec2c954d5 = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {
  const { __scopeDialog, ...descriptionProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$DESCRIPTION_NAME, __scopeDialog);
  return /* @__PURE__ */ (0, import_react37.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.p, _extends({
    id: context.descriptionId
  }, descriptionProps, {
    ref: forwardedRef
  }));
});
var $5d3850c4d0b4e6c7$var$CLOSE_NAME = "DialogClose";
var $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {
  const { __scopeDialog, ...closeProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CLOSE_NAME, __scopeDialog);
  return /* @__PURE__ */ (0, import_react37.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button"
  }, closeProps, {
    ref: forwardedRef,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onClick,
      () => context.onOpenChange(false)
    )
  }));
});
function $5d3850c4d0b4e6c7$var$getState(open) {
  return open ? "open" : "closed";
}
var $5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME = "DialogTitleWarning";
var [$5d3850c4d0b4e6c7$export$69b62a49393917d6, $5d3850c4d0b4e6c7$var$useWarningContext] = $c512c27ab02ef895$export$fd42f52fd3ae1109($5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME, {
  contentName: $5d3850c4d0b4e6c7$var$CONTENT_NAME,
  titleName: $5d3850c4d0b4e6c7$var$TITLE_NAME,
  docsSlug: "dialog"
});
var $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9 = $5d3850c4d0b4e6c7$export$3ddf2d174ce01153;
var $5d3850c4d0b4e6c7$export$41fb9f06171c75f4 = $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88;
var $5d3850c4d0b4e6c7$export$602eac185826482c = $5d3850c4d0b4e6c7$export$dad7c95542bacce0;
var $5d3850c4d0b4e6c7$export$c6fdb837b070b4ff = $5d3850c4d0b4e6c7$export$bd1d06c79be19e17;
var $5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2 = $5d3850c4d0b4e6c7$export$b6d9565de1e068cf;
var $5d3850c4d0b4e6c7$export$393edc798c47379d = $5d3850c4d0b4e6c7$export$94e94c2ec2c954d5;
var $5d3850c4d0b4e6c7$export$f39c2d165cd861fe = $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac;

// node_modules/.pnpm/@radix-ui+react-alert-dialog@1.0.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-alert-dialog/dist/index.mjs
var $905f4ae918aab1aa$var$ROOT_NAME = "AlertDialog";
var [$905f4ae918aab1aa$var$createAlertDialogContext, $905f4ae918aab1aa$export$b8891880751c2c5b] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($905f4ae918aab1aa$var$ROOT_NAME, [
  $5d3850c4d0b4e6c7$export$cc702773b8ea3e41
]);
var $905f4ae918aab1aa$var$useDialogScope = $5d3850c4d0b4e6c7$export$cc702773b8ea3e41();
var $905f4ae918aab1aa$export$de466dd8317b0b75 = (props) => {
  const { __scopeAlertDialog, ...alertDialogProps } = props;
  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9, _extends({}, dialogScope, alertDialogProps, {
    modal: true
  }));
};
var $905f4ae918aab1aa$export$6edd7a623ef0f40b = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {
  const { __scopeAlertDialog, ...triggerProps } = props;
  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$41fb9f06171c75f4, _extends({}, dialogScope, triggerProps, {
    ref: forwardedRef
  }));
});
var $905f4ae918aab1aa$export$660f2bfdb986706c = (props) => {
  const { __scopeAlertDialog, ...portalProps } = props;
  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$602eac185826482c, _extends({}, dialogScope, portalProps));
};
var $905f4ae918aab1aa$export$a707a4895ce23256 = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {
  const { __scopeAlertDialog, ...overlayProps } = props;
  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$c6fdb837b070b4ff, _extends({}, dialogScope, overlayProps, {
    ref: forwardedRef
  }));
});
var $905f4ae918aab1aa$var$CONTENT_NAME = "AlertDialogContent";
var [$905f4ae918aab1aa$var$AlertDialogContentProvider, $905f4ae918aab1aa$var$useAlertDialogContentContext] = $905f4ae918aab1aa$var$createAlertDialogContext($905f4ae918aab1aa$var$CONTENT_NAME);
var $905f4ae918aab1aa$export$94e6af45f0af4efd = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {
  const { __scopeAlertDialog, children, ...contentProps } = props;
  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
  const contentRef = (0, import_react38.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
  const cancelRef = (0, import_react38.useRef)(null);
  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$69b62a49393917d6, {
    contentName: $905f4ae918aab1aa$var$CONTENT_NAME,
    titleName: $905f4ae918aab1aa$var$TITLE_NAME,
    docsSlug: "alert-dialog"
  }, /* @__PURE__ */ (0, import_react38.createElement)($905f4ae918aab1aa$var$AlertDialogContentProvider, {
    scope: __scopeAlertDialog,
    cancelRef
  }, /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2, _extends({
    role: "alertdialog"
  }, dialogScope, contentProps, {
    ref: composedRefs,
    onOpenAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onOpenAutoFocus, (event) => {
      var _cancelRef$current;
      event.preventDefault();
      (_cancelRef$current = cancelRef.current) === null || _cancelRef$current === void 0 || _cancelRef$current.focus({
        preventScroll: true
      });
    }),
    onPointerDownOutside: (event) => event.preventDefault(),
    onInteractOutside: (event) => event.preventDefault()
  }), /* @__PURE__ */ (0, import_react38.createElement)($5e63c961fc1ce211$export$d9f1ccf0bdb05d45, null, children), false)));
});
var $905f4ae918aab1aa$var$TITLE_NAME = "AlertDialogTitle";
var $905f4ae918aab1aa$export$a23b55cde55ad9a5 = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {
  const { __scopeAlertDialog, ...descriptionProps } = props;
  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$393edc798c47379d, _extends({}, dialogScope, descriptionProps, {
    ref: forwardedRef
  }));
});
var $905f4ae918aab1aa$export$b454f818c58ee85d = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {
  const { __scopeAlertDialog, ...actionProps } = props;
  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$f39c2d165cd861fe, _extends({}, dialogScope, actionProps, {
    ref: forwardedRef
  }));
});
var $905f4ae918aab1aa$var$CANCEL_NAME = "AlertDialogCancel";
var $905f4ae918aab1aa$export$2f67a923571aaea0 = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {
  const { __scopeAlertDialog, ...cancelProps } = props;
  const { cancelRef } = $905f4ae918aab1aa$var$useAlertDialogContentContext($905f4ae918aab1aa$var$CANCEL_NAME, __scopeAlertDialog);
  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
  const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, cancelRef);
  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$f39c2d165cd861fe, _extends({}, dialogScope, cancelProps, {
    ref
  }));
});
var $905f4ae918aab1aa$export$be92b6f5f03c0fe9 = $905f4ae918aab1aa$export$de466dd8317b0b75;
var $905f4ae918aab1aa$export$41fb9f06171c75f4 = $905f4ae918aab1aa$export$6edd7a623ef0f40b;
var $905f4ae918aab1aa$export$602eac185826482c = $905f4ae918aab1aa$export$660f2bfdb986706c;
var $905f4ae918aab1aa$export$c6fdb837b070b4ff = $905f4ae918aab1aa$export$a707a4895ce23256;
var $905f4ae918aab1aa$export$7c6e2c02157bb7d2 = $905f4ae918aab1aa$export$94e6af45f0af4efd;
var $905f4ae918aab1aa$export$e19cd5f9376f8cee = $905f4ae918aab1aa$export$b454f818c58ee85d;
var $905f4ae918aab1aa$export$848c9b7ead0df967 = $905f4ae918aab1aa$export$2f67a923571aaea0;
var $905f4ae918aab1aa$export$393edc798c47379d = $905f4ae918aab1aa$export$a23b55cde55ad9a5;

// src/components/Tldraw/components/Primitives/AlertDialog/AlertDialog.tsx
var import_jsx_runtime10 = require("react/jsx-runtime");
function Content({ children, onClose, container }) {
  const handleKeyDown = (event) => {
    switch (event.key) {
      case "Escape": {
        onClose?.();
        break;
      }
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)($905f4ae918aab1aa$export$602eac185826482c, { container, children: [
    /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(StyledOverlay, {}),
    /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(StyledContent2, { onKeyDown: handleKeyDown, children })
  ] });
}
var StyledDescription = styled($905f4ae918aab1aa$export$393edc798c47379d, {
  marginBottom: 20,
  color: "$text",
  fontSize: "$2",
  lineHeight: 1.5,
  textAlign: "center",
  maxWidth: "62%",
  minWidth: 0,
  alignSelf: "center"
});
var AlertDialogRoot = $905f4ae918aab1aa$export$be92b6f5f03c0fe9;
var AlertDialogContent = Content;
var AlertDialogDescription = StyledDescription;
var AlertDialogAction = $905f4ae918aab1aa$export$e19cd5f9376f8cee;
var AlertDialogCancel = $905f4ae918aab1aa$export$848c9b7ead0df967;
var AlertDialog = ({ container }) => {
  const { setDialogState, dialogState, onCancel, onNo, onYes } = useDialog();
  const intl = useIntl();
  const descriptions = {
    saveFirstTime: intl.formatMessage({ id: "dialog.save.firsttime" }),
    saveAgain: intl.formatMessage({ id: "dialog.save.again" })
  };
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(AlertDialogRoot, { open: dialogState !== null, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(AlertDialogContent, { onClose: () => setDialogState(null), container, children: [
    dialogState && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(AlertDialogDescription, { children: descriptions[dialogState] }),
    /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(
      "div",
      {
        style: {
          width: "100%",
          gap: "$6",
          display: "flex",
          justifyContent: "space-between"
        },
        children: [
          onCancel != void 0 && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(AlertDialogCancel, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
            Button,
            {
              css: { color: "$text" },
              onClick: () => {
                onCancel();
                setDialogState(null);
              },
              children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(FormattedMessage, { id: "dialog.cancel" })
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("div", { style: { flexShrink: 0 }, children: [
            onNo != void 0 && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(AlertDialogAction, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
              Button,
              {
                onClick: () => {
                  onNo();
                  setDialogState(null);
                },
                children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(FormattedMessage, { id: "dialog.no" })
              }
            ) }),
            onYes != void 0 && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(AlertDialogAction, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
              Button,
              {
                css: { backgroundColor: "#2F80ED", color: "White" },
                onClick: () => {
                  onYes();
                  setDialogState(null);
                },
                children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(FormattedMessage, { id: "dialog.yes" })
              }
            ) })
          ] })
        ]
      }
    )
  ] }) });
};
var StyledOverlay = styled($905f4ae918aab1aa$export$c6fdb837b070b4ff, {
  position: "fixed",
  inset: 0,
  backgroundColor: "rgba(0, 0, 0, .15)",
  pointerEvents: "all"
});
var StyledDialogOverlay = styled($905f4ae918aab1aa$export$c6fdb837b070b4ff, {
  backgroundColor: "rgba(0, 0, 0, .15)",
  position: "absolute",
  pointerEvents: "all",
  inset: 0
});
var StyledContent2 = styled($905f4ae918aab1aa$export$7c6e2c02157bb7d2, {
  position: "fixed",
  font: "$ui",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  width: "max-content",
  padding: "$3",
  pointerEvents: "all",
  backgroundColor: "$panel",
  borderRadius: "$3",
  display: "flex",
  flexDirection: "column",
  justifyContent: "center",
  fontFamily: "$ui",
  border: "1px solid $panelContrast",
  boxShadow: "$panel"
});
var Button = styled("button", {
  all: "unset",
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  borderRadius: "$2",
  padding: "0 15px",
  fontSize: "$1",
  lineHeight: 1,
  fontWeight: "normal",
  height: 36,
  color: "$text",
  cursor: "pointer",
  minWidth: 48
});

// src/components/Tldraw/components/ToolsPanel/ToolsPanel.tsx
var React22 = __toESM(require("react"));

// src/components/Tldraw/components/ToolsPanel/ActionButton.tsx
var React17 = __toESM(require("react"));

// src/components/Tldraw/components/Primitives/DropdownMenu/DMItem.tsx
var import_jsx_runtime11 = require("react/jsx-runtime");
function DMItem({ onSelect, id, ...rest }) {
  return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { dir: "ltr", asChild: true, onSelect, id, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(RowButton, { ...rest }) });
}

// src/components/Tldraw/components/preventEvent.ts
var preventEvent = (e5) => e5.preventDefault();

// src/components/Tldraw/components/Primitives/DropdownMenu/DMCheckboxItem.tsx
var import_jsx_runtime12 = require("react/jsx-runtime");
function DMCheckboxItem({ checked, disabled = false, variant, onCheckedChange, kbd, id, children }) {
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)($d08ef79370b62062$export$16ce288f89fa631c, { dir: "ltr", onSelect: preventEvent, onCheckedChange, checked, disabled, asChild: true, id, children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(RowButton, { kbd, variant, hasIndicator: true, children }) });
}

// src/components/Tldraw/components/stopPropagation.ts
var stopPropagation3 = (e5) => e5.stopPropagation();

// src/components/Tldraw/components/Primitives/DropdownMenu/DMContent.tsx
var import_jsx_runtime13 = require("react/jsx-runtime");
function DMContent({ sideOffset = 4, alignOffset = 0, children, align, variant, id, overflow = false, side = "bottom" }) {
  const container = useContainer();
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)($d08ef79370b62062$export$602eac185826482c, { container: container.current, dir: "ltr", children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)($d08ef79370b62062$export$7c6e2c02157bb7d2, { align, alignOffset, sideOffset, onEscapeKeyDown: stopPropagation3, asChild: true, id, side, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(StyledContent3, { variant, overflow, children }) }) });
}
var StyledContent3 = styled(MenuContent, {
  width: "fit-content",
  height: "fit-content",
  minWidth: 0,
  maxHeight: "100vh",
  overflowY: "auto",
  overflowX: "hidden",
  "&::webkit-scrollbar": {
    display: "none"
  },
  "-ms-overflow-style": "none",
  scrollbarWidth: "none",
  variants: {
    variant: {
      horizontal: {
        flexDirection: "row"
      },
      menu: {
        minWidth: 128
      }
    },
    overflow: {
      true: {
        maxHeight: "60vh"
      }
    }
  }
});

// src/components/Tldraw/components/Primitives/DropdownMenu/DMDivider.tsx
var DMDivider = styled($d08ef79370b62062$export$1ff3c3f08ae963c0, {
  backgroundColor: "$hover",
  height: 1,
  marginTop: "$2",
  marginRight: "-$2",
  marginBottom: "$2",
  marginLeft: "-$2"
});

// src/components/Tldraw/components/Primitives/DropdownMenu/DMRadioItem.tsx
var DMRadioItem = styled($d08ef79370b62062$export$371ab307eab489c0, {
  height: "32px",
  width: "32px",
  backgroundColor: "$panel",
  borderRadius: "4px",
  padding: "0",
  margin: "0",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  outline: "none",
  border: "none",
  pointerEvents: "all",
  cursor: "pointer",
  variants: {
    isActive: {
      true: {
        backgroundColor: "$selected",
        color: "white"
      },
      false: {}
    },
    bp: {
      mobile: {},
      small: {}
    }
  },
  compoundVariants: [
    {
      isActive: false,
      bp: "small",
      css: {
        "&:focus": {
          backgroundColor: "$hover"
        },
        "&:hover:not(:disabled)": {
          backgroundColor: "$hover"
        }
      }
    }
  ]
});

// src/components/Tldraw/components/Primitives/DropdownMenu/DMSubMenu.tsx
var import_jsx_runtime14 = require("react/jsx-runtime");
function DMSubMenu({ children, size, overflow = false, disabled = false, label, id }) {
  return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)($d08ef79370b62062$export$d7a01e11500dfb6f, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime14.jsx)($d08ef79370b62062$export$2ea8a7a591ac5eac, { dir: "ltr", asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(RowButton, { disabled, hasArrow: true, children: label }) }),
    /* @__PURE__ */ (0, import_jsx_runtime14.jsx)($d08ef79370b62062$export$6d4de93b380beddf, { asChild: true, sideOffset: 4, alignOffset: -4, children: /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)(MenuContent, { size, overflow, children: [
      children,
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)($d08ef79370b62062$export$21b07c8f274aebd5, { offset: 13 })
    ] }) })
  ] }, id);
}

// src/components/Tldraw/components/Primitives/DropdownMenu/DMTriggerIcon.tsx
var import_jsx_runtime15 = require("react/jsx-runtime");
function DMTriggerIcon({ id, children, ...rest }) {
  return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { asChild: true, id, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { ...rest, children }) });
}

// src/components/Tldraw/components/ToolsPanel/ActionButton.tsx
var import_jsx_runtime16 = require("react/jsx-runtime");
var dockPositionState = (s5) => s5.settings.dockPosition;
var selectedShapesCountSelector = (s5) => s5.document.pageStates[s5.appState.currentPageId].selectedIds.length;
var isAllLockedSelector = (s5) => {
  const page = s5.document.pages[s5.appState.currentPageId];
  const { selectedIds } = s5.document.pageStates[s5.appState.currentPageId];
  return selectedIds.every((id) => page.shapes[id].isLocked);
};
var isAllAspectLockedSelector = (s5) => {
  const page = s5.document.pages[s5.appState.currentPageId];
  const { selectedIds } = s5.document.pageStates[s5.appState.currentPageId];
  return selectedIds.every((id) => page.shapes[id].isAspectRatioLocked);
};
var isAllGroupedSelector = (s5) => {
  const page = s5.document.pages[s5.appState.currentPageId];
  const selectedShapes = s5.document.pageStates[s5.appState.currentPageId].selectedIds.map((id) => page.shapes[id]);
  return selectedShapes.every(
    (shape) => shape.children !== void 0 || shape.parentId === selectedShapes[0].parentId && selectedShapes[0].parentId !== s5.appState.currentPageId
  );
};
var hasSelectionSelector = (s5) => {
  const { selectedIds } = s5.document.pageStates[s5.appState.currentPageId];
  return selectedIds.length > 0;
};
var hasMultipleSelectionSelector = (s5) => {
  const { selectedIds } = s5.document.pageStates[s5.appState.currentPageId];
  return selectedIds.length > 1;
};
function ActionButton() {
  const app = useTldrawApp();
  const intl = useIntl();
  const isAllLocked = app.useStore(isAllLockedSelector);
  const isAllAspectLocked = app.useStore(isAllAspectLockedSelector);
  const isAllGrouped = app.useStore(isAllGroupedSelector);
  const hasSelection = app.useStore(hasSelectionSelector);
  const hasMultipleSelection = app.useStore(hasMultipleSelectionSelector);
  const selectedShapesCount = app.useStore(selectedShapesCountSelector);
  const dockPosition = app.useStore(dockPositionState);
  const hasTwoOrMore = selectedShapesCount > 1;
  const hasThreeOrMore = selectedShapesCount > 2;
  const handleRotate = React17.useCallback(() => {
    app.rotate();
  }, [app]);
  const handleDuplicate = React17.useCallback(() => {
    app.duplicate();
  }, [app]);
  const handleToggleLocked = React17.useCallback(() => {
    app.toggleLocked();
  }, [app]);
  const handleToggleAspectRatio = React17.useCallback(() => {
    app.toggleAspectRatioLocked();
  }, [app]);
  const handleGroup = React17.useCallback(() => {
    app.group();
  }, [app]);
  const handleMoveToBack = React17.useCallback(() => {
    app.moveToBack();
  }, [app]);
  const handleMoveBackward = React17.useCallback(() => {
    app.moveBackward();
  }, [app]);
  const handleMoveForward = React17.useCallback(() => {
    app.moveForward();
  }, [app]);
  const handleMoveToFront = React17.useCallback(() => {
    app.moveToFront();
  }, [app]);
  const handleResetAngle = React17.useCallback(() => {
    app.setShapeProps({ rotation: 0 });
  }, [app]);
  const alignTop = React17.useCallback(() => {
    app.align("top" /* Top */);
  }, [app]);
  const alignCenterVertical = React17.useCallback(() => {
    app.align("centerVertical" /* CenterVertical */);
  }, [app]);
  const alignBottom = React17.useCallback(() => {
    app.align("bottom" /* Bottom */);
  }, [app]);
  const stretchVertically = React17.useCallback(() => {
    app.stretch("vertical" /* Vertical */);
  }, [app]);
  const distributeVertically = React17.useCallback(() => {
    app.distribute("vertical" /* Vertical */);
  }, [app]);
  const alignLeft = React17.useCallback(() => {
    app.align("left" /* Left */);
  }, [app]);
  const alignCenterHorizontal = React17.useCallback(() => {
    app.align("centerHorizontal" /* CenterHorizontal */);
  }, [app]);
  const alignRight = React17.useCallback(() => {
    app.align("right" /* Right */);
  }, [app]);
  const stretchHorizontally = React17.useCallback(() => {
    app.stretch("horizontal" /* Horizontal */);
  }, [app]);
  const distributeHorizontally = React17.useCallback(() => {
    app.distribute("horizontal" /* Horizontal */);
  }, [app]);
  const handleMenuOpenChange = React17.useCallback(
    (open) => {
      app.setMenuOpen(open);
    },
    [app]
  );
  const contentSide = dockPosition === "bottom" || dockPosition === "top" ? "top" : dockPosition;
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: "ltr", onOpenChange: handleMenuOpenChange, children: [
    /* @__PURE__ */ (0, import_jsx_runtime16.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { dir: "ltr", asChild: true, id: "TD-Tools-Dots", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { variant: "circle", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(DotsHorizontalIcon, {}) }) }),
    /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(DMContent, { sideOffset: 16, side: contentSide, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(ButtonsRow, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "duplicate" }), kbd: `#D`, id: "TD-Tools-Copy", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleDuplicate, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(CopyIcon, {}) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "rotate" }), id: "TD-Tools-Rotate", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleRotate, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(RotateCounterClockwiseIcon, {}) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: isAllLocked ? "unlock" : "lock" }), kbd: `#L`, id: "TD-Tools-Lock", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleToggleLocked, children: isAllLocked ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(LockClosedIcon, {}) : /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(LockOpen1Icon, {}) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
          Tooltip,
          {
            label: intl.formatMessage({
              id: isAllAspectLocked ? "unlock.aspect.ratio" : "lock.aspect.ratio"
            }),
            id: "TD-Tools-AspectRatio",
            children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleToggleAspectRatio, children: isAllAspectLocked ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AspectRatioIcon, {}) : /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(BoxIcon, {}) })
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "group" }), kbd: `#G`, id: "TD-Tools-Group", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection || !isAllGrouped && !hasMultipleSelection, onClick: handleGroup, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(GroupIcon, {}) }) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(ButtonsRow, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "move.to.back" }), kbd: `#\u21E7[`, id: "TD-Tools-PinBottom", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleMoveToBack, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(PinBottomIcon, {}) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "move.backward" }), kbd: `#[`, id: "TD-Tools-ArrowDown", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleMoveBackward, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ArrowDownIcon, {}) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "move.forward" }), kbd: `#]`, id: "TD-Tools-ArrowUp", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleMoveForward, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ArrowUpIcon, {}) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "move.to.front" }), kbd: `#\u21E7]`, id: "TD-Tools-PinTop", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleMoveToFront, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(PinTopIcon, {}) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "reset.angle" }), id: "TD-Tools-ResetAngle", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleResetAngle, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AngleIcon, {}) }) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Divider, {}),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(ButtonsRow, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "align.left" }), id: "TD-Tools-AlignLeft", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignLeft, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AlignLeftIcon, {}) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "align.center.x" }), id: "TD-Tools-AlignCenterHorizontal", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignCenterHorizontal, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AlignCenterHorizontallyIcon, {}) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "align.right" }), id: "TD-Tools-AlignRight", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignRight, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AlignRightIcon, {}) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "stretch.x" }), id: "TD-Tools-StretchHorizontal", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: stretchHorizontally, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(StretchHorizontallyIcon, {}) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "distribute.x" }), id: "TD-Tools-SpaceEvenlyHorizontal", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasThreeOrMore, onClick: distributeHorizontally, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(SpaceEvenlyHorizontallyIcon, {}) }) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(ButtonsRow, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "align.top" }), id: "TD-Tools-AlignTop", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignTop, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AlignTopIcon, {}) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "align.center.y" }), id: "TD-Tools-AlignCenterVertical", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignCenterVertical, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AlignCenterVerticallyIcon, {}) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "align.bottom" }), id: "TD-Tools-AlignBottom", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignBottom, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AlignBottomIcon, {}) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "stretch.y" }), id: "TD-Tools-StretchVertical", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: stretchVertically, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(StretchVerticallyIcon, {}) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: "distribute.y" }), id: "TD-Tools-SpaceEvenlyVertical", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasThreeOrMore, onClick: distributeVertically, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(SpaceEvenlyVerticallyIcon, {}) }) })
      ] })
    ] }) })
  ] });
}
var ButtonsRow = styled("div", {
  position: "relative",
  display: "flex",
  width: "100%",
  background: "none",
  border: "none",
  cursor: "pointer",
  outline: "none",
  alignItems: "center",
  justifyContent: "flex-start",
  padding: 0
});

// src/components/Tldraw/components/ToolsPanel/BackToContent.tsx
var React18 = __toESM(require("react"));
var import_jsx_runtime17 = require("react/jsx-runtime");
var isEmptyCanvasSelector = (s5) => {
  return s5.appState.isEmptyCanvas && Object.keys(s5.document.pages[s5.appState.currentPageId].shapes).length > 0;
};
var isDebugModeSelector2 = (s5) => s5.settings.isDebugMode;
var dockPositionState2 = (s5) => s5.settings.dockPosition;
var BackToContent = React18.memo(function BackToContent2() {
  const app = useTldrawApp();
  const isEmptyCanvas = app.useStore(isEmptyCanvasSelector);
  const dockPosition = app.useStore(dockPositionState2);
  const isDebugMode = app.useStore(isDebugModeSelector2);
  const style = {
    bottom: dockPosition === "bottom" && isDebugMode ? 120 : dockPosition === "bottom" ? 80 : isDebugMode ? 60 : 20,
    left: "50%",
    transform: "translate(-50%,0)"
  };
  if (!isEmptyCanvas)
    return null;
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(BackToContentContainer, { id: "TD-Tools-Back_to_content", style: { ...style }, children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(RowButton, { onClick: app.zoomToContent, children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(FormattedMessage, { id: "zoom.to.content" }) }) });
});
var BackToContentContainer = styled(MenuContent, {
  pointerEvents: "all",
  width: "fit-content",
  minWidth: 0,
  position: "fixed",
  bottom: 0
});

// src/components/Tldraw/components/ToolsPanel/DeleteButton.tsx
var React19 = __toESM(require("react"));

// src/components/Tldraw/components/Primitives/icons/BoxIcon.tsx
var import_jsx_runtime18 = require("react/jsx-runtime");

// src/components/Tldraw/components/Primitives/icons/CircleIcon.tsx
var import_jsx_runtime19 = require("react/jsx-runtime");
function CircleIcon2(props) {
  const { size = 16, ...rest } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("svg", { width: 24, height: 24, ...rest, children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("circle", { cx: 12, cy: 12, r: size / 2 }) });
}

// src/components/Tldraw/components/Primitives/icons/DashDashedIcon.tsx
var import_jsx_runtime20 = require("react/jsx-runtime");
function DashDashedIcon() {
  return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("svg", { width: "24", height: "24", stroke: "currentColor", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("circle", { cx: 12, cy: 12, r: 8, fill: "none", strokeWidth: 2.5, strokeLinecap: "round", strokeDasharray: 50.26548 * 0.1 }) });
}

// src/components/Tldraw/components/Primitives/icons/DashDottedIcon.tsx
var import_jsx_runtime21 = require("react/jsx-runtime");
var dottedDasharray = `${50.26548 * 0.025} ${50.26548 * 0.1}`;
function DashDottedIcon() {
  return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("svg", { width: "24", height: "24", stroke: "currentColor", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("circle", { cx: 12, cy: 12, r: 8, fill: "none", strokeWidth: 2.5, strokeLinecap: "round", strokeDasharray: dottedDasharray }) });
}

// src/components/Tldraw/components/Primitives/icons/DashDrawIcon.tsx
var import_jsx_runtime22 = require("react/jsx-runtime");
function DashDrawIcon() {
  return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("svg", { width: "24", height: "24", viewBox: "1 1.5 21 22", fill: "currentColor", stroke: "currentColor", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
    "path",
    {
      d: "M10.0162 19.2768C10.0162 19.2768 9.90679 19.2517 9.6879 19.2017C9.46275 19.1454 9.12816 19.0422 8.68413 18.8921C8.23384 18.7358 7.81482 18.545 7.42707 18.3199C7.03307 18.101 6.62343 17.7883 6.19816 17.3818C5.77289 16.9753 5.33511 16.3718 4.88482 15.5713C4.43453 14.7645 4.1531 13.8545 4.04053 12.8414C3.92795 11.822 4.04991 10.8464 4.40639 9.91451C4.76286 8.98266 5.39452 8.10084 6.30135 7.26906C7.21444 6.44353 8.29325 5.83377 9.5378 5.43976C10.7823 5.05202 11.833 4.92068 12.6898 5.04576C13.5466 5.16459 14.3878 5.43664 15.2133 5.86191C16.0388 6.28718 16.7768 6.8688 17.4272 7.60678C18.0714 8.34475 18.5404 9.21406 18.8344 10.2147C19.1283 11.2153 19.1721 12.2598 18.9657 13.348C18.7593 14.4299 18.2872 15.4337 17.5492 16.3593C16.8112 17.2849 15.9263 18.0072 14.8944 18.5263C13.8624 19.0391 12.9056 19.3174 12.0238 19.3612C11.142 19.405 10.2101 19.2705 9.22823 18.9578C8.24635 18.6451 7.35828 18.151 6.56402 17.4756C5.77601 16.8002 6.08871 16.8658 7.50212 17.6726C8.90927 18.4731 10.1444 18.8484 11.2076 18.7983C12.2645 18.7545 13.2965 18.4825 14.3034 17.9822C15.3102 17.4819 16.1264 16.8221 16.7518 16.0028C17.3772 15.1835 17.7681 14.3111 17.9244 13.3855C18.0808 12.4599 18.0401 11.5781 17.8025 10.74C17.5586 9.902 17.1739 9.15464 16.6486 8.49797C16.1233 7.8413 15.2289 7.27844 13.9656 6.80939C12.7086 6.34034 11.4203 6.20901 10.1007 6.41539C8.78732 6.61552 7.69599 7.06893 6.82669 7.77564C5.96363 8.48859 5.34761 9.26409 4.97863 10.1021C4.60964 10.9402 4.45329 11.8376 4.50958 12.7945C4.56586 13.7513 4.79101 14.6238 5.18501 15.4118C5.57276 16.1998 5.96363 16.8002 6.35764 17.2129C6.75164 17.6257 7.13313 17.9509 7.50212 18.1886C7.87736 18.4325 8.28074 18.642 8.71227 18.8171C9.15005 18.9922 9.47839 19.111 9.69728 19.1736C9.91617 19.2361 10.0256 19.2705 10.0256 19.2768H10.0162Z",
      strokeWidth: "2"
    }
  ) });
}

// src/components/Tldraw/components/Primitives/icons/DashSolidIcon.tsx
var import_jsx_runtime23 = require("react/jsx-runtime");
function DashSolidIcon() {
  return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("svg", { width: "24", height: "24", stroke: "currentColor", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("circle", { cx: 12, cy: 12, r: 8, fill: "none", strokeWidth: 2, strokeLinecap: "round" }) });
}

// src/components/Tldraw/components/Primitives/icons/TrashIcon.tsx
var import_jsx_runtime24 = require("react/jsx-runtime");
function TrashIcon(props) {
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("svg", { width: 18, height: 18, viewBox: "0 0 15 15", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...props, children: [
    /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2 4.656a.5.5 0 01.5-.5h9.7a.5.5 0 010 1H2.5a.5.5 0 01-.5-.5z" }),
    /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M6.272 3a.578.578 0 00-.578.578v.578h3.311v-.578A.578.578 0 008.428 3H6.272zm3.733 1.156v-.578A1.578 1.578 0 008.428 2H6.272a1.578 1.578 0 00-1.578 1.578v.578H3.578a.5.5 0 00-.5.5V12.2a1.578 1.578 0 001.577 1.578h5.39a1.578 1.578 0 001.577-1.578V4.656a.5.5 0 00-.5-.5h-1.117zm-5.927 1V12.2a.578.578 0 00.577.578h5.39a.578.578 0 00.577-.578V5.156H4.078z"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M6.272 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5zM8.428 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5z"
      }
    )
  ] });
}

// src/components/Tldraw/components/Primitives/icons/UndoIcon.tsx
var import_jsx_runtime25 = require("react/jsx-runtime");
function UndoIcon({ flipHorizontal, ...props }) {
  return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
    "svg",
    {
      width: 24,
      height: 24,
      viewBox: "0 0 15 15",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      style: {
        transform: flipHorizontal ? "scale(-1, 1)" : "scale(1, 1)"
      },
      ...props,
      children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("path", { d: "M10.6707 8.5081C10.6707 10.1923 9.3004 11.5625 7.61631 11.5625H6.5351C6.35593 11.5625 6.21074 11.4173 6.21074 11.2382V11.13C6.21074 10.9508 6.35591 10.8057 6.5351 10.8057H7.61631C8.88313 10.8057 9.91387 9.77492 9.91387 8.5081C9.91387 7.24128 8.88313 6.21054 7.61631 6.21054H5.62155L6.99534 7.58433C7.14289 7.73183 7.14289 7.97195 6.99534 8.11944C6.85216 8.26251 6.60298 8.2623 6.46013 8.11944L4.44045 6.09971C4.36898 6.02824 4.32959 5.93321 4.32959 5.8321C4.32959 5.73106 4.36898 5.63598 4.44045 5.56454L6.46024 3.54472C6.60309 3.40176 6.85248 3.40176 6.99535 3.54472C7.14291 3.69218 7.14291 3.93234 6.99535 4.07979L5.62156 5.45368H7.61631C9.3004 5.45368 10.6707 6.82393 10.6707 8.5081Z" })
    }
  );
}

// src/components/Tldraw/components/Primitives/icons/SizeSmallIcon.tsx
var import_jsx_runtime26 = require("react/jsx-runtime");
function SizeSmallIcon(props) {
  return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("svg", { width: 24, height: 24, viewBox: "-2 -2 28 28", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("path", { d: "M12.4239 4.62C13.3572 4.62 14.1572 4.73333 14.8239 4.96C15.4906 5.17333 15.9772 5.43333 16.2839 5.74C16.3639 5.82 16.4039 5.94 16.4039 6.1V8.86H14.0639C13.9172 8.86 13.8439 8.78666 13.8439 8.64V7.26C13.4306 7.12666 12.9572 7.06 12.4239 7.06C11.6506 7.06 11.0639 7.18 10.6639 7.42C10.2639 7.66 10.0639 8.04666 10.0639 8.58V9C10.0639 9.38666 10.1639 9.69333 10.3639 9.92C10.5772 10.1333 11.0306 10.3467 11.7239 10.56L13.6439 11.14C14.4706 11.38 15.1172 11.66 15.5839 11.98C16.0506 12.3 16.3772 12.68 16.5639 13.12C16.7639 13.5467 16.8639 14.0733 16.8639 14.7V15.62C16.8639 16.7933 16.4039 17.7133 15.4839 18.38C14.5639 19.0467 13.2839 19.38 11.6439 19.38C10.6706 19.38 9.79723 19.2867 9.0239 19.1C8.2639 18.9133 7.71056 18.6533 7.3639 18.32C7.3239 18.28 7.29056 18.24 7.2639 18.2C7.25056 18.1467 7.2439 18.06 7.2439 17.94V15.74H7.6239C8.2239 16.1533 8.85056 16.4533 9.5039 16.64C10.1572 16.8267 10.9306 16.92 11.8239 16.92C12.6506 16.92 13.2506 16.7867 13.6239 16.52C14.0106 16.2533 14.2039 15.9333 14.2039 15.56V14.88C14.2039 14.6667 14.1639 14.48 14.0839 14.32C14.0172 14.16 13.8706 14.0133 13.6439 13.88C13.4172 13.7467 13.0572 13.6067 12.5639 13.46L10.6639 12.88C9.7839 12.6133 9.11056 12.3 8.6439 11.94C8.17723 11.58 7.85056 11.18 7.6639 10.74C7.49056 10.3 7.4039 9.83333 7.4039 9.34V8.38C7.4039 7.64666 7.61056 7 8.0239 6.44C8.43723 5.88 9.01723 5.44 9.7639 5.12C10.5239 4.78666 11.4106 4.62 12.4239 4.62Z" }) });
}

// src/components/Tldraw/components/Primitives/icons/SizeMediumIcon.tsx
var import_jsx_runtime27 = require("react/jsx-runtime");
function SizeMediumIcon(props) {
  return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("svg", { width: 24, height: 24, viewBox: "-2 -2 28 28", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("path", { d: "M8.16191 19H5.68191C5.53525 19 5.46191 18.9267 5.46191 18.78V5H8.76191C8.88191 5 8.97525 5.03333 9.04191 5.1C9.10858 5.15333 9.17525 5.27333 9.24191 5.46C9.72191 6.59333 10.1686 7.7 10.5819 8.78C11.0086 9.84667 11.4352 10.98 11.8619 12.18H12.1619C12.6019 10.9667 13.0352 9.79333 13.4619 8.66C13.8886 7.52667 14.3552 6.30667 14.8619 5H18.3219C18.4686 5 18.5419 5.07333 18.5419 5.22V19H16.0619C15.9152 19 15.8419 18.9267 15.8419 18.78V16.26C15.8419 15.5267 15.8486 14.8133 15.8619 14.12C15.8886 13.4267 15.9286 12.6867 15.9819 11.9C16.0486 11.1 16.1419 10.1933 16.2619 9.18H15.9019C15.4352 10.3533 14.9486 11.5667 14.4419 12.82C13.9486 14.06 13.4819 15.2333 13.0419 16.34H11.1019C11.0619 16.34 11.0152 16.3333 10.9619 16.32C10.9219 16.2933 10.8886 16.2467 10.8619 16.18C10.4619 15.18 10.0086 14.06 9.50191 12.82C9.00858 11.58 8.53525 10.3667 8.08191 9.18H7.70191C7.83525 10.18 7.93525 11.0733 8.00191 11.86C8.06858 12.6467 8.10858 13.3933 8.12191 14.1C8.14858 14.8067 8.16191 15.5267 8.16191 16.26V19Z" }) });
}

// src/components/Tldraw/components/Primitives/icons/SizeLargeIcon.tsx
var import_jsx_runtime28 = require("react/jsx-runtime");
function SizeLargeIcon(props) {
  return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("svg", { width: 24, height: 24, viewBox: "-2 -2 28 28", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("path", { d: "M7.68191 19C7.53525 19 7.46191 18.9267 7.46191 18.78V5H10.1219C10.2686 5 10.3419 5.07333 10.3419 5.22V16.56H13.4419V15.02H15.7619C15.9086 15.02 15.9819 15.0933 15.9819 15.24V19H7.68191Z" }) });
}

// src/components/Tldraw/components/Primitives/icons/EraserIcon.tsx
var import_jsx_runtime29 = require("react/jsx-runtime");
function EraserIcon() {
  return /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("svg", { width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
      "path",
      {
        d: "M1.72838 9.33987L8.84935 2.34732C9.23874 1.96494 9.86279 1.96539 10.2516 2.34831L13.5636 5.60975C13.9655 6.00555 13.9607 6.65526 13.553 7.04507L8.13212 12.2278C7.94604 12.4057 7.69851 12.505 7.44107 12.505L6.06722 12.505L3.83772 12.505C3.5673 12.505 3.30842 12.3954 3.12009 12.2014L1.7114 10.7498C1.32837 10.3551 1.33596 9.72521 1.72838 9.33987Z",
        stroke: "currentColor"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("line", { x1: "6.01807", y1: "12.5", x2: "10.7959", y2: "12.5", stroke: "currentColor", strokeLinecap: "round" }),
    /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("line", { x1: "5.50834", y1: "5.74606", x2: "10.1984", y2: "10.4361", stroke: "currentColor" })
  ] });
}

// src/components/Tldraw/components/Primitives/icons/DiscordIcon.tsx
var import_jsx_runtime30 = require("react/jsx-runtime");

// src/components/Tldraw/components/Primitives/icons/LineIcon.tsx
var import_jsx_runtime31 = require("react/jsx-runtime");
function LineIcon() {
  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("svg", { width: "15", height: "15", viewBox: "0 0 15 15", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("path", { d: "M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L11.1464 3.14645C11.3417 2.95118 11.6583 2.95118 11.8536 3.14645C12.0488 3.34171 12.0488 3.65829 11.8536 3.85355L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z" }) });
}

// src/components/Tldraw/components/ToolsPanel/DeleteButton.tsx
var import_jsx_runtime32 = require("react/jsx-runtime");
function DeleteButton() {
  const app = useTldrawApp();
  const intl = useIntl();
  const handleDelete = React19.useCallback(() => {
    app.delete();
  }, [app]);
  const hasSelection = app.useStore((s5) => s5.appState.status === "idle" && s5.document.pageStates[s5.appState.currentPageId].selectedIds.length > 0);
  return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Tooltip, { label: intl.formatMessage({ id: "delete" }), kbd: "\u232B", id: "TD-Delete", children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(ToolButton, { variant: "circle", disabled: !hasSelection, onSelect: handleDelete, children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(TrashIcon, {}) }) });
}

// src/components/Tldraw/components/ToolsPanel/PrimaryTools.tsx
var React21 = __toESM(require("react"));

// src/components/Tldraw/components/Primitives/Panel/Panel.tsx
var Panel = styled("div", {
  backgroundColor: "$panel",
  display: "flex",
  flexDirection: "row",
  boxShadow: "$panel",
  padding: "$2",
  border: "1px solid $panelContrast",
  gap: 0,
  overflow: "hidden",
  variants: {
    side: {
      center: {
        borderRadius: 9
      },
      left: {
        padding: 0,
        borderTop: 0,
        borderLeft: 0,
        borderTopRightRadius: 0,
        borderBottomRightRadius: 9,
        borderBottomLeftRadius: 0
      },
      right: {
        padding: 0,
        borderTop: 0,
        borderRight: 0,
        borderTopLeftRadius: 0,
        borderBottomLeftRadius: 9,
        borderBottomRightRadius: 0
      }
    }
  },
  "& hr": {
    height: 10,
    width: "100%",
    backgroundColor: "red",
    border: "none"
  }
});

// src/components/Tldraw/components/ToolsPanel/ShapesMenu.tsx
var React20 = __toESM(require("react"));
var import_jsx_runtime33 = require("react/jsx-runtime");
var shapeShapes = ["rectangle" /* Rectangle */, "ellipse" /* Ellipse */, "triangle" /* Triangle */, "line" /* Line */];
var shapeShapeIcons = {
  ["rectangle" /* Rectangle */]: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(SquareIcon, {}),
  ["ellipse" /* Ellipse */]: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(CircleIcon, {}),
  ["triangle" /* Triangle */]: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(VercelLogoIcon, {}),
  ["line" /* Line */]: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(LineIcon, {})
};
var dockPositionState3 = (s5) => s5.settings.dockPosition;
var ShapesMenu = React20.memo(function ShapesMenu2({ activeTool, isToolLocked }) {
  const app = useTldrawApp();
  const intl = useIntl();
  const dockPosition = app.useStore(dockPositionState3);
  const [lastActiveTool, setLastActiveTool] = React20.useState("rectangle" /* Rectangle */);
  React20.useEffect(() => {
    if (shapeShapes.includes(activeTool) && lastActiveTool !== activeTool) {
      setLastActiveTool(activeTool);
    }
  }, [activeTool]);
  const selectShapeTool = React20.useCallback(() => {
    app.selectTool(lastActiveTool);
  }, [activeTool, app]);
  const handleDoubleClick = React20.useCallback(() => {
    app.toggleToolLock();
  }, [app]);
  const handleKeyDown = React20.useCallback((e5) => {
    if (e5.key === " " && app.shiftKey) {
      e5.preventDefault();
    }
  }, []);
  const isActive = shapeShapes.includes(activeTool);
  const contentSide = dockPosition === "bottom" || dockPosition === "top" ? "top" : dockPosition;
  const panelStyle = dockPosition === "bottom" || dockPosition === "top" ? "row" : "column";
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: "ltr", onOpenChange: selectShapeTool, children: [
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { dir: "ltr", asChild: true, id: "TD-PrimaryTools-Shapes", children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
      ToolButton,
      {
        disabled: isActive && app.shiftKey,
        variant: "primary",
        onDoubleClick: handleDoubleClick,
        isToolLocked: isActive && isToolLocked,
        isActive,
        onKeyDown: handleKeyDown,
        children: shapeShapeIcons[lastActiveTool]
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)($d08ef79370b62062$export$7c6e2c02157bb7d2, { asChild: true, side: contentSide, sideOffset: 12, children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Panel, { side: "center", style: { flexDirection: panelStyle }, children: shapeShapes.map((shape, index2) => /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Tooltip, { label: intl.formatMessage({ id: shape }), kbd: (4 + index2).toString(), id: `TD-PrimaryTools-Shapes-${shape}`, children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
      ToolButton,
      {
        variant: "primary",
        onClick: () => {
          app.selectTool(shape);
          setLastActiveTool(shape);
        },
        children: shapeShapeIcons[shape]
      }
    ) }) }, shape)) }) })
  ] });
});

// src/components/Tldraw/components/ToolsPanel/PrimaryTools.tsx
var import_jsx_runtime34 = require("react/jsx-runtime");
var activeToolSelector = (s5) => s5.appState.activeTool;
var toolLockedSelector = (s5) => s5.appState.isToolLocked;
var dockPositionState4 = (s5) => s5.settings.dockPosition;
var PrimaryTools = React21.memo(function PrimaryTools2() {
  const app = useTldrawApp();
  const intl = useIntl();
  const activeTool = app.useStore(activeToolSelector);
  const isToolLocked = app.useStore(toolLockedSelector);
  const dockPosition = app.useStore(dockPositionState4);
  const selectSelectTool = React21.useCallback(() => {
    app.selectTool("select");
  }, [app]);
  const selectEraseTool = React21.useCallback(() => {
    app.selectTool("erase");
  }, [app]);
  const selectDrawTool = React21.useCallback(() => {
    app.selectTool("draw" /* Draw */);
  }, [app]);
  const selectArrowTool = React21.useCallback(() => {
    app.selectTool("arrow" /* Arrow */);
  }, [app]);
  const selectTextTool = React21.useCallback(() => {
    app.selectTool("text" /* Text */);
  }, [app]);
  const selectStickyTool = React21.useCallback(() => {
    app.selectTool("sticky" /* Sticky */);
  }, [app]);
  const uploadMedias = React21.useCallback(async () => {
    app.openAsset();
  }, [app]);
  const panelStyle = dockPosition === "bottom" || dockPosition === "top" ? "row" : "column";
  return /* @__PURE__ */ (0, import_jsx_runtime34.jsxs)(StyledPanel, { side: "center", id: "TD-PrimaryTools", style: { flexDirection: panelStyle }, bp: breakpoints, children: [
    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
      ToolButtonWithTooltip,
      {
        kbd: "1",
        label: intl.formatMessage({ id: "select" }),
        onClick: selectSelectTool,
        isActive: activeTool === "select",
        id: "TD-PrimaryTools-CursorArrow",
        children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(CursorArrowIcon, {})
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
      ToolButtonWithTooltip,
      {
        kbd: "2",
        label: intl.formatMessage({ id: "draw" }),
        onClick: selectDrawTool,
        isActive: activeTool === "draw" /* Draw */,
        id: "TD-PrimaryTools-Pencil",
        children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(Pencil1Icon, {})
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
      ToolButtonWithTooltip,
      {
        kbd: "3",
        label: intl.formatMessage({ id: "eraser" }),
        onClick: selectEraseTool,
        isActive: activeTool === "erase",
        id: "TD-PrimaryTools-Eraser",
        children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(EraserIcon, {})
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(ShapesMenu, { activeTool, isToolLocked }),
    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
      ToolButtonWithTooltip,
      {
        kbd: "8",
        label: intl.formatMessage({ id: "arrow" }),
        onClick: selectArrowTool,
        isLocked: isToolLocked,
        isActive: activeTool === "arrow" /* Arrow */,
        id: "TD-PrimaryTools-ArrowTopRight",
        children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(ArrowTopRightIcon, {})
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
      ToolButtonWithTooltip,
      {
        kbd: "9",
        label: intl.formatMessage({ id: "text" }),
        onClick: selectTextTool,
        isLocked: isToolLocked,
        isActive: activeTool === "text" /* Text */,
        id: "TD-PrimaryTools-Text",
        children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(TextIcon, {})
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
      ToolButtonWithTooltip,
      {
        kbd: "0",
        label: intl.formatMessage({ id: "sticky" }),
        onClick: selectStickyTool,
        isActive: activeTool === "sticky" /* Sticky */,
        id: "TD-PrimaryTools-Pencil2",
        children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(Pencil2Icon, {})
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(ToolButtonWithTooltip, { label: intl.formatMessage({ id: "image" }), onClick: uploadMedias, id: "TD-PrimaryTools-Image", children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(ImageIcon, {}) })
  ] });
});
var StyledPanel = styled(Panel, {
  variants: {
    bp: {
      mobile: {
        padding: "$0",
        borderRadius: "10px"
      },
      small: {
        padding: "$2"
      }
    }
  }
});

// src/components/Tldraw/components/ToolsPanel/StatusBar.tsx
var import_jsx_runtime35 = require("react/jsx-runtime");
var statusSelector = (s5) => s5.appState.status;
var activeToolSelector2 = (s5) => s5.appState.activeTool;
function StatusBar() {
  const app = useTldrawApp();
  const status = app.useStore(statusSelector);
  const activeTool = app.useStore(activeToolSelector2);
  return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(StyledStatusBar, { bp: breakpoints, id: "TD-StatusBar", children: /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)(StyledSection, { children: [
    activeTool,
    " | ",
    status
  ] }) });
}
var StyledStatusBar = styled("div", {
  height: 40,
  userSelect: "none",
  borderTop: "1px solid $panelContrast",
  gridArea: "status",
  display: "flex",
  color: "$text",
  justifyContent: "space-between",
  alignItems: "center",
  backgroundColor: "$panel",
  gap: 8,
  fontFamily: "$ui",
  fontSize: "$0",
  padding: "0 16px",
  variants: {
    bp: {
      small: {
        fontSize: "$1"
      }
    }
  }
});
var StyledSection = styled("div", {
  whiteSpace: "nowrap",
  overflow: "hidden"
});

// src/components/Tldraw/components/ToolsPanel/ToolsPanel.tsx
var import_jsx_runtime36 = require("react/jsx-runtime");
var isDebugModeSelector3 = (s5) => s5.settings.isDebugMode;
var dockPositionState5 = (s5) => s5.settings.dockPosition;
var ToolsPanel = React22.memo(function ToolsPanel2({ onBlur }) {
  const app = useTldrawApp();
  const side = app.useStore(dockPositionState5);
  const isDebugMode = app.useStore(isDebugModeSelector3);
  return /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)(import_jsx_runtime36.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(StyledToolsPanelContainer, { side, onBlur, bp: breakpoints, debug: isDebugMode, children: /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)(StyledCenterWrap, { id: "TD-Tools", children: [
      /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(BackToContent, {}),
      /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)(StyledPrimaryTools, { orientation: side === "bottom" || side === "top" ? "horizontal" : "vertical", children: [
        /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(ActionButton, {}),
        /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(PrimaryTools, {}),
        /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(DeleteButton, {})
      ] })
    ] }) }),
    isDebugMode && /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(StyledStatusWrap, { children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(StatusBar, {}) })
  ] });
});
var StyledToolsPanelContainer = styled("div", {
  position: "absolute",
  width: "100%",
  minWidth: 0,
  maxWidth: "100%",
  height: 64,
  gap: "$4",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  zIndex: 200,
  overflow: "hidden",
  pointerEvents: "none",
  "& > div > *": {
    pointerEvents: "all"
  },
  variants: {
    debug: {
      true: {},
      false: {}
    },
    bp: {
      mobile: {},
      small: {},
      medium: {},
      large: {}
    },
    side: {
      top: {
        width: "100%",
        height: 64,
        left: 0,
        right: 0,
        top: 45
      },
      right: { width: 64, height: "100%", top: 0, right: 0 },
      bottom: {
        width: "100%",
        left: 0,
        right: 0,
        bottom: 4
      },
      left: { width: 64, height: "100%", left: 0 }
    }
  },
  compoundVariants: [
    {
      side: "top",
      bp: "large",
      css: {
        top: 0
      }
    },
    {
      side: "bottom",
      debug: true,
      css: {
        bottom: 44
      }
    }
  ]
});
var StyledCenterWrap = styled("div", {
  display: "flex",
  width: "fit-content",
  height: "fit-content",
  alignItems: "center",
  justifyContent: "center",
  flexDirection: "column",
  gap: "$4"
});
var StyledStatusWrap = styled("div", {
  position: "absolute",
  bottom: "0px",
  left: "0px",
  right: "0px",
  height: "40px",
  width: "100%",
  maxWidth: "100%"
});
var StyledPrimaryTools = styled("div", {
  position: "relative",
  display: "flex",
  alignItems: "center",
  height: "fit-content",
  gap: "$3",
  variants: {
    orientation: {
      horizontal: {
        flexDirection: "row"
      },
      vertical: {
        flexDirection: "column"
      }
    }
  }
});

// src/components/Tldraw/components/TopPanel/TopPanel.tsx
var React47 = __toESM(require("react"));

// src/components/Tldraw/components/TopPanel/Menu/Menu.tsx
var React24 = __toESM(require("react"));

// src/components/Tldraw/components/TopPanel/PreferencesMenu/PreferencesMenu.tsx
var React23 = __toESM(require("react"));
var import_jsx_runtime37 = require("react/jsx-runtime");
var settingsSelector = (s5) => s5.settings;
var DockPosition = ["bottom", "left", "right", "top"];
function PreferencesMenu() {
  const app = useTldrawApp();
  const intl = useIntl();
  const settings = app.useStore(settingsSelector);
  const toggleDebugMode = React23.useCallback(() => {
    app.setSetting("isDebugMode", (v6) => !v6);
  }, [app]);
  const toggleFocusMode = React23.useCallback(() => {
    app.setSetting("isFocusMode", (v6) => !v6);
  }, [app]);
  const toggleGrid = React23.useCallback(() => {
    app.setSetting("showGrid", (v6) => !v6);
  }, [app]);
  const toggleKeepStyleMenuOpen = React23.useCallback(() => {
    app.setSetting("keepStyleMenuOpen", (v6) => !v6);
  }, [app]);
  const toggleCadSelectMode = React23.useCallback(() => {
    app.setSetting("isCadSelectMode", (v6) => !v6);
  }, [app]);
  const handleChangeDockPosition = React23.useCallback(
    (position) => {
      app.setSetting("dockPosition", position);
    },
    [app]
  );
  const selectExportBackground = React23.useCallback(
    (background) => {
      app.setSetting("exportBackground", background);
    },
    [app]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(DMSubMenu, { label: intl.formatMessage({ id: "menu.preferences" }), id: "TD-MenuItem-Preferences", children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMCheckboxItem, { checked: settings.isFocusMode, onCheckedChange: toggleFocusMode, kbd: "#.", id: "TD-MenuItem-Preferences-Focus_Mode", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: "preferences.focus.mode" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMCheckboxItem, { checked: settings.isDebugMode, onCheckedChange: toggleDebugMode, id: "TD-MenuItem-Preferences-Debug_Mode", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: "preferences.debug.mode" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Divider, {}),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMCheckboxItem, { checked: settings.showGrid, onCheckedChange: toggleGrid, kbd: "#\u21E7G", id: "TD-MenuItem-Preferences-Grid", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: "preferences.show.grid" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMCheckboxItem, { checked: settings.isCadSelectMode, onCheckedChange: toggleCadSelectMode, id: "TD-MenuItem-Preferences-Cad_Selection", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: "preferences.use.cad.selection" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMCheckboxItem, { checked: settings.keepStyleMenuOpen, onCheckedChange: toggleKeepStyleMenuOpen, id: "TD-MenuItem-Preferences-Style_menu", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: "preferences.keep.stylemenu.open" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMSubMenu, { label: intl.formatMessage({ id: "dock.position" }), children: DockPosition.map((position) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
      DMCheckboxItem,
      {
        checked: settings.dockPosition === position,
        onCheckedChange: () => handleChangeDockPosition(position),
        id: `TD-MenuItem-DockPosition-${position}`,
        children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(StyledText, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: position }) })
      },
      position
    )) }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMSubMenu, { label: intl.formatMessage({ id: "export.background" }), children: Object.values(TDExportBackground).map((exportBackground) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
      DMCheckboxItem,
      {
        checked: settings.exportBackground === exportBackground,
        onCheckedChange: () => selectExportBackground(exportBackground),
        id: `TD-MenuItem-ExportBackground-${exportBackground}`,
        children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(StyledText, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: exportBackground }) })
      },
      exportBackground
    )) })
  ] });
}
var StyledText = styled("span", {
  textTransform: "capitalize"
});

// src/components/Tldraw/components/TopPanel/Menu/Menu.tsx
var import_jsx_runtime38 = require("react/jsx-runtime");
var numberOfSelectedIdsSelector2 = (s5) => {
  return s5.document.pageStates[s5.appState.currentPageId].selectedIds.length;
};
var disableAssetsSelector = (s5) => {
  return s5.appState.disableAssets;
};
var Menu = React24.memo(function Menu2({ readOnly }) {
  const app = useTldrawApp();
  const intl = useIntl();
  const [openDialog, setOpenDialog] = React24.useState(false);
  const numberOfSelectedIds = app.useStore(numberOfSelectedIdsSelector2);
  const disableAssets = app.useStore(disableAssetsSelector);
  const [_3, setForce] = React24.useState(0);
  React24.useEffect(() => setForce(1), []);
  const handleDelete = React24.useCallback(() => {
    app.delete();
  }, [app]);
  const handleCopySVG = React24.useCallback(() => {
    app.copyImage("svg" /* SVG */, { scale: 1, quality: 1, transparentBackground: false });
  }, [app]);
  const handleCopyPNG = React24.useCallback(() => {
    app.copyImage("png" /* PNG */, { scale: 2, quality: 1, transparentBackground: true });
  }, [app]);
  const handleExportPNG = React24.useCallback(async () => {
    app.exportImage("png" /* PNG */, { scale: 2, quality: 1 });
  }, [app]);
  const handleExportJPG = React24.useCallback(async () => {
    app.exportImage("jpeg" /* JPG */, { scale: 2, quality: 1 });
  }, [app]);
  const handleExportWEBP = React24.useCallback(async () => {
    app.exportImage("webp" /* WEBP */, { scale: 2, quality: 1 });
  }, [app]);
  const handleExportSVG = React24.useCallback(async () => {
    app.exportImage("svg" /* SVG */, { scale: 2, quality: 1 });
  }, [app]);
  const handleCopyJSON = React24.useCallback(async () => {
    app.copyJson();
  }, [app]);
  const handleExportJSON = React24.useCallback(async () => {
    app.exportJson();
  }, [app]);
  const handleCut = React24.useCallback(() => {
    app.cut();
  }, [app]);
  const handleCopy = React24.useCallback(() => {
    app.copy();
  }, [app]);
  const handlePaste = React24.useCallback(() => {
    app.paste();
  }, [app]);
  const handleSelectAll = React24.useCallback(() => {
    app.selectAll();
  }, [app]);
  const handleSelectNone = React24.useCallback(() => {
    app.selectNone();
  }, [app]);
  const handleUploadMedia = React24.useCallback(() => {
    app.openAsset();
  }, [app]);
  const handleZoomTo100 = React24.useCallback(() => {
    app.zoomTo(1);
  }, [app]);
  const showFileMenu = app.callbacks.onExport;
  const hasSelection = numberOfSelectedIds > 0;
  return /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(import_jsx_runtime38.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: "ltr", children: [
    /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMTriggerIcon, { id: "TD-MenuIcon", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(HamburgerMenuIcon, {}) }),
    /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(DMContent, { variant: "menu", id: "TD-Menu", side: "bottom", align: "start", sideOffset: 4, alignOffset: 4, children: [
      showFileMenu != void 0 && /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMSubMenu, { label: `${intl.formatMessage({ id: "menu.file" })}...`, id: "TD-MenuItem-File", children: !disableAssets && /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(import_jsx_runtime38.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Divider, {}),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleUploadMedia, kbd: "#U", id: "TD-MenuItem-File-Upload_Media", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: "upload.media" }) })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(DMSubMenu, { label: `${intl.formatMessage({ id: "menu.edit" })}...`, id: "TD-MenuItem-Edit", children: [
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: app.undo, disabled: readOnly, kbd: "#Z", id: "TD-MenuItem-Edit-Undo", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: "undo" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: app.redo, disabled: readOnly, kbd: "#\u21E7Z", id: "TD-MenuItem-Edit-Redo", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: "redo" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Divider, {}),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, disabled: !hasSelection || readOnly, onClick: handleCut, kbd: "#X", id: "TD-MenuItem-Edit-Cut", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: "cut" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, disabled: !hasSelection, onClick: handleCopy, kbd: "#C", id: "TD-MenuItem-Edit-Copy", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: "copy" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: handlePaste, kbd: "#V", id: "TD-MenuItem-Edit-Paste", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: "paste" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Divider, {}),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(DMSubMenu, { label: `${intl.formatMessage({ id: "copy.as" })}...`, size: "small", id: "TD-MenuItem-Copy-As", children: [
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleCopySVG, id: "TD-MenuItem-Copy-as-SVG", children: "SVG" }),
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleCopyPNG, id: "TD-MenuItem-Copy-As-PNG", children: "PNG" }),
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleCopyJSON, id: "TD-MenuItem-Copy_as_JSON", children: "JSON" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(DMSubMenu, { label: `${intl.formatMessage({ id: "export.as" })}...`, size: "small", id: "TD-MenuItem-Export", children: [
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleExportSVG, id: "TD-MenuItem-Export-SVG", children: "SVG" }),
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleExportPNG, id: "TD-MenuItem-Export-PNG", children: "PNG" }),
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleExportJPG, id: "TD-MenuItem-Export-JPG", children: "JPG" }),
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleExportWEBP, id: "TD-MenuItem-Export-WEBP", children: "WEBP" }),
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleExportJSON, id: "TD-MenuItem-Export-JSON", children: "JSON" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Divider, {}),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: handleSelectAll, kbd: "#A", id: "TD-MenuItem-Select_All", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: "select.all" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, disabled: !hasSelection, onClick: handleSelectNone, id: "TD-MenuItem-Select_None", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: "select.none" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Divider, {}),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: handleDelete, disabled: !hasSelection, kbd: "\u232B", id: "TD-MenuItem-Delete", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: "delete" }) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(DMSubMenu, { label: intl.formatMessage({ id: "menu.view" }), id: "TD-MenuItem-Edit", children: [
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomIn, kbd: "#+", id: "TD-MenuItem-View-ZoomIn", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: "zoom.in" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomOut, kbd: "#-", id: "TD-MenuItem-View-ZoomOut", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: "zoom.out" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(DMItem, { onSelect: preventEvent, onClick: handleZoomTo100, kbd: "\u21E7+0", id: "TD-MenuItem-View-ZoomTo100", children: [
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: "zoom.to" }),
          " 100%"
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomToFit, kbd: "\u21E7+1", id: "TD-MenuItem-View-ZoomToFit", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: "zoom.to.fit" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomToSelection, kbd: "\u21E7+2", id: "TD-MenuItem-View-ZoomToSelection", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: "zoom.to.selection" }) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Divider, {}),
      /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(PreferencesMenu, {})
    ] })
  ] }) });
});

// src/components/Tldraw/components/TopPanel/PageMenu/PageMenu.tsx
var React27 = __toESM(require("react"));

// src/components/Tldraw/components/TopPanel/PageOptionsDialog/PageOptionsDialog.tsx
var React26 = __toESM(require("react"));

// src/components/Tldraw/components/Primitives/TextField/TextField.tsx
var React25 = __toESM(require("react"));
var import_jsx_runtime39 = require("react/jsx-runtime");
var TextField = React25.forwardRef(({ icon, ...rest }, reference) => {
  return /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)(StyledInputWrapper, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(StyledInput, { ...rest, ref: reference }),
    icon == void 0 ? null : /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(StyledInputIcon, { children: icon })
  ] });
});
var StyledInputWrapper = styled("div", {
  position: "relative",
  width: "100%",
  height: "min-content"
});
var StyledInput = styled("input", {
  color: "$text",
  border: "none",
  textAlign: "left",
  width: "100%",
  paddingLeft: "$3",
  paddingRight: "$6",
  backgroundColor: "$background",
  height: "32px",
  outline: "none",
  fontFamily: "$ui",
  fontSize: "$1",
  "&:focus": {
    backgroundColor: "$hover"
  },
  borderRadius: "$2"
});
var StyledInputIcon = styled(SmallIcon, {
  top: 0,
  right: 0,
  position: "absolute",
  paddingLeft: "$3",
  paddingRight: "$3",
  pointerEvents: "none",
  color: "$text"
});

// src/components/Tldraw/components/TopPanel/PageOptionsDialog/PageOptionsDialog.tsx
var import_jsx_runtime40 = require("react/jsx-runtime");
var canDeleteSelector = (s5) => {
  return Object.keys(s5.document.pages).length > 1;
};
function PageOptionsDialog({ page, onOpen, onClose }) {
  const app = useTldrawApp();
  const intl = useIntl();
  const [isOpen, setIsOpen] = React26.useState(false);
  const [pageName, setPageName] = React26.useState(page.name || "Page");
  const canDelete = app.useStore(canDeleteSelector);
  const rInput = React26.useRef(null);
  const handleClose = React26.useCallback(() => {
    setIsOpen(false);
  }, []);
  const handleDuplicate = React26.useCallback(() => {
    app.duplicatePage(page.id);
  }, [app]);
  const handleDelete = React26.useCallback(() => {
    if (window.confirm(`Are you sure you want to delete this page?`)) {
      app.deletePage(page.id);
    }
  }, [app]);
  const handleOpenChange = React26.useCallback(
    (isOpen2) => {
      setIsOpen(isOpen2);
      if (isOpen2) {
        onOpen?.();
      }
    },
    [app]
  );
  function stopPropagation4(e5) {
    e5.stopPropagation();
  }
  const rInitialName = React26.useRef(page.name || "Page");
  const rCurrentName = React26.useRef(rInitialName.current);
  const handleTextFieldChange = React26.useCallback((event) => {
    const value = event.target.value.trimStart();
    rCurrentName.current = value;
    setPageName(value);
  }, []);
  const handleTextFieldKeyDown = React26.useCallback((e5) => {
    switch (e5.key) {
      case "Enter": {
        if (rCurrentName.current === rInitialName.current) {
          setIsOpen(false);
        } else {
          rInitialName.current = rCurrentName.current;
          app.renamePage(page.id, rCurrentName.current.trim());
          setIsOpen(false);
        }
        break;
      }
      case "Escape": {
        if (rCurrentName.current === rInitialName.current) {
          setIsOpen(false);
          return;
        }
        rCurrentName.current = rInitialName.current;
        setPageName(rInitialName.current);
        requestAnimationFrame(() => {
          const elm = rInput.current;
          if (elm != void 0) {
            elm.focus();
            elm.setSelectionRange(0, elm.value.length);
          }
        });
        break;
      }
    }
  }, []);
  const rWasOpen = React26.useRef(false);
  React26.useEffect(() => {
    if (isOpen) {
      rWasOpen.current = true;
      rInitialName.current = page.name || "Page";
      rCurrentName.current = rInitialName.current;
      requestAnimationFrame(() => {
        const elm = rInput.current;
        if (elm != void 0) {
          elm.focus();
          elm.setSelectionRange(0, elm.value.length);
        }
      });
    } else if (rWasOpen.current) {
      onClose?.();
    }
    return () => {
      if (rCurrentName.current !== rInitialName.current) {
        rInitialName.current = rCurrentName.current;
        app.renamePage(page.id, rCurrentName.current);
      }
    };
  }, [isOpen]);
  const container = useContainer();
  return /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)($905f4ae918aab1aa$export$be92b6f5f03c0fe9, { open: isOpen, onOpenChange: handleOpenChange, children: [
    /* @__PURE__ */ (0, import_jsx_runtime40.jsx)($905f4ae918aab1aa$export$41fb9f06171c75f4, { asChild: true, "data-shy": "true", children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(IconButton, { bp: breakpoints, children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(SmallIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(MixerVerticalIcon, {}) }) }) }),
    /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)($905f4ae918aab1aa$export$602eac185826482c, { container: container.current, children: [
      /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(StyledDialogOverlay2, { onPointerDown: handleClose }),
      /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(StyledDialogContent, { dir: "ltr", onKeyDown: stopPropagation4, onKeyUp: stopPropagation4, children: [
        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
          TextField,
          {
            ref: rInput,
            placeholder: intl.formatMessage({ id: "page.name" }),
            value: pageName,
            onChange: handleTextFieldChange,
            onKeyDown: handleTextFieldKeyDown,
            icon: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(Pencil1Icon, {})
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(Divider, {}),
        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(DialogAction, { onSelect: handleDuplicate, children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(FormattedMessage, { id: "duplicate" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(DialogAction, { disabled: !canDelete, onSelect: handleDelete, children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(FormattedMessage, { id: "delete" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(Divider, {}),
        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)($905f4ae918aab1aa$export$848c9b7ead0df967, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(RowButton, { children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(FormattedMessage, { id: "cancel" }) }) })
      ] })
    ] })
  ] });
}
var StyledDialogContent = styled($905f4ae918aab1aa$export$7c6e2c02157bb7d2, {
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  minWidth: 240,
  maxWidth: "fit-content",
  maxHeight: "85vh",
  marginTop: "-5vh",
  pointerEvents: "all",
  backgroundColor: "$panel",
  padding: "$1",
  borderRadius: "$2",
  font: "$ui",
  zIndex: 999999,
  "&:focus": {
    outline: "none"
  }
});
var StyledDialogOverlay2 = styled($905f4ae918aab1aa$export$c6fdb837b070b4ff, {
  backgroundColor: "rgba(0, 0, 0, .15)",
  position: "absolute",
  pointerEvents: "all",
  inset: 0,
  zIndex: 999998
});
function DialogAction({ onSelect, ...rest }) {
  return /* @__PURE__ */ (0, import_jsx_runtime40.jsx)($905f4ae918aab1aa$export$e19cd5f9376f8cee, { asChild: true, onClick: onSelect, onSelect, children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(RowButton, { ...rest }) });
}

// src/components/Tldraw/components/TopPanel/PageMenu/PageMenu.tsx
var import_jsx_runtime41 = require("react/jsx-runtime");
var sortedSelector = (s5) => Object.values(s5.document.pages).sort((a7, b6) => (a7.childIndex || 0) - (b6.childIndex || 0));
var currentPageNameSelector = (s5) => s5.document.pages[s5.appState.currentPageId].name;
var currentPageIdSelector2 = (s5) => s5.document.pages[s5.appState.currentPageId].id;
function PageMenu() {
  const app = useTldrawApp();
  const intl = useIntl();
  const rIsOpen = React27.useRef(false);
  const [isOpen, setIsOpen] = React27.useState(false);
  React27.useEffect(() => {
    if (rIsOpen.current !== isOpen) {
      rIsOpen.current = isOpen;
    }
  }, [isOpen]);
  const handleClose = React27.useCallback(() => {
    setIsOpen(false);
  }, [setIsOpen]);
  const handleOpenChange = React27.useCallback(
    (isOpen2) => {
      if (rIsOpen.current !== isOpen2) {
        setIsOpen(isOpen2);
      }
    },
    [setIsOpen]
  );
  const currentPageName = app.useStore(currentPageNameSelector);
  return /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: "ltr", open: isOpen, onOpenChange: handleOpenChange, children: [
    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { dir: "ltr", asChild: true, id: "TD-Page", children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(ToolButton, { variant: "text", children: currentPageName || intl.formatMessage({ id: "page" }) }) }),
    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(DMContent, { variant: "menu", align: "start", sideOffset: 4, children: isOpen && /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(PageMenuContent, { onClose: handleClose }) })
  ] });
}
function PageMenuContent({ onClose }) {
  const app = useTldrawApp();
  const intl = useIntl();
  const sortedPages = app.useStore(sortedSelector);
  const currentPageId = app.useStore(currentPageIdSelector2);
  const defaultPageName = intl.formatMessage({ id: "page" });
  const handleCreatePage = React27.useCallback(() => {
    const pageName = defaultPageName + " " + (Object.keys(app.document.pages).length + 1);
    app.createPage(void 0, pageName);
  }, [app]);
  const handleChangePage = React27.useCallback(
    (id) => {
      onClose();
      app.changePage(id);
    },
    [app]
  );
  const [dragId, setDragId] = React27.useState(null);
  const [dropIndex, setDropIndex] = React27.useState(null);
  const handleDragStart = React27.useCallback((event_) => {
    setDragId(event_.currentTarget.id);
    setDropIndex(sortedPages.findIndex((p6) => p6.id === event_.currentTarget.id));
    event_.dataTransfer.effectAllowed = "move";
  }, []);
  const handleDrag = React27.useCallback(
    (event_) => {
      event_.preventDefault();
      let dropIndex2 = sortedPages.findIndex((p6) => p6.id === event_.currentTarget.id);
      const rect = event_.currentTarget.getBoundingClientRect();
      const ny = (event_.clientY - rect.top) / rect.height;
      dropIndex2 = ny < 0.5 ? dropIndex2 : dropIndex2 + 1;
      setDropIndex(dropIndex2);
    },
    [dragId, sortedPages]
  );
  const handleDrop = React27.useCallback(() => {
    if (dragId !== null && dropIndex !== null) {
      app.movePage(dragId, dropIndex);
    }
    setDragId(null);
    setDropIndex(null);
  }, [dragId, dropIndex]);
  return /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)(import_jsx_runtime41.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)($d08ef79370b62062$export$a98f0dcb43a68a25, { dir: "ltr", value: currentPageId, onValueChange: handleChangePage, children: sortedPages.map((page, index2) => /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)(ButtonWithOptions, { isDropAbove: index2 === dropIndex && index2 === 0, isDropBelow: dropIndex !== null && index2 === dropIndex - 1, children: [
      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
        $d08ef79370b62062$export$371ab307eab489c0,
        {
          title: page.name || defaultPageName,
          value: page.id,
          id: page.id,
          asChild: true,
          onDragOver: handleDrag,
          onDragStart: handleDragStart,
          onDrop: handleDrop,
          draggable: true,
          children: /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)(PageButton, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("span", { id: page.id, children: page.name || defaultPageName }),
            /* @__PURE__ */ (0, import_jsx_runtime41.jsx)($d08ef79370b62062$export$c3468e2714d175fa, { children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(SmallIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(CheckIcon, {}) }) })
          ] })
        },
        page.id
      ),
      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(PageOptionsDialog, { page, onClose })
    ] }, page.id)) }),
    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(Divider, {}),
    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { onSelect: handleCreatePage, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)(RowButton, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("span", { children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(FormattedMessage, { id: "create.page" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(SmallIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(PlusIcon, {}) })
    ] }) })
  ] });
}
var ButtonWithOptions = styled("div", {
  position: "relative",
  display: "grid",
  gridTemplateColumns: "1fr auto",
  gridAutoFlow: "column",
  margin: 0,
  '& > *[data-shy="true"]': {
    opacity: 0
  },
  '&:hover > *[data-shy="true"]': {
    opacity: 1
  },
  variants: {
    isDropAbove: {
      true: {
        "&::after": {
          content: "",
          display: "block",
          position: "absolute",
          top: 0,
          width: "100%",
          height: "1px",
          backgroundColor: "$selected",
          zIndex: 999,
          pointerEvents: "none"
        }
      }
    },
    isDropBelow: {
      true: {
        "&::after": {
          content: "",
          display: "block",
          position: "absolute",
          width: "100%",
          height: "1px",
          top: "100%",
          backgroundColor: "$selected",
          zIndex: 999,
          pointerEvents: "none"
        }
      }
    }
  }
});
var PageButton = styled(RowButton, {
  minWidth: 128
});

// src/components/Tldraw/components/TopPanel/StyleMenu/StyleMenu.tsx
var React46 = __toESM(require("react"));

// src/components/Tldraw/state/shapes/shared/getBoundsRectangle.ts
function getBoundsRectangle(shape, boundsCache) {
  const bounds = C3.getFromCache(boundsCache, shape, () => {
    const [width, height] = shape.size;
    return {
      minX: 0,
      maxX: width,
      minY: 0,
      maxY: height,
      width,
      height
    };
  });
  return C3.translateBounds(bounds, shape.point);
}

// src/components/Tldraw/state/shapes/shared/getTextAlign.ts
var ALIGN_VALUES = {
  ["start" /* Start */]: "left",
  ["middle" /* Middle */]: "center",
  ["end" /* End */]: "right",
  ["justify" /* Justify */]: "justify"
};
function getTextAlign(alignStyle = "start" /* Start */) {
  return ALIGN_VALUES[alignStyle];
}

// src/components/Tldraw/constants.ts
var LETTER_SPACING = "0";
var GRID_SIZE = 8;
var SVG_EXPORT_PADDING = 16;
var BINDING_DISTANCE = 16;
var CLONING_DISTANCE = 32;
var FIT_TO_SCREEN_PADDING = 128;
var SNAP_DISTANCE = 5;
var SLOW_SPEED = 10;
var GHOSTED_OPACITY = 0.3;
var DEAD_ZONE = 3;
var LABEL_POINT = [0.5, 0.5];
var PI2 = Math.PI * 2;
var EASINGS = {
  linear: (t5) => t5,
  easeInQuad: (t5) => t5 * t5,
  easeOutQuad: (t5) => t5 * (2 - t5),
  easeInOutQuad: (t5) => t5 < 0.5 ? 2 * t5 * t5 : -1 + (4 - 2 * t5) * t5,
  easeInCubic: (t5) => t5 * t5 * t5,
  easeOutCubic: (t5) => --t5 * t5 * t5 + 1,
  easeInOutCubic: (t5) => t5 < 0.5 ? 4 * t5 * t5 * t5 : (t5 - 1) * (2 * t5 - 2) * (2 * t5 - 2) + 1,
  easeInQuart: (t5) => t5 * t5 * t5 * t5,
  easeOutQuart: (t5) => 1 - --t5 * t5 * t5 * t5,
  easeInOutQuart: (t5) => t5 < 0.5 ? 8 * t5 * t5 * t5 * t5 : 1 - 8 * --t5 * t5 * t5 * t5,
  easeInQuint: (t5) => t5 * t5 * t5 * t5 * t5,
  easeOutQuint: (t5) => 1 + --t5 * t5 * t5 * t5 * t5,
  easeInOutQuint: (t5) => t5 < 0.5 ? 16 * t5 * t5 * t5 * t5 * t5 : 1 + 16 * --t5 * t5 * t5 * t5 * t5,
  easeInSine: (t5) => 1 - Math.cos(t5 * Math.PI / 2),
  easeOutSine: (t5) => Math.sin(t5 * Math.PI / 2),
  easeInOutSine: (t5) => -(Math.cos(Math.PI * t5) - 1) / 2,
  easeInExpo: (t5) => t5 <= 0 ? 0 : Math.pow(2, 10 * t5 - 10),
  easeOutExpo: (t5) => t5 >= 1 ? 1 : 1 - Math.pow(2, -10 * t5),
  easeInOutExpo: (t5) => t5 <= 0 ? 0 : t5 >= 1 ? 1 : t5 < 0.5 ? Math.pow(2, 20 * t5 - 10) / 2 : (2 - Math.pow(2, -20 * t5 + 10)) / 2
};
var isSafari = typeof Window === "undefined" ? false : /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
var isLinux = typeof Window === "undefined" ? false : /linux/i.test(navigator.userAgent);
var IMAGE_EXTENSIONS = [".png", ".svg", ".jpg", ".jpeg", ".gif"];

// src/components/Tldraw/state/shapes/shared/getTextSize.ts
var melm;
function getMeasurementDiv() {
  document.querySelector("#__textLabelMeasure")?.remove();
  const pre = document.createElement("pre");
  pre.id = "__textLabelMeasure";
  Object.assign(pre.style, {
    whiteSpace: "pre",
    width: "auto",
    border: "1px solid transparent",
    padding: "4px",
    margin: "0px",
    letterSpacing: LETTER_SPACING,
    opacity: "0",
    position: "absolute",
    top: "-500px",
    left: "0px",
    zIndex: "9999",
    pointerEvents: "none",
    userSelect: "none",
    alignmentBaseline: "mathematical",
    dominantBaseline: "mathematical"
  });
  pre.tabIndex = -1;
  document.body.appendChild(pre);
  return pre;
}
if (typeof window !== "undefined") {
  melm = getMeasurementDiv();
}
var prevText = "";
var prevFont = "";
var prevSize = [0, 0];
function clearPrevSize() {
  prevText = "";
}
function getTextLabelSize(text, font) {
  if (!text) {
    return [16, 32];
  }
  if (!melm) {
    return [10, 10];
  }
  if (!melm.parent)
    document.body.appendChild(melm);
  if (text === prevText && font === prevFont) {
    return prevSize;
  }
  prevText = text;
  prevFont = font;
  melm.textContent = text;
  melm.style.font = font;
  const width = melm.offsetWidth || 1;
  const height = melm.offsetHeight || 1;
  prevSize = [width, height];
  return prevSize;
}

// src/components/Tldraw/state/shapes/shared/getTextSvgElement.ts
var wordSeparator = new RegExp(`${[32, 160, 4961, 65792, 65793, 4153, 4241].map((c5) => String.fromCodePoint(c5)).join("|")}`);
function getTextSvgElement(text, fontSize, fontFamily, textAlign, width, wrap = false) {
  const fontWeight = "normal";
  const lineHeight = 1;
  const letterSpacingPct = LETTER_SPACING;
  const lines = breakText({
    text,
    wrap,
    width,
    fontSize,
    fontWeight,
    fontFamily,
    fontStyle: "normal",
    textAlign: "left",
    letterSpacing: LETTER_SPACING,
    lineHeight: 1
  });
  const textElm = document.createElementNS("http://www.w3.org/2000/svg", "text");
  textElm.setAttribute("font-size", fontSize + "px");
  textElm.setAttribute("font-family", fontFamily);
  textElm.setAttribute("font-weight", fontWeight);
  textElm.setAttribute("line-height", lineHeight * fontSize + "px");
  textElm.setAttribute("letter-spacing", letterSpacingPct);
  textElm.setAttribute("text-align", textAlign ?? "left");
  textElm.setAttribute("dominant-baseline", "mathematical");
  textElm.setAttribute("alignment-baseline", "mathematical");
  const textLines = lines.map((line, i4) => {
    const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    tspan.textContent = line + "\n";
    tspan.setAttribute("y", lineHeight * fontSize * (i4 + 0.5) + "px");
    textElm.appendChild(tspan);
    return tspan;
  });
  switch (textAlign) {
    case "middle" /* Middle */: {
      textElm.setAttribute("text-align", "center");
      textElm.setAttribute("text-anchor", "middle");
      textLines.forEach((textElm2) => textElm2.setAttribute("x", 4 + width / 2 + ""));
      break;
    }
    case "end" /* End */: {
      textElm.setAttribute("text-align", "right");
      textElm.setAttribute("text-anchor", "end");
      textLines.forEach((textElm2) => textElm2.setAttribute("x", 4 + width + ""));
      break;
    }
    default: {
      textElm.setAttribute("text-align", "left");
      textElm.setAttribute("text-anchor", "start");
      textLines.forEach((textElm2) => textElm2.setAttribute("x", "4"));
    }
  }
  return textElm;
}
function breakText(opts) {
  const textElm = document.createElement("div");
  textElm.style.setProperty("position", "absolute");
  textElm.style.setProperty("top", "-9999px");
  textElm.style.setProperty("left", "-9999px");
  textElm.style.setProperty("width", opts.width + "px");
  textElm.style.setProperty("height", "min-content");
  textElm.style.setProperty("font-size", opts.fontSize + "px");
  textElm.style.setProperty("font-family", opts.fontFamily);
  textElm.style.setProperty("font-weight", opts.fontWeight);
  textElm.style.setProperty("line-height", opts.lineHeight * opts.fontSize + "px");
  textElm.style.setProperty("letter-spacing", opts.letterSpacing);
  textElm.style.setProperty("text-align", opts.textAlign);
  document.body.appendChild(textElm);
  const words = opts.text.split(wordSeparator).flatMap((word) => word.replace("\n", " \n")).join(" ").split(" ");
  textElm.innerText = words[0];
  let prevHeight = textElm.offsetHeight;
  let currentLine = [words[0]];
  const lines = [currentLine];
  for (let i4 = 1; i4 < words.length; i4++) {
    const word = words[i4];
    textElm.innerText += " " + word;
    const newHeight = textElm.offsetHeight;
    if (newHeight > prevHeight) {
      prevHeight = newHeight;
      currentLine = [];
      lines.push(currentLine);
    }
    currentLine.push(word);
  }
  textElm.remove();
  return lines.map((line) => line.join(" "));
}

// src/components/Tldraw/state/shapes/shared/LabelMask.tsx
var import_jsx_runtime42 = require("react/jsx-runtime");
function LabelMask({ id, bounds, labelSize, offset, scale = 1 }) {
  return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime42.jsxs)("mask", { id: id + "_clip", children: [
    /* @__PURE__ */ (0, import_jsx_runtime42.jsx)("rect", { x: -100, y: -100, width: bounds.width + 200, height: bounds.height + 200, fill: "white" }),
    /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
      "rect",
      {
        x: bounds.width / 2 - labelSize[0] / 2 * scale + (offset?.[0] || 0),
        y: bounds.height / 2 - labelSize[1] / 2 * scale + (offset?.[1] || 0),
        width: labelSize[0] * scale,
        height: labelSize[1] * scale,
        rx: 4 * scale,
        ry: 4 * scale,
        fill: "black",
        opacity: Math.max(scale, 0.8)
      }
    )
  ] }) });
}

// src/components/Tldraw/state/shapes/shared/PolygonUtils.ts
var PI22 = Math.PI * 2;
var _PolygonUtils = class {
  static inwardEdgeNormal(edge) {
    const delta = p.sub(edge[1], edge[0]);
    const len = p.len2(delta);
    return [-delta[0] / len, delta[1] / len];
  }
  static outwardEdgeNormal(edge) {
    return p.neg(_PolygonUtils.inwardEdgeNormal(edge));
  }
  static isReflexVertex(polygon, index2) {
    const len = polygon.length;
    const v0 = polygon[(index2 + len - 1) % len];
    const v1 = polygon[index2];
    const v22 = polygon[(index2 + 1) % len];
    if (_PolygonUtils.leftSide(v0, v22, v1) < 0)
      return true;
    return false;
  }
  static getEdges(vertices) {
    return vertices.map((vert, i4) => [vert, vertices[(i4 + 1) % vertices.length]]);
  }
  // based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, A => "line a", B => "line b"
  static edgesIntersection([A1, A22], [B1, B22]) {
    const den = (B22[1] - B1[1]) * (A22[0] - A1[0]) - (B22[0] - B1[0]) * (A22[1] - A1[1]);
    if (den == 0)
      return null;
    const ua = ((B22[0] - B1[0]) * (A1[1] - B1[1]) - (B22[1] - B1[1]) * (A1[0] - B1[0])) / den;
    const ub = ((A22[0] - A1[0]) * (A1[1] - B1[1]) - (A22[1] - A1[1]) * (A1[0] - B1[0])) / den;
    if (ua < 0 || ub < 0 || ua > 1 || ub > 1)
      return null;
    return [A1[0] + ua * (A22[0] - A1[0]), A1[1] + ua * (A22[1] - A1[1])];
  }
  static appendArc(polygon, center, radius, startVertex, endVertex, isPaddingBoundary = false) {
    const vertices = [...polygon];
    let startAngle = Math.atan2(startVertex[1] - center[1], startVertex[0] - center[0]);
    let endAngle = Math.atan2(endVertex[1] - center[1], endVertex[0] - center[0]);
    if (startAngle < 0)
      startAngle += PI22;
    if (endAngle < 0)
      endAngle += PI22;
    const arcSegmentCount = 5;
    const angle = startAngle > endAngle ? startAngle - endAngle : startAngle + PI22 - endAngle;
    const angle5 = (isPaddingBoundary ? -angle : PI22 - angle) / arcSegmentCount;
    vertices.push(startVertex);
    for (let i4 = 1; i4 < arcSegmentCount; ++i4) {
      const angle2 = startAngle + angle5 * i4;
      vertices.push([center[0] + Math.cos(angle2) * radius, center[1] + Math.sin(angle2) * radius]);
    }
    vertices.push(endVertex);
    return vertices;
  }
  static createOffsetEdge(edge, offset) {
    return edge.map((vert) => p.add(vert, offset));
  }
  static getOffsetPolygon(polygon, offset = 0) {
    const edges = _PolygonUtils.getEdges(polygon);
    const offsetEdges = edges.map((edge) => _PolygonUtils.createOffsetEdge(edge, p.mul(_PolygonUtils.outwardEdgeNormal(edge), offset)));
    const vertices = [];
    for (let i4 = 0; i4 < offsetEdges.length; i4++) {
      const thisEdge = offsetEdges[i4];
      const prevEdge = offsetEdges[(i4 + offsetEdges.length - 1) % offsetEdges.length];
      const vertex = _PolygonUtils.edgesIntersection(prevEdge, thisEdge);
      if (vertex)
        vertices.push(vertex);
      else {
        _PolygonUtils.appendArc(vertices, edges[i4][0], offset, prevEdge[1], thisEdge[0], false);
      }
    }
    return vertices;
  }
  static createPaddingPolygon(polygon, shapePadding = 0) {
    const offsetEdges = polygon.map((edge) => _PolygonUtils.createOffsetEdge(edge, _PolygonUtils.inwardEdgeNormal(edge)));
    const vertices = [];
    for (let i4 = 0; i4 < offsetEdges.length; i4++) {
      const thisEdge = offsetEdges[i4];
      const prevEdge = offsetEdges[(i4 + offsetEdges.length - 1) % offsetEdges.length];
      const vertex = _PolygonUtils.edgesIntersection(prevEdge, thisEdge);
      if (vertex)
        vertices.push(vertex);
      else {
        _PolygonUtils.appendArc(vertices, polygon[i4][0], shapePadding, prevEdge[1], thisEdge[0], true);
      }
    }
    return vertices;
  }
};
var PolygonUtils = _PolygonUtils;
// If the slope of line v1,v2 greater than the slope of v1,p then p is on the left side of v1,v2 and the return value is > 0.
// If p is colinear with v1,v2 then return 0, otherwise return a value < 0.
__publicField(PolygonUtils, "leftSide", p.isLeft);
function getOffsetPolygon(points, offset) {
  if (points.length < 3)
    throw new Error("Polygon must have at least 3 points");
  const len = points.length;
  return points.map((point, i4) => [point, points[(i4 + 1) % len]]).map(([A6, B5]) => {
    const offsetVector = p.mul(p.per(p.uni(p.sub(B5, A6))), offset);
    return [p.add(A6, offsetVector), p.add(B5, offsetVector)];
  }).map((edge, i4, edges) => {
    const intersection = ie2(edge, edges[(i4 + 1) % edges.length]);
    if (intersection === void 0)
      throw new Error("Expected an intersection");
    return intersection;
  });
}

// src/components/Tldraw/state/shapes/shared/shape-styles.ts
var canvasLight = "#fafafa";
var canvasDark = "#343d45";
var colors = {
  ["white" /* White */]: "#f0f1f3",
  ["lightGray" /* LightGray */]: "#c6cbd1",
  ["gray" /* Gray */]: "#788492",
  ["black" /* Black */]: "#1d1d1d",
  ["green" /* Green */]: "#36b24d",
  ["cyan" /* Cyan */]: "#0e98ad",
  ["blue" /* Blue */]: "#1c7ed6",
  ["indigo" /* Indigo */]: "#4263eb",
  ["violet" /* Violet */]: "#7746f1",
  ["red" /* Red */]: "#ff2133",
  ["orange" /* Orange */]: "#ff9433",
  ["yellow" /* Yellow */]: "#ffc936"
};
var stickyFills = {
  light: {
    ...Object.fromEntries(Object.entries(colors).map(([k7, v6]) => [k7, C3.lerpColor(v6, canvasLight, 0.45)])),
    ["white" /* White */]: "#ffffff",
    ["black" /* Black */]: "#3d3d3d"
  },
  dark: {
    ...Object.fromEntries(Object.entries(colors).map(([k7, v6]) => [k7, C3.lerpColor(C3.lerpColor(v6, "#999999", 0.3), canvasDark, 0.4)])),
    ["white" /* White */]: "#1d1d1d",
    ["black" /* Black */]: "#bbbbbb"
  }
};
var strokes = {
  light: {
    ...colors,
    ["white" /* White */]: "#1d1d1d"
  },
  dark: {
    ...Object.fromEntries(Object.entries(colors).map(([k7, v6]) => [k7, C3.lerpColor(v6, canvasDark, 0.1)])),
    ["white" /* White */]: "#cecece",
    ["black" /* Black */]: "#cecece"
  }
};
var fills = {
  light: {
    ...Object.fromEntries(Object.entries(colors).map(([k7, v6]) => [k7, C3.lerpColor(v6, canvasLight, 0.82)])),
    ["white" /* White */]: "#fefefe"
  },
  dark: {
    ...Object.fromEntries(Object.entries(colors).map(([k7, v6]) => [k7, C3.lerpColor(v6, canvasDark, 0.82)])),
    ["white" /* White */]: "rgb(30,33,37)",
    ["black" /* Black */]: "#1e1e1f"
  }
};
var strokeWidths = {
  ["small" /* Small */]: 2,
  ["medium" /* Medium */]: 3.5,
  ["large" /* Large */]: 5
};
var fontSizes = {
  ["small" /* Small */]: 28,
  ["medium" /* Medium */]: 48,
  ["large" /* Large */]: 96,
  auto: "auto"
};
var fontFaces = {
  ["script" /* Script */]: '"Caveat Brush"',
  ["sans" /* Sans */]: '"Source Sans Pro"',
  ["serif" /* Serif */]: '"Crimson Pro"',
  ["mono" /* Mono */]: '"Source Code Pro"'
};
var fontSizeModifiers = {
  ["script" /* Script */]: 1,
  ["sans" /* Sans */]: 1,
  ["serif" /* Serif */]: 1,
  ["mono" /* Mono */]: 1
};
var stickyFontSizes = {
  ["small" /* Small */]: 24,
  ["medium" /* Medium */]: 36,
  ["large" /* Large */]: 48,
  auto: "auto"
};
function getStrokeWidth(size) {
  return strokeWidths[size];
}
function getFontSize(size, fontStyle = "script" /* Script */) {
  return fontSizes[size] * fontSizeModifiers[fontStyle];
}
function getFontFace(font = "script" /* Script */) {
  return fontFaces[font];
}
function getStickyFontSize(size) {
  return stickyFontSizes[size];
}
function getFontStyle(style) {
  const fontSize = getFontSize(style.size, style.font);
  const tiddlywikiFontSetting = typeof $tw === "undefined" ? void 0 : $tw.wiki.getTiddlerText("$:/themes/tiddlywiki/vanilla/settings/fontfamily");
  const fontFace = tiddlywikiFontSetting ?? getFontFace(style.font);
  const { scale = 1 } = style;
  return `${fontSize * scale}px/1 ${fontFace}`;
}
function getStickyFontStyle(style) {
  const fontSize = getStickyFontSize(style.size);
  const fontFace = getFontFace(style.font);
  const { scale = 1 } = style;
  return `${fontSize * scale}px/1 ${fontFace}`;
}
function getStickyShapeStyle(style) {
  const { color } = style;
  const theme = "light";
  const adjustedColor = color === "white" /* White */ || color === "black" /* Black */ ? "yellow" /* Yellow */ : color;
  return {
    fill: stickyFills[theme][adjustedColor],
    stroke: strokes[theme][adjustedColor],
    color: "#0d0d0d"
  };
}
function getShapeStyle(style) {
  const { color, size, isFilled } = style;
  const strokeWidth = getStrokeWidth(size);
  const theme = "light";
  return {
    stroke: strokes[theme][color],
    fill: isFilled ? fills[theme][color] : "none",
    strokeWidth
  };
}
var defaultStyle = {
  color: "black" /* Black */,
  size: "small" /* Small */,
  isFilled: false,
  dash: "draw" /* Draw */,
  scale: 1
};
var defaultTextStyle = {
  ...defaultStyle,
  font: "script" /* Script */,
  textAlign: "middle" /* Middle */
};

// src/components/Tldraw/state/shapes/shared/TextAreaUtils.ts
var INDENT = "  ";
var TextAreaUtils = class {
  static insertTextFirefox(field, text) {
    field.setRangeText(
      text,
      field.selectionStart || 0,
      field.selectionEnd || 0,
      "end"
      // Without this, the cursor is either at the beginning or `text` remains selected
    );
    field.dispatchEvent(
      new InputEvent("input", {
        data: text,
        inputType: "insertText",
        isComposing: false
        // TODO: fix @types/jsdom, this shouldn't be required
      })
    );
  }
  /** Inserts `text` at the cursors position, replacing any selection, with **undo** support and by firing the `input` event. */
  static insert(field, text) {
    const document2 = field.ownerDocument;
    const initialFocus = document2.activeElement;
    if (initialFocus !== field) {
      field.focus();
    }
    if (!document2.execCommand("insertText", false, text)) {
      TextAreaUtils.insertTextFirefox(field, text);
    }
    if (initialFocus === document2.body) {
      field.blur();
    } else if (initialFocus instanceof HTMLElement && initialFocus !== field) {
      initialFocus.focus();
    }
  }
  /** Replaces the entire content, equivalent to `field.value = text` but with **undo** support and by firing the `input` event. */
  static set(field, text) {
    field.select();
    TextAreaUtils.insert(field, text);
  }
  /** Get the selected text in a field or an empty string if nothing is selected. */
  static getSelection(field) {
    const { selectionStart, selectionEnd } = field;
    return field.value.slice(selectionStart || void 0, selectionEnd || void 0);
  }
  /** Adds the `wrappingText` before and after fields selection (or cursor). If `endWrappingText` is provided, it will be used instead of `wrappingText` at on the right. */
  static wrapSelection(field, wrap, wrapEnd) {
    const { selectionStart, selectionEnd } = field;
    const selection = TextAreaUtils.getSelection(field);
    TextAreaUtils.insert(field, wrap + selection + (wrapEnd ?? wrap));
    field.selectionStart = (selectionStart || 0) + wrap.length;
    field.selectionEnd = (selectionEnd || 0) + wrap.length;
  }
  /** Finds and replaces strings and regex in the fields value, like `field.value = field.value.replace()` but better */
  static replace(field, searchValue, replacer) {
    let drift = 0;
    field.value.replace(searchValue, (...args) => {
      const matchStart = drift + args[args.length - 2];
      const matchLength = args[0].length;
      field.selectionStart = matchStart;
      field.selectionEnd = matchStart + matchLength;
      const replacement = typeof replacer === "string" ? replacer : replacer(...args);
      TextAreaUtils.insert(field, replacement);
      field.selectionStart = matchStart;
      drift += replacement.length - matchLength;
      return replacement;
    });
  }
  static findLineEnd(value, currentEnd) {
    const lastLineStart = value.lastIndexOf("\n", currentEnd - 1) + 1;
    if (value.charAt(lastLineStart) !== "	") {
      return currentEnd;
    }
    return lastLineStart + 1;
  }
  static indent(element) {
    const { selectionStart, selectionEnd, value } = element;
    const selectedContrast = value.slice(selectionStart, selectionEnd);
    const lineBreakCount = /\n/g.exec(selectedContrast)?.length;
    if (lineBreakCount && lineBreakCount > 0) {
      const firstLineStart = value.lastIndexOf("\n", selectionStart - 1) + 1;
      const newSelection = element.value.slice(firstLineStart, selectionEnd - 1);
      const indentedText = newSelection.replace(
        /^|\n/g,
        // Match all line starts
        `$&${INDENT}`
      );
      const replacementsCount = indentedText.length - newSelection.length;
      element.setSelectionRange(firstLineStart, selectionEnd - 1);
      TextAreaUtils.insert(element, indentedText);
      element.setSelectionRange(selectionStart + 1, selectionEnd + replacementsCount);
    } else {
      TextAreaUtils.insert(element, INDENT);
    }
  }
  // The first line should always be unindented
  // The last line should only be unindented if the selection includes any characters after `\n`
  static unindent(element) {
    const { selectionStart, selectionEnd, value } = element;
    const firstLineStart = value.lastIndexOf("\n", selectionStart - 1) + 1;
    const minimumSelectionEnd = TextAreaUtils.findLineEnd(value, selectionEnd);
    const newSelection = element.value.slice(firstLineStart, minimumSelectionEnd);
    const indentedText = newSelection.replace(/(^|\n)(\t| {1,2})/g, "$1");
    const replacementsCount = newSelection.length - indentedText.length;
    element.setSelectionRange(firstLineStart, minimumSelectionEnd);
    TextAreaUtils.insert(element, indentedText);
    const firstLineIndentation = /\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart));
    const difference = firstLineIndentation ? firstLineIndentation[0].length : 0;
    const newSelectionStart = selectionStart - difference;
    element.setSelectionRange(selectionStart - difference, Math.max(newSelectionStart, selectionEnd - replacementsCount));
  }
};

// src/components/Tldraw/state/shapes/shared/TextLabel.tsx
var React45 = __toESM(require("react"));

// src/components/Tldraw/state/StateManager/copy.ts
function deepCopy(target) {
  if (target === null) {
    return target;
  }
  if (target instanceof Date) {
    return new Date(target.getTime());
  }
  if (typeof target === "object") {
    if (typeof target[Symbol.iterator] === "function") {
      const cp = [];
      if (target.length > 0) {
        for (const arrayMember of target) {
          cp.push(deepCopy(arrayMember));
        }
      }
      return cp;
    } else {
      const targetKeys = Object.keys(target);
      const cp = {};
      if (targetKeys.length > 0) {
        for (const key of targetKeys) {
          cp[key] = deepCopy(target[key]);
        }
      }
      return cp;
    }
  }
  return target;
}

// src/components/Tldraw/state/shapes/ArrowUtil/ArrowUtil.tsx
var React31 = __toESM(require("react"));

// src/components/Tldraw/state/shapes/TDShapeUtil.tsx
var React28 = __toESM(require("react"));
var TDShapeUtil = class extends _e2 {
  canBind = false;
  canEdit = false;
  canClone = false;
  isAspectRatioLocked = false;
  hideResizeHandles = false;
  bindingDistance = BINDING_DISTANCE;
  hitTestPoint = (shape, point) => {
    return C3.pointInBounds(point, this.getRotatedBounds(shape));
  };
  hitTestLineSegment = (shape, A6, B5) => {
    const box = C3.getBoundsFromPoints([A6, B5]);
    const bounds = this.getBounds(shape);
    return C3.boundsContain(bounds, box) || shape.rotation ? S(A6, B5, C3.getRotatedCorners(this.getBounds(shape))).didIntersect : ce2(A6, B5, this.getBounds(shape)).length > 0;
  };
  create = (props) => {
    this.refMap.set(props.id, React28.createRef());
    return this.getShape(props);
  };
  getCenter = (shape) => {
    return C3.getBoundsCenter(this.getBounds(shape));
  };
  getExpandedBounds = (shape) => {
    return C3.expandBounds(this.getBounds(shape), this.bindingDistance);
  };
  getBindingPoint = (shape, fromShape, point, origin, direction, bindAnywhere) => {
    const bounds = this.getBounds(shape);
    const expandedBounds = this.getExpandedBounds(shape);
    if (!C3.pointInBounds(point, expandedBounds))
      return;
    const intersections = se2(origin, direction, expandedBounds).filter((int) => int.didIntersect).map((int) => int.points[0]);
    if (intersections.length === 0)
      return;
    const center = this.getCenter(shape);
    const intersection = intersections.sort((a7, b6) => e.dist(b6, origin) - e.dist(a7, origin))[0];
    const middlePoint = e.med(point, intersection);
    let anchor;
    let distance;
    if (bindAnywhere) {
      anchor = e.dist(point, center) < BINDING_DISTANCE / 2 ? center : point;
      distance = 0;
    } else {
      if (e.distanceToLineSegment(point, middlePoint, center) < BINDING_DISTANCE / 2) {
        anchor = center;
      } else {
        anchor = middlePoint;
      }
      if (C3.pointInBounds(point, bounds)) {
        distance = this.bindingDistance;
      } else {
        distance = Math.max(
          this.bindingDistance,
          C3.getBoundsSides(bounds).map((side) => e.distanceToLineSegment(side[1][0], side[1][1], point)).sort((a7, b6) => a7 - b6)[0]
        );
      }
    }
    const bindingPoint = e.divV(e.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [expandedBounds.width, expandedBounds.height]);
    return {
      point: e.clampV(bindingPoint, 0, 1),
      distance
    };
  };
  mutate = (shape, props) => {
    return props;
  };
  transform = (shape, bounds, info) => {
    return { ...shape, point: [bounds.minX, bounds.minY] };
  };
  transformSingle = (shape, bounds, info) => {
    return this.transform(shape, bounds, info);
  };
  updateChildren;
  onChildrenChange;
  onHandleChange;
  onRightPointHandle;
  onDoubleClickHandle;
  onDoubleClickBoundsHandle;
  onSessionComplete;
  getSvgElement = (shape) => {
    const elm = document.getElementById(shape.id + "_svg")?.cloneNode(true);
    if (!elm)
      return;
    const hasLabel = shape.label?.trim()?.length ?? 0 > 0;
    if (hasLabel) {
      const s5 = shape;
      const g6 = document.createElementNS("http://www.w3.org/2000/svg", "g");
      const font = getFontStyle(shape.style);
      const labelSize = getTextLabelSize(shape.label, font);
      const fontSize = getFontSize(shape.style.size, shape.style.font) * (shape.style.scale ?? 1);
      const fontFamily = getFontFace(shape.style.font).slice(1, -1);
      const labelElm = getTextSvgElement(s5.label, fontSize, fontFamily, "middle" /* Middle */, labelSize[0], false);
      const bounds = this.getBounds(shape);
      labelElm.setAttribute("transform", `translate(${bounds.width / 2 - labelSize[0] / 2}, ${bounds.height / 2 - labelSize[1] / 2})`);
      labelElm.setAttribute("fill", getShapeStyle(shape.style).stroke);
      labelElm.setAttribute("transform-origin", "center center");
      g6.setAttribute("text-align", "center");
      g6.setAttribute("text-anchor", "middle");
      g6.appendChild(elm);
      g6.appendChild(labelElm);
      return g6;
    }
    return elm;
  };
};

// src/components/Tldraw/state/shapes/ArrowUtil/arrowHelpers.ts
function getArrowArcPath(start, end, circle, bend) {
  return ["M", start[0], start[1], "A", circle[2], circle[2], 0, 0, bend < 0 ? 0 : 1, end[0], end[1]].join(" ");
}
function getBendPoint(handles, bend) {
  const { start, end } = handles;
  const dist = p.dist(start.point, end.point);
  const midPoint = p.med(start.point, end.point);
  const bendDist = dist / 2 * bend;
  const u5 = p.uni(p.vec(start.point, end.point));
  const point = p.toFixed(Math.abs(bendDist) < 10 ? midPoint : p.add(midPoint, p.mul(p.per(u5), bendDist)));
  return point;
}
function renderFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd) {
  const getRandom = C3.rng(id);
  const strokeWidth = getShapeStyle(style).strokeWidth;
  const startPoint = decorationStart ? p.nudge(start, end, strokeWidth) : start;
  const endPoint = decorationEnd ? p.nudge(end, start, strokeWidth) : end;
  const stroke = _e([startPoint, endPoint], {
    size: strokeWidth,
    thinning: 0.618 + getRandom() * 0.2,
    easing: EASINGS.easeOutQuad,
    simulatePressure: true,
    streamline: 0,
    last: true
  });
  return C3.getSvgPathFromStroke(stroke);
}
function renderCurvedFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd, center, radius, length, easing) {
  const getRandom = C3.rng(id);
  const strokeWidth = getShapeStyle(style).strokeWidth;
  const startPoint = decorationStart ? p.rotWith(start, center, strokeWidth / length) : start;
  const endPoint = decorationEnd ? p.rotWith(end, center, -(strokeWidth / length)) : end;
  const startAngle = p.angle(center, startPoint);
  const endAngle = p.angle(center, endPoint);
  const points = [];
  const count = 8 + Math.floor(Math.abs(length) / 20 * 1 + getRandom() / 2);
  for (let i4 = 0; i4 < count; i4++) {
    const t5 = easing(i4 / count);
    const angle = C3.lerpAngles(startAngle, endAngle, t5);
    points.push(p.toFixed(p.nudgeAtAngle(center, angle, radius)));
  }
  const stroke = _e([startPoint, ...points, endPoint], {
    size: 1 + strokeWidth,
    thinning: 0.618 + getRandom() * 0.2,
    easing: EASINGS.easeOutQuad,
    simulatePressure: false,
    streamline: 0,
    last: true
  });
  return C3.getSvgPathFromStroke(stroke);
}
function getCtp(start, bend, end) {
  return C3.circleFromThreePoints(start, end, bend);
}
function getCurvedArrowHeadPoints(A6, r1, C6, r22, sweep) {
  const ints = le(A6, r1 * 0.618, C6, r22).points;
  if (!ints) {
    TLDR.warn("Could not find an intersection for the arrow head.");
    return { left: A6, right: A6 };
  }
  const int = sweep ? ints[0] : ints[1];
  const left = int ? p.nudge(p.rotWith(int, A6, Math.PI / 6), A6, r1 * -0.382) : A6;
  const right = int ? p.nudge(p.rotWith(int, A6, -Math.PI / 6), A6, r1 * -0.382) : A6;
  return { left, right };
}
function getStraightArrowHeadPoints(A6, B5, r5) {
  const ints = de2(A6, r5, A6, B5).points;
  if (!ints) {
    TLDR.warn("Could not find an intersection for the arrow head.");
    return { left: A6, right: A6 };
  }
  const int = ints[0];
  const left = int ? p.rotWith(int, A6, Math.PI / 6) : A6;
  const right = int ? p.rotWith(int, A6, -Math.PI / 6) : A6;
  return { left, right };
}
function getCurvedArrowHeadPath(A6, r1, C6, r22, sweep) {
  const { left, right } = getCurvedArrowHeadPoints(A6, r1, C6, r22, sweep);
  return `M ${left} L ${A6} ${right}`;
}
function getStraightArrowHeadPath(A6, B5, r5) {
  const { left, right } = getStraightArrowHeadPoints(A6, B5, r5);
  return `M ${left} L ${A6} ${right}`;
}
function getArrowPath(style, start, bend, end, decorationStart, decorationEnd) {
  const { strokeWidth } = getShapeStyle(style, false);
  const arrowDist = p.dist(start, end);
  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8);
  const path = [];
  const isStraightLine = p.dist(bend, p.toFixed(p.med(start, end))) < 1;
  if (isStraightLine) {
    path.push(`M ${start} L ${end}`);
    if (decorationStart) {
      path.push(getStraightArrowHeadPath(start, end, arrowHeadLength));
    }
    if (decorationEnd) {
      path.push(getStraightArrowHeadPath(end, start, arrowHeadLength));
    }
  } else {
    const circle = getCtp(start, bend, end);
    const center = [circle[0], circle[1]];
    const radius = circle[2];
    const length = getArcLength(center, radius, start, end);
    path.push(`M ${start} A ${radius} ${radius} 0 0 ${length > 0 ? "1" : "0"} ${end}`);
    if (decorationStart)
      path.push(getCurvedArrowHeadPath(start, arrowHeadLength, center, radius, length < 0));
    if (decorationEnd) {
      path.push(getCurvedArrowHeadPath(end, arrowHeadLength, center, radius, length >= 0));
    }
  }
  return path.join(" ");
}
function getArcPoints(start, bend, end) {
  if (p.dist2(bend, p.med(start, end)) <= 4)
    return [start, end];
  const points = [];
  const circle = getCtp(start, bend, end);
  const center = [circle[0], circle[1]];
  const radius = circle[2];
  const startAngle = p.angle(center, start);
  const endAngle = p.angle(center, end);
  for (let i4 = 0; i4 < 20; i4++) {
    const t5 = i4 / 19;
    const angle = C3.lerpAngles(startAngle, endAngle, t5);
    points.push(p.nudgeAtAngle(center, angle, radius));
  }
  return points;
}
function isAngleBetween(a7, b6, c5) {
  if (c5 === a7 || c5 === b6)
    return true;
  const PI24 = Math.PI * 2;
  const AB = (b6 - a7 + PI24) % PI24;
  const AC = (c5 - a7 + PI24) % PI24;
  return AB <= Math.PI !== AC > AB;
}
function getArcLength(C6, r5, A6, B5) {
  const sweep = C3.getSweep(C6, A6, B5);
  return r5 * (2 * Math.PI) * (sweep / (2 * Math.PI));
}

// src/components/Tldraw/state/shapes/ArrowUtil/components/CurvedArrow.tsx.tsx
var React29 = __toESM(require("react"));

// src/components/Tldraw/state/shapes/ArrowUtil/components/ArrowHead.tsx
var import_jsx_runtime43 = require("react/jsx-runtime");
function Arrowhead({ left, middle, right, stroke, strokeWidth }) {
  return /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)("g", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("path", { className: "tl-stroke-hitarea", d: `M ${left} L ${middle} ${right}` }),
    /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
      "path",
      {
        d: `M ${left} L ${middle} ${right}`,
        fill: "none",
        stroke,
        strokeWidth,
        strokeLinecap: "round",
        strokeLinejoin: "round",
        pointerEvents: "none"
      }
    )
  ] });
}

// src/components/Tldraw/state/shapes/ArrowUtil/components/CurvedArrow.tsx.tsx
var import_jsx_runtime44 = require("react/jsx-runtime");
var CurvedArrow = React29.memo(function CurvedArrow2({
  id,
  style,
  start,
  bend,
  end,
  arrowBend,
  decorationStart,
  decorationEnd,
  isDraw
}) {
  const arrowDist = p.dist(start, end);
  if (arrowDist < 2)
    return null;
  const styles = getShapeStyle(style);
  const { strokeWidth } = styles;
  const sw = 1 + strokeWidth * 1.618;
  const circle = getCtp(start, bend, end);
  const center = [circle[0], circle[1]];
  const radius = circle[2];
  const length = getArcLength(center, radius, start, end);
  const getRandom = C3.rng(id);
  const easing = EASINGS[getRandom() > 0 ? "easeInOutSine" : "easeInOutCubic"];
  const path = isDraw ? renderCurvedFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd, center, radius, length, easing) : getArrowArcPath(start, end, circle, arrowBend);
  const { strokeDasharray, strokeDashoffset } = C3.getPerfectDashProps(Math.abs(length), sw, style.dash, 2, false);
  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8);
  const startArrowHead = decorationStart ? getCurvedArrowHeadPoints(start, arrowHeadLength, center, radius, length < 0) : null;
  const endArrowHead = decorationEnd ? getCurvedArrowHeadPoints(end, arrowHeadLength, center, radius, length >= 0) : null;
  return /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)(import_jsx_runtime44.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("path", { className: "tl-stroke-hitarea", d: path }),
    /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(
      "path",
      {
        d: path,
        fill: isDraw ? styles.stroke : "none",
        stroke: styles.stroke,
        strokeWidth: isDraw ? 0 : sw,
        strokeDasharray,
        strokeDashoffset,
        strokeLinecap: "round",
        strokeLinejoin: "round",
        pointerEvents: "none"
      }
    ),
    startArrowHead && /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(Arrowhead, { left: startArrowHead.left, middle: start, right: startArrowHead.right, stroke: styles.stroke, strokeWidth: sw }),
    endArrowHead && /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(Arrowhead, { left: endArrowHead.left, middle: end, right: endArrowHead.right, stroke: styles.stroke, strokeWidth: sw })
  ] });
});

// src/components/Tldraw/state/shapes/ArrowUtil/components/StraightArrow.tsx
var React30 = __toESM(require("react"));
var import_jsx_runtime45 = require("react/jsx-runtime");
var StraightArrow = React30.memo(function StraightArrow2({ id, style, start, end, decorationStart, decorationEnd, isDraw }) {
  const arrowDist = p.dist(start, end);
  if (arrowDist < 2)
    return null;
  const styles = getShapeStyle(style);
  const { strokeWidth } = styles;
  const sw = 1 + strokeWidth * 1.618;
  const path = isDraw ? renderFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd) : "M" + p.toFixed(start) + "L" + p.toFixed(end);
  const { strokeDasharray, strokeDashoffset } = C3.getPerfectDashProps(arrowDist, strokeWidth * 1.618, style.dash, 2, false);
  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8);
  const startArrowHead = decorationStart ? getStraightArrowHeadPoints(start, end, arrowHeadLength) : null;
  const endArrowHead = decorationEnd ? getStraightArrowHeadPoints(end, start, arrowHeadLength) : null;
  return /* @__PURE__ */ (0, import_jsx_runtime45.jsxs)(import_jsx_runtime45.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime45.jsx)("path", { className: "tl-stroke-hitarea", d: path }),
    /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
      "path",
      {
        d: path,
        fill: styles.stroke,
        stroke: styles.stroke,
        strokeWidth: isDraw ? sw / 2 : sw,
        strokeDasharray,
        strokeDashoffset,
        strokeLinecap: "round",
        strokeLinejoin: "round",
        pointerEvents: "stroke"
      }
    ),
    startArrowHead && /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(Arrowhead, { left: startArrowHead.left, middle: start, right: startArrowHead.right, stroke: styles.stroke, strokeWidth: sw }),
    endArrowHead && /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(Arrowhead, { left: endArrowHead.left, middle: end, right: endArrowHead.right, stroke: styles.stroke, strokeWidth: sw })
  ] });
});

// src/components/Tldraw/state/shapes/ArrowUtil/ArrowUtil.tsx
var import_jsx_runtime46 = require("react/jsx-runtime");
var ArrowUtil = class extends TDShapeUtil {
  type = "arrow" /* Arrow */;
  hideBounds = true;
  canEdit = true;
  pathCache = /* @__PURE__ */ new WeakMap();
  getShape = (props) => {
    return {
      id: "id",
      type: "arrow" /* Arrow */,
      name: "Arrow",
      parentId: "page",
      childIndex: 1,
      point: [0, 0],
      rotation: 0,
      bend: 0,
      handles: {
        start: {
          id: "start",
          index: 0,
          point: [0, 0],
          canBind: true,
          ...props.handles?.start
        },
        end: {
          id: "end",
          index: 1,
          point: [1, 1],
          canBind: true,
          ...props.handles?.end
        },
        bend: {
          id: "bend",
          index: 2,
          point: [0.5, 0.5],
          ...props.handles?.bend
        }
      },
      decorations: props.decorations ?? {
        end: "arrow" /* Arrow */
      },
      style: {
        ...defaultStyle,
        isFilled: false,
        ...props.style
      },
      label: "",
      labelPoint: [0.5, 0.5],
      ...props
    };
  };
  Component = TDShapeUtil.Component(({ shape, isEditing, isGhost, meta, events, onShapeChange, onShapeBlur }, ref) => {
    const {
      id,
      label = "",
      handles: { start, bend, end },
      decorations = {},
      style
    } = shape;
    const hasLabel = label?.trim()?.length ?? 0 > 0;
    const isStraightLine = e.dist(bend.point, e.toFixed(e.med(start.point, end.point))) < 1;
    const font = getFontStyle(style);
    const styles = getShapeStyle(style);
    const labelSize = hasLabel || isEditing ? getTextLabelSize(label, font) : [0, 0];
    const bounds = this.getBounds(shape);
    const dist = React31.useMemo(() => {
      const { start: start2, bend: bend2, end: end2 } = shape.handles;
      if (isStraightLine)
        return e.dist(start2.point, end2.point);
      const circle = getCtp(start2.point, bend2.point, end2.point);
      const center = circle.slice(0, 2);
      const radius = circle[2];
      const length = getArcLength(center, radius, start2.point, end2.point);
      return Math.abs(length);
    }, [shape.handles]);
    const scale = Math.max(0.5, Math.min(1, Math.max(dist / (labelSize[1] + 128), dist / (labelSize[0] + 128))));
    const offset = React31.useMemo(() => {
      const bounds2 = this.getBounds(shape);
      const offset2 = e.sub(shape.handles.bend.point, e.toFixed([bounds2.width / 2, bounds2.height / 2]));
      return offset2;
    }, [shape, scale]);
    const handleLabelChange = React31.useCallback(
      (label2) => {
        onShapeChange?.({ id, label: label2 });
      },
      [onShapeChange]
    );
    const Component = isStraightLine ? StraightArrow : CurvedArrow;
    return /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(FullWrapper, { ref, ...events, children: [
      /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
        TextLabel,
        {
          font,
          text: label,
          color: styles.stroke,
          offsetX: offset[0],
          offsetY: offset[1],
          scale,
          isEditing,
          onChange: handleLabelChange,
          onBlur: onShapeBlur
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(te, { id: shape.id + "_svg", children: [
        /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)("mask", { id: shape.id + "_clip", children: [
          /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("rect", { x: -100, y: -100, width: bounds.width + 200, height: bounds.height + 200, fill: "white" }),
          /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
            "rect",
            {
              x: bounds.width / 2 - labelSize[0] / 2 * scale + offset[0],
              y: bounds.height / 2 - labelSize[1] / 2 * scale + offset[1],
              width: labelSize[0] * scale,
              height: labelSize[1] * scale,
              rx: 4 * scale,
              ry: 4 * scale,
              fill: "black",
              opacity: 1
            }
          )
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("g", { pointerEvents: "none", opacity: isGhost ? GHOSTED_OPACITY : 1, mask: hasLabel || isEditing ? `url(#${shape.id}_clip)` : ``, children: /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
          Component,
          {
            id,
            style,
            start: start.point,
            end: end.point,
            bend: bend.point,
            arrowBend: shape.bend,
            decorationStart: decorations?.start,
            decorationEnd: decorations?.end,
            isDraw: style.dash === "draw" /* Draw */
          }
        ) })
      ] })
    ] });
  });
  Indicator = TDShapeUtil.Indicator(({ shape, bounds }) => {
    const {
      style,
      decorations,
      label,
      handles: { start, bend, end }
    } = shape;
    const hasLabel = label?.trim()?.length ?? 0 > 0;
    const font = getFontStyle(style);
    const labelSize = hasLabel ? getTextLabelSize(label, font) : [0, 0];
    const isStraightLine = e.dist(bend.point, e.toFixed(e.med(start.point, end.point))) < 1;
    const dist = React31.useMemo(() => {
      const { start: start2, bend: bend2, end: end2 } = shape.handles;
      if (isStraightLine)
        return e.dist(start2.point, end2.point);
      const circle = getCtp(start2.point, bend2.point, end2.point);
      const center = circle.slice(0, 2);
      const radius = circle[2];
      const length = getArcLength(center, radius, start2.point, end2.point);
      return Math.abs(length);
    }, [shape.handles]);
    const scale = Math.max(0.5, Math.min(1, Math.max(dist / (labelSize[1] + 128), dist / (labelSize[0] + 128))));
    const offset = React31.useMemo(() => {
      const bounds2 = this.getBounds(shape);
      const offset2 = e.sub(shape.handles.bend.point, [bounds2.width / 2, bounds2.height / 2]);
      return offset2;
    }, [shape, scale]);
    return /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, { children: [
      hasLabel && /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(LabelMask, { id: shape.id, scale, offset, bounds, labelSize }),
      /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
        "path",
        {
          d: getArrowPath(style, start.point, bend.point, end.point, decorations?.start, decorations?.end),
          mask: hasLabel ? `url(#${shape.id}_clip)` : ``
        }
      ),
      hasLabel && /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
        "rect",
        {
          x: bounds.width / 2 - labelSize[0] / 2 * scale + offset[0],
          y: bounds.height / 2 - labelSize[1] / 2 * scale + offset[1],
          width: labelSize[0] * scale,
          height: labelSize[1] * scale,
          rx: 4 * scale,
          ry: 4 * scale,
          fill: "transparent"
        }
      )
    ] });
  });
  getBounds = (shape) => {
    const bounds = C3.getFromCache(this.boundsCache, shape, () => {
      const {
        handles: { start, bend, end }
      } = shape;
      return C3.getBoundsFromPoints(getArcPoints(start.point, bend.point, end.point));
    });
    return C3.translateBounds(bounds, shape.point);
  };
  getRotatedBounds = (shape) => {
    const {
      handles: { start, bend, end }
    } = shape;
    let points = getArcPoints(start.point, bend.point, end.point);
    const { minX, minY, maxX, maxY } = C3.getBoundsFromPoints(points);
    if (shape.rotation !== 0) {
      points = points.map((pt2) => e.rotWith(pt2, [(minX + maxX) / 2, (minY + maxY) / 2], shape.rotation || 0));
    }
    return C3.translateBounds(C3.getBoundsFromPoints(points), shape.point);
  };
  getCenter = (shape) => {
    const { start, end } = shape.handles;
    return e.add(shape.point, e.med(start.point, end.point));
  };
  shouldRender = (prev, next) => {
    return next.decorations !== prev.decorations || next.handles !== prev.handles || next.style !== prev.style || next.label !== prev.label;
  };
  hitTestPoint = (shape, point) => {
    const {
      handles: { start, bend, end }
    } = shape;
    const pt2 = e.sub(point, shape.point);
    const points = getArcPoints(start.point, bend.point, end.point);
    for (let i4 = 1; i4 < points.length; i4++) {
      if (e.distanceToLineSegment(points[i4 - 1], points[i4], pt2) < 1) {
        return true;
      }
    }
    return false;
  };
  hitTestLineSegment = (shape, A6, B5) => {
    const {
      handles: { start, bend, end }
    } = shape;
    const ptA = e.sub(A6, shape.point);
    const ptB = e.sub(B5, shape.point);
    const points = getArcPoints(start.point, bend.point, end.point);
    for (let i4 = 1; i4 < points.length; i4++) {
      if (B2(points[i4 - 1], points[i4], ptA, ptB).didIntersect) {
        return true;
      }
    }
    return false;
  };
  hitTestBounds = (shape, bounds) => {
    const { start, end, bend } = shape.handles;
    const sp = e.add(shape.point, start.point);
    const ep = e.add(shape.point, end.point);
    if (C3.pointInBounds(sp, bounds) || C3.pointInBounds(ep, bounds)) {
      return true;
    }
    if (e.isEqual(e.med(start.point, end.point), bend.point)) {
      return ce2(sp, ep, bounds).length > 0;
    } else {
      const [cx, cy, r5] = getCtp(start.point, bend.point, end.point);
      const cp = e.add(shape.point, [cx, cy]);
      return be(cp, r5, sp, ep, bounds).length > 0;
    }
  };
  transform = (shape, bounds, { initialShape, scaleX, scaleY }) => {
    const initialShapeBounds = this.getBounds(initialShape);
    const handles = ["start", "end"];
    const nextHandles = { ...initialShape.handles };
    handles.forEach((handle) => {
      if (handle === "bend")
        return;
      const [x5, y6] = nextHandles[handle].point;
      const nw = x5 / initialShapeBounds.width;
      const nh = y6 / initialShapeBounds.height;
      nextHandles[handle] = {
        ...nextHandles[handle],
        point: [bounds.width * (scaleX < 0 ? 1 - nw : nw), bounds.height * (scaleY < 0 ? 1 - nh : nh)]
      };
    });
    const nextBend = scaleX > 0 && scaleY < 0 || scaleX < 0 && scaleY > 0 ? -initialShape.bend : initialShape.bend;
    const bendPoint = getBendPoint(nextHandles, nextBend);
    nextHandles.bend.point = bendPoint;
    return {
      point: e.toFixed([bounds.minX, bounds.minY]),
      handles: nextHandles,
      bend: nextBend
      // does this change?
    };
  };
  onDoubleClickHandle = (shape, handle) => {
    switch (handle) {
      case "bend": {
        return {
          bend: 0,
          handles: {
            ...shape.handles,
            bend: {
              ...shape.handles.bend,
              point: getBendPoint(shape.handles, shape.bend)
            }
          }
        };
      }
      case "start": {
        return {
          decorations: {
            ...shape.decorations,
            start: shape.decorations?.start ? void 0 : "arrow" /* Arrow */
          }
        };
      }
      case "end": {
        return {
          decorations: {
            ...shape.decorations,
            end: shape.decorations?.end ? void 0 : "arrow" /* Arrow */
          }
        };
      }
    }
    return this;
  };
  onHandleChange = (shape, handles) => {
    let nextHandles = C3.deepMerge(shape.handles, handles);
    let nextBend = shape.bend;
    nextHandles = C3.deepMerge(nextHandles, {
      start: {
        point: e.toFixed(nextHandles.start.point)
      },
      end: {
        point: e.toFixed(nextHandles.end.point)
      }
    });
    if (e.isEqual(nextHandles.start.point, nextHandles.end.point))
      return;
    if ("bend" in handles) {
      const { start, end, bend } = nextHandles;
      const distance = e.dist(start.point, end.point);
      const midPoint = e.med(start.point, end.point);
      const angle = e.angle(start.point, end.point);
      const u5 = e.uni(e.vec(start.point, end.point));
      const ap = e.add(midPoint, e.mul(e.per(u5), distance));
      const bp = e.sub(midPoint, e.mul(e.per(u5), distance));
      const bendPoint = e.nearestPointOnLineSegment(ap, bp, bend.point, true);
      const bendDist = e.dist(midPoint, bendPoint);
      const realBend = bendDist / (distance / 2);
      nextBend = C3.clamp(realBend, -0.99, 0.99);
      const angleToBend = e.angle(start.point, bendPoint);
      if (e.isEqual(midPoint, getBendPoint(nextHandles, nextBend))) {
        nextBend = 0;
      } else if (isAngleBetween(angle, angle + Math.PI, angleToBend)) {
        nextBend *= -1;
      }
    }
    const nextShape = {
      point: shape.point,
      bend: nextBend,
      handles: {
        ...nextHandles,
        bend: {
          ...nextHandles.bend,
          point: getBendPoint(nextHandles, nextBend)
        }
      }
    };
    const topLeft = shape.point;
    const nextBounds = this.getBounds({ ...nextShape });
    const offset = e.sub([nextBounds.minX, nextBounds.minY], topLeft);
    if (!e.isEqual(offset, [0, 0])) {
      Object.values(nextShape.handles).forEach((handle) => {
        handle.point = e.toFixed(e.sub(handle.point, offset));
      });
      nextShape.point = e.toFixed(e.add(nextShape.point, offset));
    }
    return nextShape;
  };
  getSvgElement = (shape) => {
    const elm = document.getElementById(shape.id + "_svg")?.cloneNode(true);
    if (!elm)
      return;
    const hasLabel = shape.label?.trim()?.length ?? 0 > 0;
    if (hasLabel) {
      const s5 = shape;
      const g6 = document.createElementNS("http://www.w3.org/2000/svg", "g");
      const font = getFontStyle(shape.style);
      const labelSize = getTextLabelSize(shape.label, font);
      const fontSize = getFontSize(shape.style.size, shape.style.font) * (shape.style.scale ?? 1);
      const fontFamily = getFontFace(shape.style.font).slice(1, -1);
      const labelElm = getTextSvgElement(s5.label, fontSize, fontFamily, "start" /* Start */, labelSize[0], false);
      let dist;
      const { start, bend, end } = shape.handles;
      const isStraightLine = e.dist(bend.point, e.toFixed(e.med(start.point, end.point))) < 1;
      if (isStraightLine) {
        dist = e.dist(start.point, end.point);
      } else {
        const circle = getCtp(start.point, bend.point, end.point);
        const center = circle.slice(0, 2);
        const radius = circle[2];
        const length = getArcLength(center, radius, start.point, end.point);
        dist = Math.abs(length);
      }
      const scale = Math.max(0.5, Math.min(1, Math.max(dist / (labelSize[1] + 128), dist / (labelSize[0] + 128))));
      const bounds = this.getBounds(shape);
      const offset = e.sub(shape.handles.bend.point, [bounds.width / 2, bounds.height / 2]);
      const x5 = bounds.width / 2 - labelSize[0] / 2 * scale + offset[0];
      const y6 = bounds.height / 2 - labelSize[1] / 2 * scale + offset[1];
      labelElm.setAttribute("transform", `translate(${x5}, ${y6})`);
      labelElm.setAttribute("fill", getShapeStyle(shape.style).stroke);
      labelElm.setAttribute("transform-origin", "center center");
      g6.setAttribute("text-align", "center");
      g6.setAttribute("text-anchor", "middle");
      g6.appendChild(elm);
      g6.appendChild(labelElm);
      return g6;
    }
    return elm;
  };
};
var FullWrapper = styled("div", { width: "100%", height: "100%" });

// src/components/Tldraw/state/shapes/DrawUtil/DrawUtil.tsx
var React32 = __toESM(require("react"));

// src/components/Tldraw/state/shapes/DrawUtil/drawHelpers.ts
var simulatePressureSettings = {
  easing: (t5) => Math.sin(t5 * Math.PI / 2),
  simulatePressure: true
};
var realPressureSettings = {
  easing: (t5) => t5 * t5,
  simulatePressure: false
};
function getFreehandOptions(shape) {
  const styles = getShapeStyle(shape.style);
  const options = {
    size: 1 + styles.strokeWidth * 1.5,
    thinning: 0.65,
    streamline: 0.65,
    smoothing: 0.65,
    ...shape.points[1][2] === 0.5 ? simulatePressureSettings : realPressureSettings,
    last: shape.isComplete
  };
  return options;
}
function getFillPath(shape) {
  if (shape.points.length < 2)
    return "";
  return C3.getSvgPathFromStroke(me(shape.points, getFreehandOptions(shape)).map((pt2) => pt2.point));
}
function getDrawStrokePoints(shape, options) {
  return me(shape.points, options);
}
function getDrawStrokePathTDSnapshot(shape) {
  if (shape.points.length < 2)
    return "";
  const options = getFreehandOptions(shape);
  const strokePoints = getDrawStrokePoints(shape, options);
  const path = C3.getSvgPathFromStroke(ce(strokePoints, options));
  return path;
}
function getSolidStrokePathTDSnapshot(shape) {
  const { points } = shape;
  if (points.length < 2)
    return "M 0 0 L 0 0";
  const options = getFreehandOptions(shape);
  const strokePoints = getDrawStrokePoints(shape, options);
  const last = points[points.length - 1];
  if (!p.isEqual(strokePoints[0].point, last))
    strokePoints.push({ point: last });
  const path = C3.getSvgPathFromStrokePoints(strokePoints);
  return path;
}

// src/components/Tldraw/state/shapes/DrawUtil/DrawUtil.tsx
var import_jsx_runtime47 = require("react/jsx-runtime");
var DrawUtil = class extends TDShapeUtil {
  type = "draw" /* Draw */;
  pointsBoundsCache = /* @__PURE__ */ new WeakMap([]);
  shapeBoundsCache = /* @__PURE__ */ new Map();
  rotatedCache = /* @__PURE__ */ new WeakMap([]);
  pointCache = {};
  canClone = true;
  getShape = (props) => {
    return C3.deepMerge(
      {
        id: "id",
        type: "draw" /* Draw */,
        name: "Draw",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        rotation: 0,
        style: defaultStyle,
        points: [],
        isComplete: false
      },
      props
    );
  };
  Component = TDShapeUtil.Component(({ shape, meta, isSelected, isGhost, events }, ref) => {
    const { points, style, isComplete } = shape;
    const polygonPathTDSnapshot = React32.useMemo(() => {
      return getFillPath(shape);
    }, [points, style.size]);
    const pathTDSnapshot = React32.useMemo(() => {
      return style.dash === "draw" /* Draw */ ? getDrawStrokePathTDSnapshot(shape) : getSolidStrokePathTDSnapshot(shape);
    }, [points, style.size, style.dash, isComplete]);
    const styles = getShapeStyle(style);
    const { stroke, fill, strokeWidth } = styles;
    const bounds = this.getBounds(shape);
    const verySmall = bounds.width <= strokeWidth / 2 && bounds.height <= strokeWidth / 2;
    if (verySmall) {
      const sw2 = 1 + strokeWidth;
      return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(te, { ref, id: shape.id + "_svg", ...events, children: /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("circle", { r: sw2, fill: stroke, stroke, pointerEvents: "all", opacity: isGhost ? GHOSTED_OPACITY : 1 }) });
    }
    const shouldFill = style.isFilled && points.length > 3 && e.dist(points[0], points[points.length - 1]) < strokeWidth * 2;
    if (shape.style.dash === "draw" /* Draw */) {
      return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(te, { ref, id: shape.id + "_svg", ...events, children: /* @__PURE__ */ (0, import_jsx_runtime47.jsxs)("g", { opacity: isGhost ? GHOSTED_OPACITY : 1, children: [
        /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("path", { className: shouldFill || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea", d: pathTDSnapshot }),
        shouldFill && /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("path", { d: polygonPathTDSnapshot, stroke: "none", fill, strokeLinejoin: "round", strokeLinecap: "round", pointerEvents: "none" }),
        /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
          "path",
          {
            d: pathTDSnapshot,
            fill: stroke,
            stroke,
            strokeWidth: strokeWidth / 2,
            strokeLinejoin: "round",
            strokeLinecap: "round",
            pointerEvents: "none"
          }
        )
      ] }) });
    }
    const strokeDasharray = {
      ["draw" /* Draw */]: "none",
      ["solid" /* Solid */]: `none`,
      ["dotted" /* Dotted */]: `0.1 ${strokeWidth * 4}`,
      ["dashed" /* Dashed */]: `${strokeWidth * 4} ${strokeWidth * 4}`
    }[style.dash];
    const strokeDashoffset = {
      ["draw" /* Draw */]: "none",
      ["solid" /* Solid */]: `none`,
      ["dotted" /* Dotted */]: `0`,
      ["dashed" /* Dashed */]: `0`
    }[style.dash];
    const sw = 1 + strokeWidth * 1.5;
    return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(te, { ref, id: shape.id + "_svg", ...events, children: /* @__PURE__ */ (0, import_jsx_runtime47.jsxs)("g", { opacity: isGhost ? GHOSTED_OPACITY : 1, children: [
      /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("path", { className: shouldFill && isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea", d: pathTDSnapshot }),
      /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
        "path",
        {
          d: pathTDSnapshot,
          fill: shouldFill ? fill : "none",
          stroke: "none",
          strokeWidth: Math.min(4, strokeWidth * 2),
          strokeLinejoin: "round",
          strokeLinecap: "round",
          pointerEvents: "none"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
        "path",
        {
          d: pathTDSnapshot,
          fill: "none",
          stroke,
          strokeWidth: sw,
          strokeDasharray,
          strokeDashoffset,
          strokeLinejoin: "round",
          strokeLinecap: "round",
          pointerEvents: "none"
        }
      )
    ] }) });
  });
  Indicator = TDShapeUtil.Indicator(({ shape }) => {
    const { points } = shape;
    const pathTDSnapshot = React32.useMemo(() => {
      return getSolidStrokePathTDSnapshot(shape);
    }, [points]);
    const bounds = this.getBounds(shape);
    const verySmall = bounds.width < 4 && bounds.height < 4;
    if (verySmall) {
      return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("circle", { x: bounds.width / 2, y: bounds.height / 2, r: 1 });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("path", { d: pathTDSnapshot });
  });
  transform = (shape, bounds, { initialShape, scaleX, scaleY }) => {
    const initialShapeBounds = C3.getFromCache(this.boundsCache, initialShape, () => C3.getBoundsFromPoints(initialShape.points));
    const points = initialShape.points.map(([x5, y6, r5]) => {
      return [
        bounds.width * (scaleX < 0 ? 1 - x5 / initialShapeBounds.width : x5 / initialShapeBounds.width),
        bounds.height * (scaleY < 0 ? 1 - y6 / initialShapeBounds.height : y6 / initialShapeBounds.height),
        r5
      ];
    });
    const newBounds = C3.getBoundsFromPoints(shape.points);
    const point = e.sub([bounds.minX, bounds.minY], [newBounds.minX, newBounds.minY]);
    return {
      points,
      point
    };
  };
  getBounds = (shape) => {
    const pointsHaveChanged = !this.pointsBoundsCache.has(shape.points);
    const pointHasChanged = !(this.pointCache[shape.id] === shape.point);
    if (pointsHaveChanged) {
      const bounds = C3.getBoundsFromPoints(shape.points);
      this.pointsBoundsCache.set(shape.points, bounds);
      this.shapeBoundsCache.set(shape.id, C3.translateBounds(bounds, shape.point));
      this.pointCache[shape.id] = shape.point;
    } else if (pointHasChanged && !pointsHaveChanged) {
      this.pointCache[shape.id] = shape.point;
      this.shapeBoundsCache.set(shape.id, C3.translateBounds(this.pointsBoundsCache.get(shape.points), shape.point));
    }
    return this.shapeBoundsCache.get(shape.id);
  };
  shouldRender = (prev, next) => {
    return next.points !== prev.points || next.style !== prev.style || next.isComplete !== prev.isComplete;
  };
  hitTestPoint = (shape, point) => {
    const ptA = e.sub(point, shape.point);
    return C3.pointInPolyline(ptA, shape.points);
  };
  hitTestLineSegment = (shape, A6, B5) => {
    const { points, point } = shape;
    const ptA = e.sub(A6, point);
    const ptB = e.sub(B5, point);
    const bounds = this.getBounds(shape);
    if (bounds.width < 8 && bounds.height < 8) {
      return e.distanceToLineSegment(A6, B5, C3.getBoundsCenter(bounds)) < 5;
    }
    if (ce2(ptA, ptB, bounds)) {
      for (let i4 = 1; i4 < points.length; i4++) {
        if (B2(points[i4 - 1], points[i4], ptA, ptB).didIntersect) {
          return true;
        }
      }
    }
    return false;
  };
  hitTestBounds = (shape, bounds) => {
    if (!shape.rotation) {
      const shapeBounds = this.getBounds(shape);
      return C3.boundsContain(bounds, shapeBounds) || (C3.boundsContain(shapeBounds, bounds) || Te(shapeBounds, bounds).length > 0) && ye(C3.translateBounds(bounds, e.neg(shape.point)), shape.points).length > 0;
    }
    const rBounds = this.getRotatedBounds(shape);
    const rotatedBounds = C3.getFromCache(this.rotatedCache, shape, () => {
      const c5 = C3.getBoundsCenter(C3.getBoundsFromPoints(shape.points));
      return shape.points.map((pt2) => e.rotWith(pt2, c5, shape.rotation || 0));
    });
    return C3.boundsContain(bounds, rBounds) || ye(C3.translateBounds(bounds, e.neg(shape.point)), rotatedBounds).length > 0;
  };
};

// src/components/Tldraw/state/shapes/EllipseUtil/EllipseUtil.tsx
var React35 = __toESM(require("react"));

// src/components/Tldraw/state/shapes/EllipseUtil/components/DashedEllipse.tsx
var React33 = __toESM(require("react"));
var import_jsx_runtime48 = require("react/jsx-runtime");
var DashedEllipse = React33.memo(function DashedEllipse2({ radius, style, isSelected }) {
  const { stroke, strokeWidth, fill } = getShapeStyle(style);
  const sw = 1 + strokeWidth * 1.618;
  const rx = Math.max(0, radius[0] - sw / 2);
  const ry = Math.max(0, radius[1] - sw / 2);
  const perimeter = C3.perimeterOfEllipse(rx, ry);
  const { strokeDasharray, strokeDashoffset } = C3.getPerfectDashProps(perimeter < 64 ? perimeter * 2 : perimeter, strokeWidth * 1.618, style.dash, 4);
  return /* @__PURE__ */ (0, import_jsx_runtime48.jsxs)(import_jsx_runtime48.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime48.jsx)("ellipse", { className: style.isFilled || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea", cx: radius[0], cy: radius[1], rx: radius[0], ry: radius[1] }),
    /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(
      "ellipse",
      {
        cx: radius[0],
        cy: radius[1],
        rx,
        ry,
        fill,
        stroke,
        strokeWidth: sw,
        strokeDasharray,
        strokeDashoffset,
        pointerEvents: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    )
  ] });
});

// src/components/Tldraw/state/shapes/EllipseUtil/components/DrawEllipse.tsx
var React34 = __toESM(require("react"));

// src/components/Tldraw/state/shapes/EllipseUtil/ellipseHelpers.ts
function getEllipseStrokePoints(id, radius, style) {
  const { strokeWidth } = getShapeStyle(style);
  const getRandom = C3.rng(id);
  const rx = radius[0] + getRandom() * strokeWidth * 2;
  const ry = radius[1] + getRandom() * strokeWidth * 2;
  const perimeter = C3.perimeterOfEllipse(rx, ry);
  const points = [];
  const start = Math.PI + Math.PI * getRandom();
  const extra = Math.abs(getRandom());
  const count = Math.max(16, perimeter / 10);
  for (let i4 = 0; i4 < count; i4++) {
    const t5 = EASINGS.easeInOutSine(i4 / (count + 1));
    const rads = start * 2 + Math.PI * (2 + extra) * t5;
    const c5 = Math.cos(rads);
    const s5 = Math.sin(rads);
    points.push([rx * c5 + radius[0], ry * s5 + radius[1], t5 + 0.5 + getRandom() / 2]);
  }
  return me(points, {
    size: 1 + strokeWidth * 2,
    thinning: 0.618,
    end: { taper: perimeter / 8 },
    start: { taper: perimeter / 12 },
    streamline: 0,
    simulatePressure: true
  });
}
function getEllipsePath(id, radius, style) {
  const { strokeWidth } = getShapeStyle(style);
  const getRandom = C3.rng(id);
  const rx = radius[0] + getRandom() * strokeWidth * 2;
  const ry = radius[1] + getRandom() * strokeWidth * 2;
  const perimeter = C3.perimeterOfEllipse(rx, ry);
  return C3.getSvgPathFromStroke(
    ce(getEllipseStrokePoints(id, radius, style), {
      size: 2 + strokeWidth * 2,
      thinning: 0.618,
      end: { taper: perimeter / 8 },
      start: { taper: perimeter / 12 },
      streamline: 0,
      simulatePressure: true
    })
  );
}
function getEllipseIndicatorPath(id, radius, style) {
  return C3.getSvgPathFromStrokePoints(getEllipseStrokePoints(id, radius, style));
}

// src/components/Tldraw/state/shapes/EllipseUtil/components/DrawEllipse.tsx
var import_jsx_runtime49 = require("react/jsx-runtime");
var DrawEllipse = React34.memo(function DrawEllipse2({ id, radius, style, isSelected }) {
  const { stroke, strokeWidth, fill } = getShapeStyle(style);
  const innerPath = getEllipsePath(id, radius, style);
  return /* @__PURE__ */ (0, import_jsx_runtime49.jsxs)(import_jsx_runtime49.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime49.jsx)("ellipse", { className: style.isFilled || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea", cx: radius[0], cy: radius[1], rx: radius[0], ry: radius[1] }),
    style.isFilled && /* @__PURE__ */ (0, import_jsx_runtime49.jsx)("path", { d: getEllipseIndicatorPath(id, radius, style), stroke: "none", fill, pointerEvents: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime49.jsx)("path", { d: innerPath, fill: stroke, stroke, strokeWidth, pointerEvents: "none", strokeLinecap: "round", strokeLinejoin: "round" })
  ] });
});

// src/components/Tldraw/state/shapes/EllipseUtil/EllipseUtil.tsx
var import_jsx_runtime50 = require("react/jsx-runtime");
var EllipseUtil = class extends TDShapeUtil {
  type = "ellipse" /* Ellipse */;
  canBind = true;
  canClone = true;
  canEdit = true;
  getShape = (props) => {
    return C3.deepMerge(
      {
        id: "id",
        type: "ellipse" /* Ellipse */,
        name: "Ellipse",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        radius: [1, 1],
        rotation: 0,
        style: defaultStyle,
        label: "",
        labelPoint: [0.5, 0.5]
      },
      props
    );
  };
  Component = TDShapeUtil.Component(
    ({ shape, isGhost, isSelected, isBinding, isEditing, meta, bounds, events, onShapeChange, onShapeBlur }, ref) => {
      const { id, radius, style, label = "", labelPoint = LABEL_POINT } = shape;
      const font = getFontStyle(shape.style);
      const styles = getShapeStyle(style);
      const strokeWidth = styles.strokeWidth;
      const sw = 1 + strokeWidth * 1.618;
      const rx = Math.max(0, radius[0] - sw / 2);
      const ry = Math.max(0, radius[1] - sw / 2);
      const Component = style.dash === "draw" /* Draw */ ? DrawEllipse : DashedEllipse;
      const handleLabelChange = React35.useCallback((label2) => onShapeChange?.({ id, label: label2 }), [onShapeChange]);
      return /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(FullWrapper2, { ref, ...events, children: [
        /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(
          TextLabel,
          {
            isEditing,
            onChange: handleLabelChange,
            onBlur: onShapeBlur,
            font,
            text: label,
            color: styles.stroke,
            offsetX: (labelPoint[0] - 0.5) * bounds.width,
            offsetY: (labelPoint[1] - 0.5) * bounds.height
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(te, { id: shape.id + "_svg", opacity: isGhost ? GHOSTED_OPACITY : 1, children: [
          isBinding && /* @__PURE__ */ (0, import_jsx_runtime50.jsx)("ellipse", { className: "tl-binding-indicator", cx: radius[0], cy: radius[1], rx, ry, strokeWidth: this.bindingDistance }),
          /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(Component, { id, radius, style, isSelected })
        ] })
      ] });
    }
  );
  Indicator = TDShapeUtil.Indicator(({ shape }) => {
    const { id, radius, style } = shape;
    const styles = getShapeStyle(style);
    const strokeWidth = styles.strokeWidth;
    const sw = 1 + strokeWidth * 1.618;
    const rx = Math.max(0, radius[0] - sw / 2);
    const ry = Math.max(0, radius[1] - sw / 2);
    return style.dash === "draw" /* Draw */ ? /* @__PURE__ */ (0, import_jsx_runtime50.jsx)("path", { d: getEllipseIndicatorPath(id, radius, style) }) : /* @__PURE__ */ (0, import_jsx_runtime50.jsx)("ellipse", { cx: radius[0], cy: radius[1], rx, ry });
  });
  hitTestPoint = (shape, point) => {
    return C3.pointInBounds(point, this.getRotatedBounds(shape)) && C3.pointInEllipse(point, this.getCenter(shape), shape.radius[0], shape.radius[1], shape.rotation || 0);
  };
  hitTestLineSegment = (shape, A6, B5) => {
    return y(A6, B5, this.getCenter(shape), shape.radius[0], shape.radius[1], shape.rotation || 0).didIntersect;
  };
  getBounds = (shape) => {
    return C3.getFromCache(this.boundsCache, shape, () => {
      return C3.getRotatedEllipseBounds(shape.point[0], shape.point[1], shape.radius[0], shape.radius[1], 0);
    });
  };
  getRotatedBounds = (shape) => {
    return C3.getRotatedEllipseBounds(shape.point[0], shape.point[1], shape.radius[0], shape.radius[1], shape.rotation);
  };
  hitTestBounds = (shape, bounds) => {
    const shapeBounds = this.getBounds(shape);
    return C3.boundsContained(shapeBounds, bounds) || pe2(this.getCenter(shape), shape.radius[0], shape.radius[1], shape.rotation || 0, bounds).length > 0;
  };
  shouldRender = (prev, next) => {
    return next.radius !== prev.radius || next.style !== prev.style || next.label !== prev.label;
  };
  getCenter = (shape) => {
    return e.add(shape.point, shape.radius);
  };
  getBindingPoint = (shape, fromShape, point, origin, direction, bindAnywhere) => {
    {
      const expandedBounds = this.getExpandedBounds(shape);
      const center = this.getCenter(shape);
      let bindingPoint;
      let distance;
      if (!C3.pointInEllipse(point, center, shape.radius[0] + this.bindingDistance, shape.radius[1] + this.bindingDistance)) {
        return;
      }
      if (bindAnywhere) {
        if (e.dist(point, this.getCenter(shape)) < 12) {
          bindingPoint = [0.5, 0.5];
        } else {
          bindingPoint = e.divV(e.sub(point, [expandedBounds.minX, expandedBounds.minY]), [expandedBounds.width, expandedBounds.height]);
        }
        distance = 0;
      } else {
        let intersection = F(origin, direction, center, shape.radius[0], shape.radius[1], shape.rotation || 0).points.sort(
          (a7, b6) => e.dist(a7, origin) - e.dist(b6, origin)
        )[0];
        if (!intersection) {
          intersection = y(point, center, center, shape.radius[0], shape.radius[1], shape.rotation || 0).points.sort(
            (a7, b6) => e.dist(a7, point) - e.dist(b6, point)
          )[0];
        }
        if (!intersection) {
          return;
        }
        const anchor = e.med(point, intersection);
        if (e.distanceToLineSegment(point, anchor, this.getCenter(shape)) < 12) {
          bindingPoint = [0.5, 0.5];
        } else {
          bindingPoint = e.divV(e.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [expandedBounds.width, expandedBounds.height]);
        }
        if (C3.pointInEllipse(point, center, shape.radius[0], shape.radius[1], shape.rotation || 0)) {
          distance = this.bindingDistance / 2;
        } else {
          const innerIntersection = y(point, center, center, shape.radius[0], shape.radius[1], shape.rotation || 0).points[0];
          if (!innerIntersection)
            return;
          distance = Math.max(this.bindingDistance / 2, e.dist(point, innerIntersection));
        }
      }
      return {
        point: bindingPoint,
        distance
      };
    }
  };
  transform = (shape, bounds, { scaleX, scaleY, initialShape }) => {
    const { rotation = 0 } = initialShape;
    return {
      point: [bounds.minX, bounds.minY],
      radius: [bounds.width / 2, bounds.height / 2],
      rotation: scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? -(rotation || 0) : rotation || 0
    };
  };
  transformSingle = (shape, bounds) => {
    return {
      point: e.toFixed([bounds.minX, bounds.minY]),
      radius: e.div([bounds.width, bounds.height], 2)
    };
  };
};
var FullWrapper2 = styled("div", { width: "100%", height: "100%" });

// src/components/Tldraw/state/shapes/GroupUtil/GroupUtil.tsx
var import_jsx_runtime51 = require("react/jsx-runtime");
var GroupUtil = class extends TDShapeUtil {
  type = "group" /* Group */;
  canBind = true;
  getShape = (props) => {
    return C3.deepMerge(
      {
        id: "id",
        type: "group" /* Group */,
        name: "Group",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        size: [100, 100],
        rotation: 0,
        children: [],
        style: defaultStyle
      },
      props
    );
  };
  Component = TDShapeUtil.Component(({ shape, isBinding, isGhost, isHovered, isSelected, events }, ref) => {
    const { id, size } = shape;
    const sw = 2;
    const w7 = Math.max(0, size[0] - sw / 2);
    const h6 = Math.max(0, size[1] - sw / 2);
    const strokes2 = [
      [[sw / 2, sw / 2], [w7, sw / 2], w7 - sw / 2],
      [[w7, sw / 2], [w7, h6], h6 - sw / 2],
      [[w7, h6], [sw / 2, h6], w7 - sw / 2],
      [[sw / 2, h6], [sw / 2, sw / 2], h6 - sw / 2]
    ];
    const paths = strokes2.map(([start, end], i4) => {
      return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)("line", { x1: start[0], y1: start[1], x2: end[0], y2: end[1] }, id + "_" + i4);
    });
    return /* @__PURE__ */ (0, import_jsx_runtime51.jsxs)(te, { ref, ...events, children: [
      isBinding && /* @__PURE__ */ (0, import_jsx_runtime51.jsx)("rect", { className: "tl-binding-indicator", strokeWidth: this.bindingDistance }),
      /* @__PURE__ */ (0, import_jsx_runtime51.jsxs)("g", { opacity: isGhost ? GHOSTED_OPACITY : 1, children: [
        /* @__PURE__ */ (0, import_jsx_runtime51.jsx)("rect", { x: 0, y: 0, width: size[0], height: size[1], fill: "transparent", pointerEvents: "all" }),
        /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(ScaledLines, { stroke: "black" /* Black */, opacity: isHovered || isSelected ? 1 : 0, strokeLinecap: "round", pointerEvents: "stroke", children: paths })
      ] })
    ] });
  });
  Indicator = TDShapeUtil.Indicator(({ shape }) => {
    const { id, size } = shape;
    const sw = 2;
    const w7 = Math.max(0, size[0] - sw / 2);
    const h6 = Math.max(0, size[1] - sw / 2);
    const strokes2 = [
      [[sw / 2, sw / 2], [w7, sw / 2], w7 - sw / 2],
      [[w7, sw / 2], [w7, h6], h6 - sw / 2],
      [[w7, h6], [sw / 2, h6], w7 - sw / 2],
      [[sw / 2, h6], [sw / 2, sw / 2], h6 - sw / 2]
    ];
    const paths = strokes2.map(([start, end], i4) => {
      return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)("line", { x1: start[0], y1: start[1], x2: end[0], y2: end[1] }, id + "_" + i4);
    });
    return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(ScaledLines, { strokeLinecap: "round", pointerEvents: "stroke", children: paths });
  });
  getBounds = (shape) => {
    return getBoundsRectangle(shape, this.boundsCache);
  };
  shouldRender = (prev, next) => {
    return next.size !== prev.size || next.style !== prev.style;
  };
};
var ScaledLines = styled("g", {
  strokeWidth: "calc(1.5px * var(--tl-scale))",
  strokeDasharray: `calc(1px * var(--tl-scale)), calc(3px * var(--tl-scale))`
});

// src/components/Tldraw/state/shapes/ImageUtil/ImageUtil.tsx
var React36 = __toESM(require("react"));
var import_jsx_runtime52 = require("react/jsx-runtime");
var ImageUtil = class extends TDShapeUtil {
  type = "image" /* Image */;
  canBind = true;
  canClone = true;
  isAspectRatioLocked = true;
  showCloneHandles = false;
  getShape = (props) => {
    return C3.deepMerge(
      {
        id: "image",
        type: "image" /* Image */,
        name: "Image",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        size: [1, 1],
        rotation: 0,
        style: { ...defaultStyle, isFilled: true },
        assetId: "assetId"
      },
      props
    );
  };
  Component = TDShapeUtil.Component(({ shape, asset = { src: "" }, isBinding, isGhost, meta, events, onShapeChange }, ref) => {
    const { size, style } = shape;
    const { bindingDistance } = this;
    const rImage = React36.useRef(null);
    const rWrapper = React36.useRef(null);
    React36.useLayoutEffect(() => {
      const wrapper = rWrapper.current;
      if (!wrapper)
        return;
      const [width, height] = size;
      wrapper.style.width = `${width}px`;
      wrapper.style.height = `${height}px`;
    }, [size]);
    return /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)(Xs, { ref, ...events, children: [
      isBinding && /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(
        "div",
        {
          className: "tl-binding-indicator",
          style: {
            position: "absolute",
            top: `calc(${-bindingDistance}px * var(--tl-zoom))`,
            left: `calc(${-bindingDistance}px * var(--tl-zoom))`,
            width: `calc(100% + ${bindingDistance * 2}px * var(--tl-zoom))`,
            height: `calc(100% + ${bindingDistance * 2}px * var(--tl-zoom))`,
            backgroundColor: "var(--tl-selectFill)"
          }
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(
        Wrapper,
        {
          ref: rWrapper,
          isFilled: style.isFilled,
          isGhost,
          children: /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(ImageElement, { id: shape.id + "_image", ref: rImage, src: asset.src, alt: "tl_image_asset", draggable: false })
        }
      )
    ] });
  });
  Indicator = TDShapeUtil.Indicator(({ shape }) => {
    const {
      size: [width, height]
    } = shape;
    return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("rect", { x: 0, y: 0, rx: 2, ry: 2, width: Math.max(1, width), height: Math.max(1, height) });
  });
  getBounds = (shape) => {
    return getBoundsRectangle(shape, this.boundsCache);
  };
  shouldRender = (prev, next) => {
    return next.size !== prev.size || next.style !== prev.style;
  };
  transform = transformRectangle;
  transformSingle = transformSingleRectangle;
  getSvgElement = (shape) => {
    const bounds = this.getBounds(shape);
    const elm = document.createElementNS("http://www.w3.org/2000/svg", "image");
    elm.setAttribute("width", `${bounds.width}`);
    elm.setAttribute("height", `${bounds.height}`);
    elm.setAttribute("xmlns:xlink", `http://www.w3.org/1999/xlink`);
    return elm;
  };
};
var Wrapper = re2("div", {
  pointerEvents: "all",
  position: "relative",
  fontFamily: "sans-serif",
  fontSize: "2em",
  height: "100%",
  width: "100%",
  borderRadius: "3px",
  perspective: "800px",
  overflow: "hidden",
  p: {
    userSelect: "none"
  },
  img: {
    userSelect: "none"
  },
  variants: {
    isGhost: {
      false: { opacity: 1 },
      true: { transition: "opacity .2s", opacity: GHOSTED_OPACITY }
    },
    isFilled: {
      true: {},
      false: {}
    }
  },
  compoundVariants: [
    {
      isFilled: true,
      css: {
        boxShadow: "2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)"
      }
    },
    {
      isFilled: true,
      css: {
        boxShadow: "2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)"
      }
    }
  ]
});
var ImageElement = re2("img", {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%",
  maxWidth: "100%",
  minWidth: "100%",
  pointerEvents: "none",
  objectFit: "cover",
  userSelect: "none",
  borderRadius: 2
});

// src/components/Tldraw/state/shapes/RectangleUtil/RectangleUtil.tsx
var React39 = __toESM(require("react"));

// src/components/Tldraw/state/shapes/RectangleUtil/components/BindingIndicator.tsx
var import_jsx_runtime53 = require("react/jsx-runtime");
function BindingIndicator({ strokeWidth, size }) {
  return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
    "rect",
    {
      className: "tl-binding-indicator",
      x: strokeWidth,
      y: strokeWidth,
      width: Math.max(0, size[0] - strokeWidth / 2),
      height: Math.max(0, size[1] - strokeWidth / 2),
      strokeWidth: BINDING_DISTANCE * 2
    }
  );
}

// src/components/Tldraw/state/shapes/RectangleUtil/components/DashedRectangle.tsx
var React37 = __toESM(require("react"));
var import_jsx_runtime54 = require("react/jsx-runtime");
var DashedRectangle = React37.memo(function DashedRectangle2({ id, style, size, isSelected }) {
  const { stroke, strokeWidth, fill } = getShapeStyle(style);
  const sw = 1 + strokeWidth * 1.618;
  const w7 = Math.max(0, size[0] - sw / 2);
  const h6 = Math.max(0, size[1] - sw / 2);
  const strokes2 = [
    [[sw / 2, sw / 2], [w7, sw / 2], w7 - sw / 2],
    [[w7, sw / 2], [w7, h6], h6 - sw / 2],
    [[w7, h6], [sw / 2, h6], w7 - sw / 2],
    [[sw / 2, h6], [sw / 2, sw / 2], h6 - sw / 2]
  ];
  const paths = strokes2.map(([start, end, length], i4) => {
    const { strokeDasharray, strokeDashoffset } = C3.getPerfectDashProps(length, strokeWidth * 1.618, style.dash);
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)("line", { x1: start[0], y1: start[1], x2: end[0], y2: end[1], strokeDasharray, strokeDashoffset }, id + "_" + i4);
  });
  return /* @__PURE__ */ (0, import_jsx_runtime54.jsxs)(import_jsx_runtime54.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
      "rect",
      {
        className: isSelected || style.isFilled ? "tl-fill-hitarea" : "tl-stroke-hitarea",
        x: sw / 2,
        y: sw / 2,
        width: w7,
        height: h6,
        strokeWidth: BINDING_DISTANCE
      }
    ),
    style.isFilled && /* @__PURE__ */ (0, import_jsx_runtime54.jsx)("rect", { x: sw / 2, y: sw / 2, width: w7, height: h6, fill, pointerEvents: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime54.jsx)("g", { pointerEvents: "none", stroke, strokeWidth: sw, strokeLinecap: "round", children: paths })
  ] });
});

// src/components/Tldraw/state/shapes/RectangleUtil/components/DrawRectangle.tsx
var React38 = __toESM(require("react"));

// src/components/Tldraw/state/shapes/RectangleUtil/rectangleHelpers.ts
function getRectangleDrawPoints(id, style, size) {
  const styles = getShapeStyle(style);
  const getRandom = C3.rng(id);
  const sw = styles.strokeWidth;
  const w7 = Math.max(0, size[0]);
  const h6 = Math.max(0, size[1]);
  const offsets = Array.from({ length: 4 }).map(() => {
    return [getRandom() * sw * 0.75, getRandom() * sw * 0.75];
  });
  const tl = p.add([sw / 2, sw / 2], offsets[0]);
  const tr = p.add([w7 - sw / 2, sw / 2], offsets[1]);
  const br = p.add([w7 - sw / 2, h6 - sw / 2], offsets[2]);
  const bl = p.add([sw / 2, h6 - sw / 2], offsets[3]);
  const rm = Math.round(Math.abs(getRandom() * 2 * 4));
  const rx = Math.min(w7 / 4, sw * 2);
  const ry = Math.min(h6 / 4, sw * 2);
  const px = Math.max(8, Math.floor(w7 / 16));
  const py = Math.max(8, Math.floor(h6 / 16));
  const lines = C3.rotateArray(
    [
      p.pointsBetween(p.add(tl, [rx, 0]), p.sub(tr, [rx, 0]), px),
      p.pointsBetween(p.add(tr, [0, ry]), p.sub(br, [0, ry]), py),
      p.pointsBetween(p.sub(br, [rx, 0]), p.add(bl, [rx, 0]), px),
      p.pointsBetween(p.sub(bl, [0, ry]), p.add(tl, [0, ry]), py)
    ],
    rm
  );
  const points = [...lines.flat(), ...lines[0]].slice(5, Math.floor((rm % 2 === 0 ? px : py) / -2) + 3);
  return {
    points
  };
}
function getDrawStrokeInfo(id, style, size) {
  const { points } = getRectangleDrawPoints(id, style, size);
  const { strokeWidth } = getShapeStyle(style);
  const options = {
    size: strokeWidth,
    thinning: 0.65,
    streamline: 0.3,
    smoothing: 1,
    simulatePressure: false,
    last: true
  };
  return { points, options };
}
function getRectanglePath(id, style, size) {
  const { points, options } = getDrawStrokeInfo(id, style, size);
  const stroke = _e(points, options);
  return C3.getSvgPathFromStroke(stroke);
}
function getRectangleIndicatorPathTDSnapshot(id, style, size) {
  const { points, options } = getDrawStrokeInfo(id, style, size);
  return C3.getSvgPathFromStrokePoints(me(points, options));
}

// src/components/Tldraw/state/shapes/RectangleUtil/components/DrawRectangle.tsx
var import_jsx_runtime55 = require("react/jsx-runtime");
var DrawRectangle = React38.memo(function DrawRectangle2({ id, style, size, isSelected }) {
  const { isFilled } = style;
  const { stroke, strokeWidth, fill } = getShapeStyle(style);
  const pathTDSnapshot = getRectanglePath(id, style, size);
  const innerPath = getRectangleIndicatorPathTDSnapshot(id, style, size);
  return /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)(import_jsx_runtime55.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("path", { className: style.isFilled || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea", d: innerPath }),
    isFilled && /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("path", { d: innerPath, fill, pointerEvents: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("path", { d: pathTDSnapshot, fill: stroke, stroke, strokeWidth, pointerEvents: "none" })
  ] });
});

// src/components/Tldraw/state/shapes/RectangleUtil/RectangleUtil.tsx
var import_jsx_runtime56 = require("react/jsx-runtime");
var RectangleUtil = class extends TDShapeUtil {
  type = "rectangle" /* Rectangle */;
  canBind = true;
  canClone = true;
  canEdit = true;
  getShape = (props) => {
    return C3.deepMerge(
      {
        id: "id",
        type: "rectangle" /* Rectangle */,
        name: "Rectangle",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        size: [1, 1],
        rotation: 0,
        style: defaultStyle,
        label: "",
        labelPoint: [0.5, 0.5]
      },
      props
    );
  };
  Component = TDShapeUtil.Component(
    ({ shape, isEditing, isBinding, isSelected, isGhost, meta, bounds, events, onShapeBlur, onShapeChange }, ref) => {
      const { id, size, style, label = "", labelPoint = LABEL_POINT } = shape;
      const font = getFontStyle(style);
      const styles = getShapeStyle(style);
      const Component = style.dash === "draw" /* Draw */ ? DrawRectangle : DashedRectangle;
      const handleLabelChange = React39.useCallback((label2) => onShapeChange?.({ id, label: label2 }), [onShapeChange]);
      return /* @__PURE__ */ (0, import_jsx_runtime56.jsxs)(FullWrapper3, { ref, ...events, children: [
        /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(
          TextLabel,
          {
            isEditing,
            onChange: handleLabelChange,
            onBlur: onShapeBlur,
            font,
            text: label,
            color: styles.stroke,
            offsetX: (labelPoint[0] - 0.5) * bounds.width,
            offsetY: (labelPoint[1] - 0.5) * bounds.height
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime56.jsxs)(te, { id: shape.id + "_svg", opacity: isGhost ? GHOSTED_OPACITY : 1, children: [
          isBinding && /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(BindingIndicator, { strokeWidth: styles.strokeWidth, size }),
          /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(Component, { id, style, size, isSelected })
        ] })
      ] });
    }
  );
  Indicator = TDShapeUtil.Indicator(({ shape }) => {
    const { id, style, size } = shape;
    const styles = getShapeStyle(style, false);
    const sw = styles.strokeWidth;
    if (style.dash === "draw" /* Draw */) {
      return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("path", { d: getRectangleIndicatorPathTDSnapshot(id, style, size) });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("rect", { x: sw, y: sw, rx: 1, ry: 1, width: Math.max(1, size[0] - sw * 2), height: Math.max(1, size[1] - sw * 2) });
  });
  getBounds = (shape) => {
    return getBoundsRectangle(shape, this.boundsCache);
  };
  shouldRender = (prev, next) => {
    return next.size !== prev.size || next.style !== prev.style || next.label !== prev.label;
  };
  transform = transformRectangle;
  transformSingle = transformSingleRectangle;
};
var FullWrapper3 = styled("div", { width: "100%", height: "100%" });

// src/components/Tldraw/state/shapes/StickyUtil/StickyUtil.tsx
var React40 = __toESM(require("react"));
var import_tw_react = __toESM(require_tw_react());
var import_jsx_runtime57 = require("react/jsx-runtime");
var StickyUtil = class extends TDShapeUtil {
  type = "sticky" /* Sticky */;
  canBind = true;
  canEdit = true;
  canClone = true;
  getShape = (props) => {
    return C3.deepMerge(
      {
        id: "id",
        type: "sticky" /* Sticky */,
        name: "Sticky",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        size: [300, 300],
        text: "",
        rotation: 0,
        style: defaultTextStyle
      },
      props
    );
  };
  Component = TDShapeUtil.Component(({ shape, meta, events, isGhost, isBinding, isEditing, onShapeBlur, onShapeChange }, reference) => {
    const font = getStickyFontStyle(shape.style);
    const { color, fill } = getStickyShapeStyle(shape.style);
    const rContainer = React40.useRef(null);
    const rTextArea = React40.useRef(null);
    const rRenderedText = React40.useRef(null);
    const rIsMounted = React40.useRef(false);
    const handlePointerDown = React40.useCallback((event) => {
      event.stopPropagation();
    }, []);
    const astNode = React40.useMemo(() => {
      const childTree = $tw.wiki.parseText("text/vnd.tiddlywiki", shape.text).tree;
      return { type: "tiddler", children: childTree };
    }, [shape.text]);
    (0, import_tw_react.useWidget)(astNode, rRenderedText, { skip: isEditing });
    const onChange = React40.useCallback(
      (text) => {
        onShapeChange?.({
          id: shape.id,
          type: shape.type,
          text: TLDR.normalizeText(text)
        });
      },
      [onShapeChange, shape.id, shape.type]
    );
    const handleTextChange = React40.useCallback(
      (event) => {
        onChange(event.currentTarget.value);
      },
      [onChange]
    );
    const handleKeyDown = React40.useCallback(
      (event) => {
        if (event.key === "Escape") {
          event.preventDefault();
          event.stopPropagation();
          onShapeBlur?.();
          return;
        }
        if (event.key === "Tab" && shape.text.length === 0) {
          event.preventDefault();
          return;
        }
        if (!(event.key === "Meta" || event.metaKey)) {
          event.stopPropagation();
        } else if (event.key === "z" && event.metaKey) {
          if (event.shiftKey) {
            document.execCommand("redo", false);
          } else {
            document.execCommand("undo", false);
          }
          event.stopPropagation();
          event.preventDefault();
          return;
        }
        if ((event.metaKey || event.ctrlKey) && event.key === "=") {
          event.preventDefault();
        }
        if (event.key === "Tab") {
          event.preventDefault();
          if (event.shiftKey) {
            TextAreaUtils.unindent(event.currentTarget);
          } else {
            TextAreaUtils.indent(event.currentTarget);
          }
          onShapeChange?.({ ...shape, text: TLDR.normalizeText(event.currentTarget.value) });
        }
      },
      [shape, onShapeBlur, onShapeChange]
    );
    const handleBlur = React40.useCallback(
      (event) => {
        event.currentTarget.setSelectionRange(0, 0);
        onShapeBlur?.();
      },
      [onShapeBlur]
    );
    const handleFocus = React40.useCallback(
      (event) => {
        if (!isEditing)
          return;
        if (!rIsMounted.current)
          return;
        event.currentTarget.select();
      },
      [isEditing]
    );
    React40.useEffect(() => {
      if (isEditing) {
        rIsMounted.current = true;
        const elm = rTextArea.current;
        elm.focus();
        elm.select();
      }
    }, [isEditing]);
    const style = {
      font,
      color,
      textShadow: `0.5px 0.5px 2px rgba(255, 255, 255,.5)`
    };
    const getClickedTWElement = React40.useCallback((event) => {
      const buttonOrLinkInWikiText = event.target.querySelectorAll("a,button");
      const clickedElement = Array.from(buttonOrLinkInWikiText).find((element) => {
        const rect = element.getBoundingClientRect();
        return event.clientX > rect.x && event.clientX < rect.x + rect.width && event.clientY > rect.y && event.clientY < rect.y + rect.height;
      });
      return clickedElement;
    }, []);
    const onPointerUp = React40.useCallback(
      (event) => {
        const clickedElement = getClickedTWElement(event);
        if (clickedElement !== void 0) {
          event.preventDefault();
          event.stopPropagation();
          const newClickEvent = new MouseEvent("click", { ...event.nativeEvent });
          clickedElement.dispatchEvent(newClickEvent);
        }
        events.onPointerUp(event);
      },
      [events, getClickedTWElement]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(Xs, { ref: reference, ...events, onPointerUp, children: /* @__PURE__ */ (0, import_jsx_runtime57.jsxs)(StyledStickyContainer, { ref: rContainer, isGhost, style: { backgroundColor: fill, ...style }, children: [
      isBinding && /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(
        "div",
        {
          className: "tl-binding-indicator",
          style: {
            position: "absolute",
            top: -this.bindingDistance,
            left: -this.bindingDistance,
            width: `calc(100% + ${this.bindingDistance * 2}px)`,
            height: `calc(100% + ${this.bindingDistance * 2}px)`,
            backgroundColor: "var(--tl-selectFill)"
          }
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(StyledText2, { ref: rRenderedText, isEditing, alignment: shape.style.textAlign }),
      isEditing && /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(
        StyledTextArea,
        {
          className: STICKY_TEXT_AREA_CLASS_NAME,
          ref: rTextArea,
          onPointerDown: handlePointerDown,
          value: shape.text,
          onChange: handleTextChange,
          onKeyDown: handleKeyDown,
          onFocus: handleFocus,
          onBlur: handleBlur,
          tabIndex: -1,
          autoComplete: "false",
          autoCapitalize: "false",
          autoCorrect: "false",
          autoSave: "false",
          autoFocus: true,
          spellCheck: true,
          alignment: shape.style.textAlign,
          onContextMenu: stopPropagation3,
          onCopy: stopPropagation3,
          onPaste: stopPropagation3,
          onCut: stopPropagation3
        }
      )
    ] }) });
  });
  Indicator = TDShapeUtil.Indicator(({ shape }) => {
    const {
      size: [width, height]
    } = shape;
    return /* @__PURE__ */ (0, import_jsx_runtime57.jsx)("rect", { x: 0, y: 0, rx: 3, ry: 3, width: Math.max(1, width), height: Math.max(1, height) });
  });
  getBounds = (shape) => {
    return getBoundsRectangle(shape, this.boundsCache);
  };
  shouldRender = (previous, next) => {
    return next.size !== previous.size || next.style !== previous.style || next.text !== previous.text;
  };
  transform = transformRectangle;
  transformSingle = transformSingleRectangle;
  getSvgElement = (shape) => {
    const bounds = this.getBounds(shape);
    const style = getStickyShapeStyle(shape.style);
    const fontSize = getStickyFontSize(shape.style.size) * (shape.style.scale ?? 1);
    const fontFamily = getFontFace(shape.style.font).slice(1, -1);
    const textAlign = shape.style.textAlign ?? "start" /* Start */;
    const textElm = getTextSvgElement(shape.text, fontSize, fontFamily, textAlign, bounds.width - PADDING * 2, true);
    textElm.setAttribute("fill", style.color);
    textElm.setAttribute("transform", `translate(${PADDING}, ${PADDING})`);
    const g6 = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("width", String(bounds.width));
    rect.setAttribute("height", String(bounds.height));
    rect.setAttribute("fill", style.fill);
    rect.setAttribute("rx", "3");
    rect.setAttribute("ry", "3");
    g6.appendChild(rect);
    g6.appendChild(textElm);
    return g6;
  };
};
var PADDING = 16;
var StyledStickyContainer = styled("div", {
  pointerEvents: "all",
  position: "relative",
  backgroundColor: "transparent",
  height: "100%",
  width: "100%",
  padding: `${PADDING}px`,
  borderRadius: "3px",
  perspective: "800px",
  variants: {
    isGhost: {
      false: { opacity: 1 },
      true: { transition: "opacity .2s", opacity: GHOSTED_OPACITY }
    }
  }
});
var commonTextWrapping = {
  whiteSpace: "pre-wrap",
  overflowWrap: "break-word",
  letterSpacing: LETTER_SPACING
};
var StyledText2 = styled("div", {
  position: "absolute",
  top: PADDING,
  left: PADDING,
  width: `calc(100% - ${PADDING * 2}px)`,
  height: "fit-content",
  font: "inherit",
  pointerEvents: "none",
  userSelect: "none",
  variants: {
    isEditing: {
      true: {
        opacity: 0
      },
      false: {
        opacity: 1
      }
    },
    alignment: {
      ["start" /* Start */]: {
        textAlign: "left"
      },
      ["middle" /* Middle */]: {
        textAlign: "center"
      },
      ["end" /* End */]: {
        textAlign: "right"
      },
      ["justify" /* Justify */]: {
        textAlign: "justify"
      }
    }
  },
  ...commonTextWrapping
});
var StyledTextArea = styled("textarea", {
  width: "100%",
  height: "100%",
  border: "none",
  overflow: "hidden",
  background: "none",
  outline: "none",
  textAlign: "left",
  font: "inherit",
  padding: 0,
  color: "#333",
  verticalAlign: "top",
  resize: "none",
  caretColor: "black",
  ...commonTextWrapping,
  variants: {
    alignment: {
      ["start" /* Start */]: {
        textAlign: "left"
      },
      ["middle" /* Middle */]: {
        textAlign: "center"
      },
      ["end" /* End */]: {
        textAlign: "right"
      },
      ["justify" /* Justify */]: {
        textAlign: "justify"
      }
    }
  },
  "&:focus": {
    outline: "none",
    border: "none"
  }
});

// src/components/Tldraw/state/shapes/TextUtil/TextUtil.tsx
var React41 = __toESM(require("react"));
var import_jsx_runtime58 = require("react/jsx-runtime");
var TextUtil = class extends TDShapeUtil {
  type = "text" /* Text */;
  isAspectRatioLocked = true;
  canEdit = true;
  canBind = true;
  canClone = true;
  bindingDistance = BINDING_DISTANCE / 2;
  getShape = (props) => {
    return C3.deepMerge(
      {
        id: "id",
        type: "text" /* Text */,
        name: "Text",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        rotation: 0,
        text: " ",
        style: defaultTextStyle
      },
      props
    );
  };
  texts = /* @__PURE__ */ new Map();
  Component = TDShapeUtil.Component(({ shape, isBinding, isGhost, isEditing, onShapeBlur, onShapeChange, meta, events }, ref) => {
    const { text, style } = shape;
    const styles = getShapeStyle(style);
    const font = getFontStyle(shape.style);
    const rInput = React41.useRef(null);
    const rIsMounted = React41.useRef(false);
    const rEditedText = React41.useRef(text);
    React41.useLayoutEffect(() => {
      if (text !== rEditedText.current) {
        let delta = [0, 0];
        this.texts.set(shape.id, text);
        const currentBounds = this.getBounds(shape);
        const nextBounds = this.getBounds(shape);
        switch (shape.style.textAlign) {
          case "start" /* Start */: {
            break;
          }
          case "middle" /* Middle */: {
            delta = e.div([nextBounds.width - currentBounds.width, 0], 2);
            break;
          }
          case "end" /* End */: {
            delta = [nextBounds.width - currentBounds.width, 0];
            break;
          }
        }
        rEditedText.current = text;
        onShapeChange?.({
          ...shape,
          id: shape.id,
          point: e.sub(shape.point, delta),
          text
        });
      }
    }, [text]);
    const handleChange = React41.useCallback(
      (e5) => {
        let delta = [0, 0];
        const newText = TLDR.normalizeText(e5.currentTarget.value);
        const currentBounds = this.getBounds(shape);
        this.texts.set(shape.id, newText);
        const nextBounds = this.getBounds({
          ...shape,
          text: newText
        });
        switch (shape.style.textAlign) {
          case "start" /* Start */: {
            break;
          }
          case "middle" /* Middle */: {
            delta = e.div([nextBounds.width - currentBounds.width, 0], 2);
            break;
          }
          case "end" /* End */: {
            delta = [nextBounds.width - currentBounds.width, 0];
            break;
          }
        }
        rEditedText.current = newText;
        onShapeChange?.({
          ...shape,
          id: shape.id,
          point: e.sub(shape.point, delta),
          text: newText
        });
      },
      [shape.id, shape.point]
    );
    const handleKeyDown = React41.useCallback(
      (e5) => {
        if (e5.key === "Escape") {
          e5.preventDefault();
          e5.stopPropagation();
          onShapeBlur?.();
          return;
        }
        if (e5.key === "Tab" && shape.text.length === 0) {
          e5.preventDefault();
          return;
        }
        if (e5.key === "Enter" && (e5.metaKey || e5.ctrlKey)) {
          e5.preventDefault();
          e5.stopPropagation();
          rInput.current.blur();
          return;
        }
        if (!(e5.key === "Meta" || e5.metaKey)) {
          e5.stopPropagation();
        } else if (e5.key === "z" && e5.metaKey) {
          if (e5.shiftKey) {
            document.execCommand("redo", false);
          } else {
            document.execCommand("undo", false);
          }
          e5.stopPropagation();
          e5.preventDefault();
          return;
        }
        if ((e5.metaKey || e5.ctrlKey) && e5.key === "=") {
          e5.preventDefault();
        }
        if (e5.key === "Tab") {
          e5.preventDefault();
          if (e5.shiftKey) {
            TextAreaUtils.unindent(e5.currentTarget);
          } else {
            TextAreaUtils.indent(e5.currentTarget);
          }
          onShapeChange?.({ ...shape, text: TLDR.normalizeText(e5.currentTarget.value) });
        }
      },
      [shape, onShapeChange]
    );
    const handleBlur = React41.useCallback((e5) => {
      e5.currentTarget.setSelectionRange(0, 0);
      onShapeBlur?.();
    }, []);
    const handleFocus = React41.useCallback(
      (e5) => {
        if (!isEditing)
          return;
        if (!rIsMounted.current)
          return;
        if (document.activeElement === e5.currentTarget) {
          e5.currentTarget.select();
        }
      },
      [isEditing]
    );
    const handlePointerDown = React41.useCallback(
      (e5) => {
        if (isEditing) {
          e5.stopPropagation();
        }
      },
      [isEditing]
    );
    const rWasEditing = React41.useRef(isEditing);
    React41.useEffect(() => {
      if (isEditing) {
        rWasEditing.current = true;
        this.texts.set(shape.id, text);
        requestAnimationFrame(() => {
          rIsMounted.current = true;
          const elm = rInput.current;
          if (elm) {
            elm.focus();
            elm.select();
          }
        });
      } else if (rWasEditing.current) {
        rWasEditing.current = false;
        onShapeBlur?.();
      }
    }, [isEditing]);
    return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(Xs, { ref, ...events, children: /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(Wrapper2, { isGhost, isEditing, onPointerDown: handlePointerDown, children: /* @__PURE__ */ (0, import_jsx_runtime58.jsxs)(
      InnerWrapper,
      {
        style: {
          font,
          color: styles.stroke,
          textAlign: getTextAlign(style.textAlign)
        },
        children: [
          isBinding && /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(
            "div",
            {
              className: "tl-binding-indicator",
              style: {
                position: "absolute",
                top: -this.bindingDistance,
                left: -this.bindingDistance,
                width: `calc(100% + ${this.bindingDistance * 2}px)`,
                height: `calc(100% + ${this.bindingDistance * 2}px)`,
                backgroundColor: "var(--tl-selectFill)"
              }
            }
          ),
          isEditing ? /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(
            TextArea,
            {
              ref: rInput,
              style: {
                font,
                color: styles.stroke
              },
              name: "text",
              tabIndex: -1,
              autoComplete: "false",
              autoCapitalize: "false",
              autoCorrect: "false",
              autoSave: "false",
              autoFocus: true,
              placeholder: "",
              spellCheck: "true",
              wrap: "off",
              dir: "auto",
              datatype: "wysiwyg",
              defaultValue: text,
              color: styles.stroke,
              onFocus: handleFocus,
              onChange: handleChange,
              onKeyDown: handleKeyDown,
              onBlur: handleBlur,
              onPointerDown: handlePointerDown,
              onContextMenu: stopPropagation3,
              onCopy: stopPropagation3,
              onPaste: stopPropagation3,
              onCut: stopPropagation3
            }
          ) : text,
          "\u200B"
        ]
      }
    ) }) });
  });
  Indicator = TDShapeUtil.Indicator(({ shape }) => {
    const { width, height } = this.getBounds(shape);
    return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)("rect", { x: 0, y: 0, width, height });
  });
  getBounds = (shape) => {
    const bounds = C3.getFromCache(this.boundsCache, shape, () => {
      if (!melm2) {
        return { minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10 };
      }
      if (!melm2.parentNode)
        document.body.appendChild(melm2);
      melm2.style.font = getFontStyle(shape.style);
      melm2.textContent = this.texts.get(shape.id) ?? shape.text;
      const width = melm2.offsetWidth || 1;
      const height = melm2.offsetHeight || 1;
      return {
        minX: 0,
        maxX: width,
        minY: 0,
        maxY: height,
        width,
        height
      };
    });
    return C3.translateBounds(bounds, shape.point);
  };
  shouldRender = (prev, next) => {
    return next.text !== prev.text || next.style.scale !== prev.style.scale || next.style !== prev.style;
  };
  transform = (shape, bounds, { initialShape, scaleX, scaleY }) => {
    const {
      rotation = 0,
      style: { scale = 1 }
    } = initialShape;
    const nextScale = scale * Math.abs(Math.min(scaleX, scaleY));
    return {
      point: [bounds.minX, bounds.minY],
      rotation: scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? -(rotation || 0) : rotation,
      style: {
        ...initialShape.style,
        scale: nextScale
      }
    };
  };
  transformSingle = (shape, bounds, { initialShape, scaleX, scaleY }) => {
    const {
      style: { scale = 1 }
    } = initialShape;
    return {
      point: e.toFixed([bounds.minX, bounds.minY]),
      style: {
        ...initialShape.style,
        scale: scale * Math.max(Math.abs(scaleY), Math.abs(scaleX))
      }
    };
  };
  onDoubleClickBoundsHandle = (shape) => {
    const center = this.getCenter(shape);
    const newCenter = this.getCenter({
      ...shape,
      style: {
        ...shape.style,
        scale: 1
      }
    });
    return {
      style: {
        ...shape.style,
        scale: 1
      },
      point: e.toFixed(e.add(shape.point, e.sub(center, newCenter)))
    };
  };
  getSvgElement = (shape) => {
    const bounds = this.getBounds(shape);
    const style = getShapeStyle(shape.style);
    const fontSize = getFontSize(shape.style.size, shape.style.font) * (shape.style.scale ?? 1);
    const fontFamily = getFontFace(shape.style.font).slice(1, -1);
    const textAlign = shape.style.textAlign ?? "start" /* Start */;
    const textElm = getTextSvgElement(shape.text, fontSize, fontFamily, textAlign, bounds.width, false);
    textElm.setAttribute("fill", style.stroke);
    return textElm;
  };
};
var melm2;
function getMeasurementDiv2() {
  document.querySelector("#__textMeasure")?.remove();
  const pre = document.createElement("pre");
  pre.id = "__textMeasure";
  Object.assign(pre.style, {
    whiteSpace: "pre",
    width: "auto",
    border: "1px solid transparent",
    padding: "4px",
    margin: "0px",
    letterSpacing: LETTER_SPACING,
    opacity: "0",
    position: "absolute",
    top: "-500px",
    left: "0px",
    zIndex: "9999",
    pointerEvents: "none",
    userSelect: "none",
    alignmentBaseline: "mathematical",
    dominantBaseline: "mathematical"
  });
  pre.tabIndex = -1;
  document.body.appendChild(pre);
  return pre;
}
if (typeof window !== "undefined") {
  melm2 = getMeasurementDiv2();
}
var Wrapper2 = styled("div", {
  width: "100%",
  height: "100%",
  variants: {
    isGhost: {
      false: { opacity: 1 },
      true: { transition: "opacity .2s", opacity: GHOSTED_OPACITY }
    },
    isEditing: {
      false: {
        pointerEvents: "all",
        userSelect: "all"
      },
      true: {
        pointerEvents: "none",
        userSelect: "none"
      }
    }
  }
});
var commonTextWrapping2 = {
  whiteSpace: "pre-wrap",
  overflowWrap: "break-word"
};
var InnerWrapper = styled("div", {
  position: "absolute",
  width: "100%",
  height: "100%",
  padding: "4px",
  zIndex: 1,
  minHeight: 1,
  minWidth: 1,
  lineHeight: 1,
  letterSpacing: LETTER_SPACING,
  outline: 0,
  fontWeight: "500",
  backfaceVisibility: "hidden",
  userSelect: "none",
  pointerEvents: "none",
  WebkitUserSelect: "none",
  WebkitTouchCallout: "none",
  isEditing: {
    false: {},
    true: {
      pointerEvents: "all",
      background: "$boundsBg",
      userSelect: "text",
      WebkitUserSelect: "text"
    }
  },
  ...commonTextWrapping2
});
var TextArea = styled("textarea", {
  position: "absolute",
  top: 0,
  left: 0,
  zIndex: 1,
  width: "100%",
  height: "100%",
  border: "none",
  padding: "4px",
  resize: "none",
  textAlign: "inherit",
  minHeight: "inherit",
  minWidth: "inherit",
  lineHeight: "inherit",
  letterSpacing: "inherit",
  outline: 0,
  fontWeight: "inherit",
  overflow: "hidden",
  backfaceVisibility: "hidden",
  display: "inline-block",
  pointerEvents: "all",
  background: "$boundsBg",
  userSelect: "text",
  WebkitUserSelect: "text",
  ...commonTextWrapping2,
  "&:focus": {
    outline: "none",
    border: "none"
  }
});

// src/components/Tldraw/state/shapes/TriangleUtil/TriangleUtil.tsx
var React44 = __toESM(require("react"));

// src/components/Tldraw/state/shapes/TriangleUtil/components/DashedTriangle.tsx
var React42 = __toESM(require("react"));

// src/components/Tldraw/state/shapes/TriangleUtil/triangleHelpers.ts
function getTrianglePoints(size, offset = 0, rotation = 0) {
  const [w7, h6] = size;
  let points = [
    [w7 / 2, 0],
    [w7, h6],
    [0, h6]
  ];
  if (offset)
    points = getOffsetPolygon(points, offset);
  if (rotation)
    points = points.map((pt2) => p.rotWith(pt2, [w7 / 2, h6 / 2], rotation));
  return points;
}
function getTriangleCentroid(size) {
  const [w7, h6] = size;
  const points = [
    [w7 / 2, 0],
    [w7, h6],
    [0, h6]
  ];
  return [(points[0][0] + points[1][0] + points[2][0]) / 3, (points[0][1] + points[1][1] + points[2][1]) / 3];
}
function getTriangleDrawPoints(id, size, strokeWidth) {
  const [w7, h6] = size;
  const getRandom = C3.rng(id);
  const offsets = Array.from({ length: 3 }).map(() => {
    return [getRandom() * strokeWidth * 0.75, getRandom() * strokeWidth * 0.75];
  });
  const corners = [p.add([w7 / 2, 0], offsets[0]), p.add([w7, h6], offsets[1]), p.add([0, h6], offsets[2])];
  const rm = Math.round(Math.abs(getRandom() * 2 * 3));
  const lines = C3.rotateArray(
    [p.pointsBetween(corners[0], corners[1], 32), p.pointsBetween(corners[1], corners[2], 32), p.pointsBetween(corners[2], corners[0], 32)],
    rm
  );
  const points = [...lines.flat(), ...lines[0]];
  return {
    points
  };
}
function getDrawStrokeInfo2(id, size, style) {
  const { strokeWidth } = getShapeStyle(style);
  const { points } = getTriangleDrawPoints(id, size, strokeWidth);
  const options = {
    size: strokeWidth,
    thinning: 0.65,
    streamline: 0.3,
    smoothing: 1,
    simulatePressure: false,
    last: true
  };
  return { points, options };
}
function getTrianglePath(id, size, style) {
  const { points, options } = getDrawStrokeInfo2(id, size, style);
  const stroke = _e(points, options);
  return C3.getSvgPathFromStroke(stroke);
}
function getTriangleIndicatorPathTDSnapshot(id, size, style) {
  const { points, options } = getDrawStrokeInfo2(id, size, style);
  return C3.getSvgPathFromStrokePoints(me(points, options));
}

// src/components/Tldraw/state/shapes/TriangleUtil/components/DashedTriangle.tsx
var import_jsx_runtime59 = require("react/jsx-runtime");
var DashedTriangle = React42.memo(function DashedTriangle2({ id, size, style, isSelected }) {
  const { stroke, strokeWidth, fill } = getShapeStyle(style);
  const sw = 1 + strokeWidth * 1.618;
  const points = getTrianglePoints(size);
  const sides = C3.pointsToLineSegments(points, true);
  const paths = sides.map(([start, end], i4) => {
    const { strokeDasharray, strokeDashoffset } = C3.getPerfectDashProps(p.dist(start, end), strokeWidth * 1.618, style.dash);
    return /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(
      "line",
      {
        x1: start[0],
        y1: start[1],
        x2: end[0],
        y2: end[1],
        stroke,
        strokeWidth: sw,
        strokeLinecap: "round",
        strokeDasharray,
        strokeDashoffset
      },
      id + "_" + i4
    );
  });
  const bgPath = points.join(",");
  return /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)(import_jsx_runtime59.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("polygon", { className: style.isFilled || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea", points: bgPath }),
    style.isFilled && /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("polygon", { fill, points: bgPath, pointerEvents: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("g", { pointerEvents: "stroke", children: paths })
  ] });
});

// src/components/Tldraw/state/shapes/TriangleUtil/components/DrawTriangle.tsx
var React43 = __toESM(require("react"));
var import_jsx_runtime60 = require("react/jsx-runtime");
var DrawTriangle = React43.memo(function DrawTriangle2({ id, size, style, isSelected }) {
  const { stroke, strokeWidth, fill } = getShapeStyle(style);
  const pathTDSnapshot = getTrianglePath(id, size, style);
  const indicatorPath = getTriangleIndicatorPathTDSnapshot(id, size, style);
  return /* @__PURE__ */ (0, import_jsx_runtime60.jsxs)(import_jsx_runtime60.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime60.jsx)("path", { className: style.isFilled || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea", d: indicatorPath }),
    style.isFilled && /* @__PURE__ */ (0, import_jsx_runtime60.jsx)("path", { d: indicatorPath, fill, pointerEvents: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime60.jsx)("path", { d: pathTDSnapshot, fill: stroke, stroke, strokeWidth, pointerEvents: "none" })
  ] });
});

// src/components/Tldraw/state/shapes/TriangleUtil/components/TriangleBindingIndicator.tsx
var import_jsx_runtime61 = require("react/jsx-runtime");
function TriangleBindingIndicator({ size }) {
  const trianglePoints = getTrianglePoints(size).join(",");
  return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("polygon", { className: "tl-binding-indicator", points: trianglePoints, strokeWidth: BINDING_DISTANCE * 2 });
}

// src/components/Tldraw/state/shapes/TriangleUtil/TriangleUtil.tsx
var import_jsx_runtime62 = require("react/jsx-runtime");
var TriangleUtil = class extends TDShapeUtil {
  type = "triangle" /* Triangle */;
  canBind = true;
  canClone = true;
  canEdit = true;
  getShape = (props) => {
    return C3.deepMerge(
      {
        id: "id",
        type: "triangle" /* Triangle */,
        name: "Triangle",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        size: [1, 1],
        rotation: 0,
        style: defaultStyle,
        label: "",
        labelPoint: [0.5, 0.5]
      },
      props
    );
  };
  Component = TDShapeUtil.Component(
    ({ shape, bounds, isBinding, isEditing, isSelected, isGhost, meta, events, onShapeChange, onShapeBlur }, ref) => {
      const { id, label = "", size, style, labelPoint = LABEL_POINT } = shape;
      const font = getFontStyle(style);
      const styles = getShapeStyle(style);
      const Component = style.dash === "draw" /* Draw */ ? DrawTriangle : DashedTriangle;
      const handleLabelChange = React44.useCallback((label2) => onShapeChange?.({ id, label: label2 }), [onShapeChange]);
      const offsetY = React44.useMemo(() => {
        const center = p.div(size, 2);
        const centroid = getTriangleCentroid(size);
        return (centroid[1] - center[1]) * 0.72;
      }, [size]);
      return /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)(FullWrapper4, { ref, ...events, children: [
        /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
          TextLabel,
          {
            font,
            text: label,
            color: styles.stroke,
            offsetX: (labelPoint[0] - 0.5) * bounds.width,
            offsetY: offsetY + (labelPoint[1] - 0.5) * bounds.height,
            isEditing,
            onChange: handleLabelChange,
            onBlur: onShapeBlur
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)(te, { id: shape.id + "_svg", opacity: isGhost ? GHOSTED_OPACITY : 1, children: [
          isBinding && /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(TriangleBindingIndicator, { size }),
          /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Component, { id, style, size, isSelected })
        ] })
      ] });
    }
  );
  Indicator = TDShapeUtil.Indicator(({ shape }) => {
    const { size } = shape;
    return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)("polygon", { points: getTrianglePoints(size).join(",") });
  });
  getPoints(shape) {
    const {
      rotation = 0,
      point: [x5, y6],
      size: [w7, h6]
    } = shape;
    return [
      [x5 + w7 / 2, y6],
      [x5, y6 + h6],
      [x5 + w7, y6 + h6]
    ].map((pt2) => p.rotWith(pt2, this.getCenter(shape), rotation));
  }
  shouldRender = (prev, next) => {
    return next.size !== prev.size || next.style !== prev.style || next.label !== prev.label;
  };
  getBounds = (shape) => {
    return getBoundsRectangle(shape, this.boundsCache);
  };
  getExpandedBounds = (shape) => {
    return C3.getBoundsFromPoints(getTrianglePoints(shape.size, this.bindingDistance).map((pt2) => p.add(pt2, shape.point)));
  };
  hitTestLineSegment = (shape, A6, B5) => {
    return S(A6, B5, this.getPoints(shape)).didIntersect;
  };
  hitTestBounds = (shape, bounds) => {
    return C3.boundsContained(this.getBounds(shape), bounds) || Se(bounds, this.getPoints(shape)).length > 0;
  };
  getBindingPoint = (shape, fromShape, point, origin, direction, bindAnywhere) => {
    const expandedBounds = this.getExpandedBounds(shape);
    if (!C3.pointInBounds(point, expandedBounds))
      return;
    const points = getTrianglePoints(shape.size).map((pt2) => p.add(pt2, shape.point));
    const expandedPoints = getTrianglePoints(shape.size, this.bindingDistance).map((pt2) => p.add(pt2, shape.point));
    const closestDistanceToEdge = C3.pointsToLineSegments(points, true).map(([a7, b6]) => p.distanceToLineSegment(a7, b6, point)).sort((a7, b6) => a7 - b6)[0];
    if (!(C3.pointInPolygon(point, expandedPoints) || closestDistanceToEdge < this.bindingDistance))
      return;
    const intersections = C3.pointsToLineSegments([...expandedPoints, expandedPoints[0]]).map((segment) => x(origin, direction, segment[0], segment[1])).filter((intersection2) => intersection2.didIntersect).flatMap((intersection2) => intersection2.points);
    if (intersections.length === 0)
      return;
    const center = p.add(getTriangleCentroid(shape.size), shape.point);
    const intersection = intersections.sort((a7, b6) => p.dist(b6, origin) - p.dist(a7, origin))[0];
    const middlePoint = p.med(point, intersection);
    let anchor;
    let distance;
    if (bindAnywhere) {
      anchor = p.dist(point, center) < BINDING_DISTANCE / 2 ? center : point;
      distance = 0;
    } else {
      if (p.distanceToLineSegment(point, middlePoint, center) < BINDING_DISTANCE / 2) {
        anchor = center;
      } else {
        anchor = middlePoint;
      }
      if (C3.pointInPolygon(point, points)) {
        distance = this.bindingDistance;
      } else {
        distance = Math.max(this.bindingDistance, closestDistanceToEdge);
      }
    }
    const bindingPoint = p.divV(p.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [expandedBounds.width, expandedBounds.height]);
    return {
      point: p.clampV(bindingPoint, 0, 1),
      distance
    };
  };
  transform = transformRectangle;
  transformSingle = transformSingleRectangle;
};
var FullWrapper4 = styled("div", { width: "100%", height: "100%" });

// src/components/Tldraw/state/shapes/index.ts
var Rectangle = new RectangleUtil();
var Triangle = new TriangleUtil();
var Ellipse = new EllipseUtil();
var Draw = new DrawUtil();
var Arrow = new ArrowUtil();
var Text = new TextUtil();
var Group = new GroupUtil();
var Sticky = new StickyUtil();
var Image2 = new ImageUtil();
var shapeUtils = {
  ["rectangle" /* Rectangle */]: Rectangle,
  ["triangle" /* Triangle */]: Triangle,
  ["ellipse" /* Ellipse */]: Ellipse,
  ["draw" /* Draw */]: Draw,
  ["arrow" /* Arrow */]: Arrow,
  ["text" /* Text */]: Text,
  ["group" /* Group */]: Group,
  ["sticky" /* Sticky */]: Sticky,
  ["image" /* Image */]: Image2
};
var getShapeUtil = (shape) => {
  if (typeof shape === "string")
    return shapeUtils[shape];
  return shapeUtils[shape.type];
};

// src/components/Tldraw/state/TLDR.ts
var isDevelopment = true;
var _TLDR = class {
  static getShapeUtil(shape) {
    if (shape === void 0) {
      debugger;
      throw new Error(`shape is undefined in getShapeUtil`);
    }
    return getShapeUtil(shape);
  }
  static getSelectedShapes(data, pageId) {
    const page = _TLDR.getPage(data, pageId);
    const selectedIds = _TLDR.getSelectedIds(data, pageId);
    return selectedIds.map((id) => page.shapes[id]);
  }
  static screenToWorld(data, point) {
    const camera = _TLDR.getPageState(data, data.appState.currentPageId).camera;
    return e.sub(e.div(point, camera.zoom), camera.point);
  }
  static getCameraZoom(zoom) {
    return C3.clamp(zoom, 0.1, 5);
  }
  static getPage(data, pageId) {
    return data.document.pages[pageId];
  }
  static getPageState(data, pageId) {
    return data.document.pageStates[pageId];
  }
  static getSelectedIds(data, pageId) {
    return _TLDR.getPageState(data, pageId).selectedIds;
  }
  static getShapes(data, pageId) {
    return Object.values(_TLDR.getPage(data, pageId).shapes);
  }
  static getCamera(data, pageId) {
    return _TLDR.getPageState(data, pageId).camera;
  }
  static getShape(data, shapeId, pageId) {
    return _TLDR.getPage(data, pageId).shapes[shapeId];
  }
  static getCenter(shape) {
    return _TLDR.getShapeUtil(shape).getCenter(shape);
  }
  static getBounds(shape) {
    return _TLDR.getShapeUtil(shape).getBounds(shape);
  }
  static getRotatedBounds(shape) {
    return _TLDR.getShapeUtil(shape).getRotatedBounds(shape);
  }
  static getSelectedBounds(data) {
    return C3.getCommonBounds(_TLDR.getSelectedShapes(data, data.appState.currentPageId).map((shape) => _TLDR.getShapeUtil(shape).getBounds(shape)));
  }
  static getParentId(data, id, pageId) {
    return _TLDR.getShape(data, id, pageId).parentId;
  }
  // static getPointedId(data: TDSnapshot, id: string, pageId: string): string {
  //   const page = TLDR.getPage(data, pageId)
  //   const pageState = TLDR.getPageState(data, data.appState.currentPageId)
  //   const shape = TLDR.getShape(data, id, pageId)
  //   if (!shape) return id
  //   return shape.parentId === pageState.currentParentId || shape.parentId === page.id
  //     ? id
  //     : TLDR.getPointedId(data, shape.parentId, pageId)
  // }
  // static getDrilledPointedId(data: TDSnapshot, id: string, pageId: string): string {
  //   const shape = TLDR.getShape(data, id, pageId)
  //   const { currentPageId } = data.appState
  //   const { currentParentId, pointedId } = TLDR.getPageState(data, data.appState.currentPageId)
  //   return shape.parentId === currentPageId ||
  //     shape.parentId === pointedId ||
  //     shape.parentId === currentParentId
  //     ? id
  //     : TLDR.getDrilledPointedId(data, shape.parentId, pageId)
  // }
  // static getTopParentId(data: TDSnapshot, id: string, pageId: string): string {
  //   const page = TLDR.getPage(data, pageId)
  //   const pageState = TLDR.getPageState(data, pageId)
  //   const shape = TLDR.getShape(data, id, pageId)
  //   if (shape.parentId === shape.id) {
  //     throw Error(`Shape has the same id as its parent! ${shape.id}`)
  //   }
  //   return shape.parentId === page.id || shape.parentId === pageState.currentParentId
  //     ? id
  //     : TLDR.getTopParentId(data, shape.parentId, pageId)
  // }
  // Get an array of a shape id and its descendant shapes' ids
  static getDocumentBranch(data, id, pageId) {
    const shape = _TLDR.getShape(data, id, pageId);
    if (shape.children === void 0)
      return [id];
    return [id, ...shape.children.flatMap((childId) => _TLDR.getDocumentBranch(data, childId, pageId))];
  }
  static getSelectedBranchSnapshot(data, pageId, function_) {
    const page = _TLDR.getPage(data, pageId);
    const copies = _TLDR.getSelectedIds(data, pageId).flatMap((id) => _TLDR.getDocumentBranch(data, id, pageId).map((id2) => page.shapes[id2])).filter((shape) => !shape.isLocked).map(C3.deepClone);
    if (function_ !== void 0) {
      return copies.map((shape) => ({ id: shape.id, ...function_(shape) }));
    }
    return copies;
  }
  static getSelectedShapeSnapshot(data, pageId, function_) {
    const copies = _TLDR.getSelectedShapes(data, pageId).filter((shape) => !shape.isLocked).map(C3.deepClone);
    if (function_ !== void 0) {
      return copies.map((shape) => ({ id: shape.id, ...function_(shape) }));
    }
    return copies;
  }
  // For a given array of shape ids, an array of all other shapes that may be affected by a mutation to it.
  // Use this to decide which shapes to clone as before / after for a command.
  static getAllEffectedShapeIds(data, ids, pageId) {
    const page = _TLDR.getPage(data, pageId);
    const visited = new Set(ids);
    ids.forEach((id) => {
      const shape = page.shapes[id];
      function collectDescendants(shape2) {
        if (shape2.children === void 0)
          return;
        shape2.children.filter((childId) => !visited.has(childId)).forEach((childId) => {
          visited.add(childId);
          collectDescendants(page.shapes[childId]);
        });
      }
      collectDescendants(shape);
      function collectAscendants(shape2) {
        const parentId = shape2.parentId;
        if (parentId === page.id)
          return;
        if (visited.has(parentId))
          return;
        visited.add(parentId);
        collectAscendants(page.shapes[parentId]);
      }
      collectAscendants(shape);
      visited.forEach((id2) => {
        Object.values(page.bindings).filter((binding) => binding.fromId === id2 || binding.toId === id2).forEach((binding) => visited.add(binding.fromId === id2 ? binding.toId : binding.fromId));
      });
    });
    return [...visited.values()];
  }
  static getLinkedShapeIds(data, pageId, direction, includeArrows = true) {
    const selectedIds = _TLDR.getSelectedIds(data, pageId);
    const page = _TLDR.getPage(data, pageId);
    const linkedIds = new Set(selectedIds);
    const checkedIds = /* @__PURE__ */ new Set();
    const idsToCheck = [...selectedIds];
    const arrows = new Set(
      Object.values(page.shapes).filter((shape) => {
        return shape.type === "arrow" /* Arrow */ && (shape.handles.start.bindingId || shape.handles?.end.bindingId);
      })
    );
    while (idsToCheck.length > 0) {
      const id = idsToCheck.pop();
      if (!(id && arrows.size > 0))
        break;
      if (checkedIds.has(id))
        continue;
      checkedIds.add(id);
      arrows.forEach((arrow2) => {
        const {
          handles: {
            start: { bindingId: startBindingId },
            end: { bindingId: endBindingId }
          }
        } = arrow2;
        const startBinding = startBindingId ? page.bindings[startBindingId] : null;
        const endBinding = endBindingId ? page.bindings[endBindingId] : null;
        let hit = false;
        if (startBinding != void 0 && startBinding.toId === id) {
          if (direction === "center") {
            hit = true;
          } else if (arrow2.decorations?.start && endBinding != void 0) {
            hit = direction === "left";
          } else {
            hit = direction === "right";
          }
          if (hit) {
            if (includeArrows)
              linkedIds.add(arrow2.id);
            linkedIds.add(id);
            if (endBinding != void 0) {
              linkedIds.add(endBinding.toId);
              idsToCheck.push(endBinding.toId);
            }
          }
        } else if (endBinding != void 0 && endBinding.toId === id) {
          if (direction === "center") {
            hit = true;
          } else if (arrow2.decorations?.end && startBinding != void 0) {
            hit = direction === "left";
          } else {
            hit = direction === "right";
          }
          if (hit) {
            if (includeArrows)
              linkedIds.add(arrow2.id);
            linkedIds.add(id);
            if (startBinding != void 0) {
              linkedIds.add(startBinding.toId);
              idsToCheck.push(startBinding.toId);
            }
          }
        }
        if ((startBinding == void 0 || linkedIds.has(startBinding.toId)) && (endBinding == void 0 || linkedIds.has(endBinding.toId))) {
          arrows.delete(arrow2);
        }
      });
    }
    return [...linkedIds.values()];
  }
  static getChildIndexAbove(data, id, pageId) {
    const page = data.document.pages[pageId];
    const shape = page.shapes[id];
    let siblings;
    if (shape.parentId === page.id) {
      siblings = Object.values(page.shapes).filter((shape2) => shape2.parentId === page.id).sort((a7, b6) => a7.childIndex - b6.childIndex);
    } else {
      const parent = page.shapes[shape.parentId];
      if (parent.children == void 0)
        throw new Error("No children in parent!");
      siblings = parent.children.map((childId) => page.shapes[childId]).sort((a7, b6) => a7.childIndex - b6.childIndex);
    }
    const index2 = siblings.indexOf(shape);
    const nextSibling = siblings[index2 + 1];
    if (!nextSibling)
      return shape.childIndex + 1;
    return nextSibling.childIndex;
  }
  /* -------------------------------------------------- */
  /*                      Mutations                     */
  /* -------------------------------------------------- */
  static getBeforeShape(shape, change) {
    return Object.fromEntries(Object.keys(change).map((k7) => [k7, shape[k7]]));
  }
  static mutateShapes(data, ids, function_, pageId, forceChildrenTraversal = false) {
    const beforeShapes = {};
    const afterShapes = {};
    ids.forEach((id, index2) => {
      const shape = _TLDR.getShape(data, id, pageId);
      if (shape.isLocked)
        return;
      if (shape?.type === "group" && (ids.length === 1 || forceChildrenTraversal)) {
        shape.children.forEach((id2, index_) => {
          const shape2 = _TLDR.getShape(data, id2, pageId);
          if (shape2.isLocked)
            return;
          const change2 = function_(shape2, index_);
          if (change2 != void 0) {
            beforeShapes[id2] = _TLDR.getBeforeShape(shape2, change2);
            afterShapes[id2] = change2;
          }
        });
      }
      const change = function_(shape, index2);
      if (change != void 0) {
        beforeShapes[id] = _TLDR.getBeforeShape(shape, change);
        afterShapes[id] = change;
      }
    });
    const dataWithMutations = C3.deepMerge(data, {
      document: {
        pages: {
          [data.appState.currentPageId]: {
            shapes: afterShapes
          }
        }
      }
    });
    return {
      before: beforeShapes,
      after: afterShapes,
      data: dataWithMutations
    };
  }
  static createShapes(data, shapes, pageId) {
    const before = {
      document: {
        pages: {
          [pageId]: {
            shapes: {
              ...Object.fromEntries(
                shapes.flatMap((shape) => {
                  const results = [[shape.id, void 0]];
                  if (shape.parentId !== pageId) {
                    const parent = _TLDR.getShape(data, shape.parentId, pageId);
                    if (parent.children == void 0)
                      throw new Error("No children in parent!");
                    results.push([parent.id, { children: parent.children }]);
                  }
                  return results;
                })
              )
            }
          }
        }
      }
    };
    const after = {
      document: {
        pages: {
          [pageId]: {
            shapes: {
              shapes: {
                ...Object.fromEntries(
                  shapes.flatMap((shape) => {
                    const results = [[shape.id, shape]];
                    if (shape.parentId !== pageId) {
                      const parent = _TLDR.getShape(data, shape.parentId, pageId);
                      if (parent.children == void 0)
                        throw new Error("No children in parent!");
                      results.push([parent.id, { children: [...parent.children, shape.id] }]);
                    }
                    return results;
                  })
                )
              }
            }
          }
        }
      }
    };
    return {
      before,
      after
    };
  }
  static deleteShapes(data, shapes, pageId) {
    pageId = pageId || data.appState.currentPageId;
    const page = _TLDR.getPage(data, pageId);
    const shapeIds = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    const before = {
      document: {
        pages: {
          [pageId]: {
            shapes: {
              // These are the shapes that we're going to delete
              ...Object.fromEntries(
                shapeIds.flatMap((id) => {
                  const shape = page.shapes[id];
                  const results = [[shape.id, shape]];
                  if (shape.parentId !== pageId) {
                    const parent = page.shapes[shape.parentId];
                    if (parent.children == void 0)
                      throw new Error("No children in parent!");
                    results.push([parent.id, { children: parent.children }]);
                  }
                  return results;
                })
              )
            },
            bindings: {
              // These are the bindings that we're going to delete
              ...Object.fromEntries(
                Object.values(page.bindings).filter((binding) => {
                  return shapeIds.includes(binding.fromId) || shapeIds.includes(binding.toId);
                }).map((binding) => {
                  return [binding.id, binding];
                })
              )
            }
          }
        }
      }
    };
    const after = {
      document: {
        pages: {
          [pageId]: {
            shapes: {
              ...Object.fromEntries(
                shapeIds.flatMap((id) => {
                  const shape = page.shapes[id];
                  const results = [[shape.id, void 0]];
                  if (shape.parentId !== page.id) {
                    const parent = page.shapes[shape.parentId];
                    if (parent.children == void 0)
                      throw new Error("No children in parent!");
                    results.push([parent.id, { children: parent.children.filter((id2) => id2 !== shape.id) }]);
                  }
                  return results;
                })
              )
            }
          }
        }
      }
    };
    return {
      before,
      after
    };
  }
  static onSessionComplete(shape) {
    const delta = _TLDR.getShapeUtil(shape).onSessionComplete?.(shape);
    if (delta == void 0)
      return shape;
    return { ...shape, ...delta };
  }
  static onChildrenChange(data, shape, pageId) {
    if (shape.children == void 0)
      return;
    const delta = _TLDR.getShapeUtil(shape).onChildrenChange?.(
      shape,
      shape.children.map((id) => _TLDR.getShape(data, id, pageId))
    );
    if (delta == void 0)
      return shape;
    return { ...shape, ...delta };
  }
  static updateArrowBindings(page, arrowShape) {
    const result = {
      start: deepCopy(arrowShape.handles.start),
      end: deepCopy(arrowShape.handles.end)
    };
    let start = {
      isBound: false,
      handle: arrowShape.handles.start,
      point: e.add(arrowShape.handles.start.point, arrowShape.point)
    };
    let end = {
      isBound: false,
      handle: arrowShape.handles.end,
      point: e.add(arrowShape.handles.end.point, arrowShape.point)
    };
    if (arrowShape.handles.start.bindingId) {
      const hasDecoration = arrowShape.decorations?.start !== void 0;
      const handle = arrowShape.handles.start;
      const binding = page.bindings[arrowShape.handles.start.bindingId];
      if (!binding)
        throw new Error("Could not find a binding to match the start handle's bindingId: " + arrowShape.handles.start.bindingId);
      const target = page.shapes[binding.toId];
      const util = _TLDR.getShapeUtil(target);
      const bounds = util.getBounds(target);
      const expandedBounds = util.getExpandedBounds(target);
      const intersectBounds = hasDecoration ? C3.expandBounds(bounds, binding.distance) : bounds;
      const { minX, minY, width, height } = expandedBounds;
      const anchorPoint = e.add([minX, minY], e.mulV([width, height], e.rotWith(binding.point, [0.5, 0.5], target.rotation || 0)));
      start = {
        isBound: true,
        hasDecoration,
        binding,
        handle,
        point: anchorPoint,
        util,
        target,
        bounds,
        expandedBounds,
        intersectBounds,
        center: util.getCenter(target)
      };
    }
    if (arrowShape.handles.end.bindingId) {
      const hasDecoration = arrowShape.decorations?.end !== void 0;
      const handle = arrowShape.handles.end;
      const binding = page.bindings[arrowShape.handles.end.bindingId];
      if (!binding)
        throw new Error("Could not find a binding to match the end handle's bindingId");
      const target = page.shapes[binding.toId];
      const util = _TLDR.getShapeUtil(target);
      const bounds = util.getBounds(target);
      const expandedBounds = util.getExpandedBounds(target);
      const intersectBounds = hasDecoration ? C3.expandBounds(bounds, binding.distance) : bounds;
      const { minX, minY, width, height } = expandedBounds;
      const anchorPoint = e.add([minX, minY], e.mulV([width, height], e.rotWith(binding.point, [0.5, 0.5], target.rotation || 0)));
      end = {
        isBound: true,
        hasDecoration,
        binding,
        handle,
        point: anchorPoint,
        util,
        target,
        bounds,
        expandedBounds,
        intersectBounds,
        center: util.getCenter(target)
      };
    }
    for (const ID of ["end", "start"]) {
      const A6 = ID === "start" ? start : end;
      const B5 = ID === "start" ? end : start;
      if (A6.isBound) {
        if (A6.binding.distance) {
          const direction = e.uni(e.sub(A6.point, B5.point));
          switch (A6.target.type) {
            case "ellipse" /* Ellipse */: {
              const hits = F(
                B5.point,
                direction,
                A6.center,
                A6.target.radius[0] + (A6.hasDecoration ? A6.binding.distance : 0),
                A6.target.radius[1] + (A6.hasDecoration ? A6.binding.distance : 0),
                A6.target.rotation || 0
              ).points.sort((a7, b6) => e.dist(a7, B5.point) - e.dist(b6, B5.point));
              if (hits[0] !== void 0) {
                result[ID].point = e.toFixed(e.sub(hits[0], arrowShape.point));
              }
              break;
            }
            case "triangle" /* Triangle */: {
              const targetPoint = A6.target.point;
              const points = getTrianglePoints(A6.target.size, A6.hasDecoration ? BINDING_DISTANCE : 0, A6.target.rotation).map((pt2) => e.add(pt2, targetPoint));
              const hits = C3.pointsToLineSegments(points, true).map(([p0, p1]) => x(B5.point, direction, p0, p1)).filter((intersection) => intersection.didIntersect).flatMap((intersection) => intersection.points).sort((a7, b6) => e.dist(a7, B5.point) - e.dist(b6, B5.point));
              if (hits[0] !== void 0) {
                result[ID].point = e.toFixed(e.sub(hits[0], arrowShape.point));
              }
              break;
            }
            default: {
              const hits = se2(B5.point, direction, A6.intersectBounds, A6.target.rotation).filter((int) => int.didIntersect).map((int) => int.points[0]).sort((a7, b6) => e.dist(a7, B5.point) - e.dist(b6, B5.point));
              if (!hits[0])
                continue;
              let bHit;
              if (B5.isBound) {
                const bHits = se2(B5.point, direction, B5.intersectBounds, B5.target.rotation).filter((int) => int.didIntersect).map((int) => int.points[0]).sort((a7, b6) => e.dist(a7, B5.point) - e.dist(b6, B5.point));
                bHit = bHits[0];
              }
              if (B5.isBound && (hits.length < 2 || bHit != void 0 && hits[0] && Math.ceil(e.dist(hits[0], bHit)) < BINDING_DISTANCE * 2.5 || C3.boundsContain(A6.expandedBounds, B5.expandedBounds) || C3.boundsCollide(A6.expandedBounds, B5.expandedBounds))) {
                const shortArrowDirection = e.uni(e.sub(B5.point, A6.point));
                const shortArrowHits = se2(A6.point, shortArrowDirection, A6.bounds, A6.target.rotation).filter((int) => int.didIntersect).map((int) => int.points[0]);
                if (!shortArrowHits[0])
                  continue;
                result[ID].point = e.toFixed(e.sub(shortArrowHits[0], arrowShape.point));
                result[ID === "start" ? "end" : "start"].point = e.toFixed(
                  e.add(
                    e.sub(shortArrowHits[0], arrowShape.point),
                    e.mul(
                      shortArrowDirection,
                      Math.min(e.dist(shortArrowHits[0], B5.point), BINDING_DISTANCE * 2.5 * (C3.boundsContain(B5.bounds, A6.intersectBounds) ? -1 : 1))
                    )
                  )
                );
              } else if (!B5.isBound && (hits[0] && e.dist(hits[0], B5.point) < BINDING_DISTANCE * 2.5 || C3.pointInBounds(B5.point, A6.intersectBounds))) {
                const shortArrowDirection = e.uni(e.sub(A6.center, B5.point));
                return _TLDR.getShapeUtil(arrowShape).onHandleChange?.(arrowShape, {
                  [ID]: {
                    ...arrowShape.handles[ID],
                    point: e.toFixed(e.add(e.sub(B5.point, arrowShape.point), e.mul(shortArrowDirection, BINDING_DISTANCE * 2.5)))
                  }
                });
              } else if (hits[0]) {
                result[ID].point = e.toFixed(e.sub(hits[0], arrowShape.point));
              }
            }
          }
        } else {
          result[ID].point = e.sub(A6.point, arrowShape.point);
        }
      }
    }
    return _TLDR.getShapeUtil(arrowShape).onHandleChange?.(arrowShape, result);
  }
  static transform(shape, bounds, info) {
    const delta = _TLDR.getShapeUtil(shape).transform(shape, bounds, info);
    if (!delta)
      return shape;
    return { ...shape, ...delta };
  }
  static transformSingle(shape, bounds, info) {
    const delta = _TLDR.getShapeUtil(shape).transformSingle(shape, bounds, info);
    if (delta == void 0)
      return shape;
    return { ...shape, ...delta };
  }
  /**
   * Rotate a shape around an origin point.
   * @param shape a shape.
   * @param center the shape's center in page space.
   * @param origin the page point to rotate around.
   * @param rotation the amount to rotate the shape.
   */
  static getRotatedShapeMutation(shape, center, origin, delta) {
    const relativeCenter = e.sub(center, shape.point);
    const rotatedCenter = e.rotWith(center, origin, delta);
    const nextPoint = e.toFixed(e.sub(rotatedCenter, relativeCenter));
    if (shape.handles !== void 0) {
      const change = this.getShapeUtil(shape).onHandleChange?.(
        // Base the change on a shape with the next point
        { ...shape, point: nextPoint },
        Object.fromEntries(
          Object.entries(shape.handles).map(([handleId, handle]) => {
            const point = e.toFixed(e.rotWith(handle.point, relativeCenter, delta));
            return [handleId, { ...handle, point }];
          })
        )
      );
      return change;
    }
    const nextRotation = C3.clampRadians((shape.rotation || 0) + delta);
    return {
      point: nextPoint,
      rotation: nextRotation
    };
  }
  /* -------------------------------------------------- */
  /*                       Parents                      */
  /* -------------------------------------------------- */
  static updateParents(data, pageId, changedShapeIds) {
    const page = _TLDR.getPage(data, pageId);
    if (changedShapeIds.length === 0)
      return;
    const { shapes } = _TLDR.getPage(data, pageId);
    const parentToUpdateIds = [...new Set(changedShapeIds.map((id) => shapes[id].parentId).values())].filter((id) => id !== page.id);
    for (const parentId of parentToUpdateIds) {
      const parent = shapes[parentId];
      if (parent.children == void 0) {
        throw new Error("A shape is parented to a shape without a children array.");
      }
      _TLDR.onChildrenChange(data, parent, pageId);
    }
    _TLDR.updateParents(data, pageId, parentToUpdateIds);
  }
  /* -------------------------------------------------- */
  /*                      Bindings                      */
  /* -------------------------------------------------- */
  static getBinding(data, id, pageId) {
    return _TLDR.getPage(data, pageId).bindings[id];
  }
  static getBindings(data, pageId) {
    const page = _TLDR.getPage(data, pageId);
    return Object.values(page.bindings);
  }
  static getBindableShapeIds(data) {
    return _TLDR.getShapes(data, data.appState.currentPageId).filter((shape) => _TLDR.getShapeUtil(shape).canBind).sort((a7, b6) => b6.childIndex - a7.childIndex).map((shape) => shape.id);
  }
  static getBindingsWithShapeIds(data, ids, pageId) {
    return [
      ...new Set(
        _TLDR.getBindings(data, pageId).filter((binding) => {
          return ids.includes(binding.toId) || ids.includes(binding.fromId);
        })
      ).values()
    ];
  }
  static getRelatedBindings(data, ids, pageId) {
    const changedShapeIds = new Set(ids);
    const page = _TLDR.getPage(data, pageId);
    const bindingsArray = Object.values(page.bindings);
    const bindingsToUpdate = new Set(bindingsArray.filter((binding) => changedShapeIds.has(binding.toId) || changedShapeIds.has(binding.fromId)));
    let previousSize = bindingsToUpdate.size;
    let delta = -1;
    while (delta !== 0) {
      bindingsToUpdate.forEach((binding) => {
        const fromId = binding.fromId;
        for (const otherBinding of bindingsArray) {
          if (otherBinding.fromId === fromId) {
            bindingsToUpdate.add(otherBinding);
          }
          if (otherBinding.toId === fromId) {
            bindingsToUpdate.add(otherBinding);
          }
        }
      });
      delta = bindingsToUpdate.size - previousSize;
      previousSize = bindingsToUpdate.size;
    }
    return [...bindingsToUpdate.values()];
  }
  static normalizeText(text) {
    return text.replace(_TLDR.fixNewLines, "\n").split("\n").map((x5) => x5 || " ").join("\n");
  }
  /* -------------------------------------------------- */
  /*                     Assertions                     */
  /* -------------------------------------------------- */
  static assertShapeHasProperty(shape, property) {
    if (shape[property] === void 0) {
      throw new Error();
    }
  }
  static warn(e5) {
    if (isDevelopment) {
      console.warn(e5);
    }
  }
  static error(e5) {
    if (isDevelopment) {
      console.error(e5);
    }
  }
  /* -------------------------------------------------- */
  /*                       Export                       */
  /* -------------------------------------------------- */
  static getSvgString(svg, scale = 1) {
    const clone = svg.cloneNode(true);
    svg.setAttribute("width", +svg.getAttribute("width") * scale + "");
    svg.setAttribute("height", +svg.getAttribute("height") * scale + "");
    return new XMLSerializer().serializeToString(clone).replaceAll("&#10;      ", "").replaceAll(/((\s|")\d*\.\d{2})(\d*)(\b|"|\))/g, "$1");
  }
  static getSvgAsDataUrl(svg, scale = 1) {
    const svgString = _TLDR.getSvgString(svg, scale);
    const base64SVG = window.btoa(unescape(svgString));
    return `data:image/svg+xml;base64,${base64SVG}`;
  }
  static async getImageForSvg(svg, type = "png" /* PNG */, options = {}) {
    const { scale = 2, quality = 1 } = options;
    const svgString = _TLDR.getSvgString(svg, scale);
    const width = +svg.getAttribute("width");
    const height = +svg.getAttribute("height");
    if (!svgString)
      return;
    const canvas = await new Promise((resolve) => {
      const image = new Image();
      image.crossOrigin = "anonymous";
      const base64SVG = window.btoa(unescape(encodeURIComponent(svgString)));
      const dataUrl = `data:image/svg+xml;base64,${base64SVG}`;
      image.onload = () => {
        const canvas2 = document.createElement("canvas");
        const context = canvas2.getContext("2d");
        canvas2.width = width;
        canvas2.height = height;
        context.drawImage(image, 0, 0, width, height);
        URL.revokeObjectURL(dataUrl);
        resolve(canvas2);
      };
      image.onerror = () => {
        console.warn("Could not convert that SVG to an image.");
      };
      image.src = dataUrl;
    });
    const blob = await new Promise((resolve) => canvas.toBlob((blob2) => resolve(blob2), "image/" + type, quality));
    return blob;
  }
};
var TLDR = _TLDR;
__publicField(TLDR, "copyStringToClipboard", (string) => {
  try {
    if (navigator.clipboard) {
      navigator.clipboard.write([
        new ClipboardItem({
          "text/plain": new Blob([string], { type: "text/plain" })
        })
      ]);
    }
  } catch {
    const textarea = document.createElement("textarea");
    textarea.setAttribute("position", "fixed");
    textarea.setAttribute("top", "0");
    textarea.setAttribute("readonly", "true");
    textarea.setAttribute("contenteditable", "true");
    textarea.style.position = "fixed";
    textarea.value = string;
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();
    try {
      const range = document.createRange();
      range.selectNodeContents(textarea);
      const sel = window.getSelection();
      if (sel != void 0) {
        sel.removeAllRanges();
        sel.addRange(range);
        textarea.setSelectionRange(0, textarea.value.length);
      }
      document.execCommand("copy");
    } catch {
      null;
    } finally {
      textarea.remove();
    }
  }
});
/* -------------------------------------------------- */
/*                       Groups                       */
/* -------------------------------------------------- */
__publicField(TLDR, "flattenShape", (data, shape) => {
  return [
    shape,
    ...(shape.children ?? []).map((childId) => _TLDR.getShape(data, childId, data.appState.currentPageId)).sort((a7, b6) => a7.childIndex - b6.childIndex).flatMap((shape2) => _TLDR.flattenShape(data, shape2))
  ];
});
__publicField(TLDR, "flattenPage", (data, pageId) => {
  return Object.values(data.document.pages[pageId].shapes).sort((a7, b6) => a7.childIndex - b6.childIndex).reduce((accumulator, shape) => [...accumulator, ..._TLDR.flattenShape(data, shape)], []);
});
__publicField(TLDR, "getTopChildIndex", (data, pageId) => {
  const shapes = _TLDR.getShapes(data, pageId);
  return shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === pageId).sort((a7, b6) => b6.childIndex - a7.childIndex)[0].childIndex + 1;
});
/* -------------------------------------------------- */
/*                        Text                        */
/* -------------------------------------------------- */
__publicField(TLDR, "fixNewLines", /\r?\n|\r/g);

// src/components/Tldraw/state/shapes/shared/TextLabel.tsx
var import_jsx_runtime63 = require("react/jsx-runtime");
var TextLabel = React45.memo(function TextLabel2({
  font,
  text,
  color,
  offsetX = 0,
  offsetY = 0,
  scale = 1,
  isEditing = false,
  onBlur,
  onChange
}) {
  const rInput = React45.useRef(null);
  const rIsMounted = React45.useRef(false);
  const handleChange = React45.useCallback(
    (e5) => {
      onChange(TLDR.normalizeText(e5.currentTarget.value));
    },
    [onChange]
  );
  const handleKeyDown = React45.useCallback(
    (e5) => {
      if (e5.key === "Escape") {
        e5.preventDefault();
        e5.stopPropagation();
        onBlur?.();
        return;
      }
      if (e5.key === "Tab" && text.length === 0) {
        e5.preventDefault();
        return;
      }
      if (!(e5.key === "Meta" || e5.metaKey)) {
        e5.stopPropagation();
      } else if (e5.key === "z" && e5.metaKey) {
        if (e5.shiftKey) {
          document.execCommand("redo", false);
        } else {
          document.execCommand("undo", false);
        }
        e5.stopPropagation();
        e5.preventDefault();
        return;
      }
      if ((e5.metaKey || e5.ctrlKey) && e5.key === "=") {
        e5.preventDefault();
      }
      if (e5.key === "Tab") {
        e5.preventDefault();
        if (e5.shiftKey) {
          TextAreaUtils.unindent(e5.currentTarget);
        } else {
          TextAreaUtils.indent(e5.currentTarget);
        }
        onChange?.(TLDR.normalizeText(e5.currentTarget.value));
      }
    },
    [onChange]
  );
  const handleBlur = React45.useCallback(
    (e5) => {
      e5.currentTarget.setSelectionRange(0, 0);
      onBlur?.();
    },
    [onBlur]
  );
  const handleFocus = React45.useCallback(
    (e5) => {
      if (!isEditing)
        return;
      if (!rIsMounted.current)
        return;
      if (document.activeElement === e5.currentTarget) {
        e5.currentTarget.select();
      }
    },
    [isEditing]
  );
  const handlePointerDown = React45.useCallback(
    (e5) => {
      if (isEditing) {
        e5.stopPropagation();
      }
    },
    [isEditing]
  );
  const rWasEditing = React45.useRef(isEditing);
  React45.useEffect(() => {
    if (isEditing) {
      rWasEditing.current = true;
      requestAnimationFrame(() => {
        rIsMounted.current = true;
        const elm = rInput.current;
        if (elm) {
          elm.focus();
          elm.select();
        }
      });
    } else if (rWasEditing.current) {
      onBlur?.();
      rWasEditing.current = false;
    }
  }, [isEditing, onBlur]);
  const rInnerWrapper = React45.useRef(null);
  React45.useLayoutEffect(() => {
    const elm = rInnerWrapper.current;
    if (!elm)
      return;
    const size = getTextLabelSize(text, font);
    elm.style.transform = `scale(${scale}, ${scale}) translate(${offsetX}px, ${offsetY}px)`;
    elm.style.width = size[0] + 1 + "px";
    elm.style.height = size[1] + 1 + "px";
  }, [text, font, offsetY, offsetX, scale]);
  return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(TextWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(
    InnerWrapper2,
    {
      ref: rInnerWrapper,
      hasText: !!text,
      isEditing,
      style: {
        font,
        color
      },
      children: [
        isEditing ? /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
          TextArea2,
          {
            ref: rInput,
            style: {
              font,
              color
            },
            name: "text",
            tabIndex: -1,
            autoComplete: "false",
            autoCapitalize: "false",
            autoCorrect: "false",
            autoSave: "false",
            autoFocus: true,
            placeholder: "",
            spellCheck: "true",
            wrap: "off",
            dir: "auto",
            datatype: "wysiwyg",
            defaultValue: text,
            color,
            onFocus: handleFocus,
            onChange: handleChange,
            onKeyDown: handleKeyDown,
            onBlur: handleBlur,
            onPointerDown: handlePointerDown,
            onContextMenu: stopPropagation3,
            onCopy: stopPropagation3,
            onPaste: stopPropagation3,
            onCut: stopPropagation3
          }
        ) : text,
        "\u200B"
      ]
    }
  ) });
});
var TextWrapper = styled("div", {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  pointerEvents: "none",
  userSelect: "none",
  variants: {
    isGhost: {
      false: { opacity: 1 },
      true: { transition: "opacity .2s", opacity: GHOSTED_OPACITY }
    }
  }
});
var commonTextWrapping3 = {
  whiteSpace: "pre-wrap",
  overflowWrap: "break-word",
  letterSpacing: LETTER_SPACING
};
var InnerWrapper2 = styled("div", {
  position: "absolute",
  padding: "4px",
  zIndex: 1,
  minHeight: 1,
  minWidth: 1,
  lineHeight: 1,
  outline: 0,
  fontWeight: "500",
  textAlign: "center",
  backfaceVisibility: "hidden",
  userSelect: "none",
  WebkitUserSelect: "none",
  WebkitTouchCallout: "none",
  variants: {
    hasText: {
      false: {
        pointerEvents: "none"
      },
      true: {
        pointerEvents: "all"
      }
    },
    isEditing: {
      false: {
        userSelect: "none"
      },
      true: {
        background: "$boundsBg",
        userSelect: "text",
        WebkitUserSelect: "text"
      }
    }
  },
  ...commonTextWrapping3
});
var TextArea2 = styled("textarea", {
  position: "absolute",
  top: 0,
  left: 0,
  zIndex: 1,
  width: "100%",
  height: "100%",
  border: "none",
  padding: "4px",
  resize: "none",
  textAlign: "inherit",
  minHeight: "inherit",
  minWidth: "inherit",
  lineHeight: "inherit",
  outline: 0,
  fontWeight: "inherit",
  overflow: "hidden",
  backfaceVisibility: "hidden",
  display: "inline-block",
  pointerEvents: "all",
  background: "$boundsBg",
  userSelect: "text",
  WebkitUserSelect: "text",
  fontSmooth: "always",
  WebkitFontSmoothing: "subpixel-antialiased",
  MozOsxFontSmoothing: "auto",
  ...commonTextWrapping3,
  "&:focus": {
    outline: "none",
    border: "none"
  }
});

// src/components/Tldraw/state/shapes/shared/transformRectangle.ts
function transformRectangle(shape, bounds, { initialShape, transformOrigin, scaleX, scaleY }) {
  if (shape.rotation || initialShape.isAspectRatioLocked) {
    const size = p.toFixed(p.mul(initialShape.size, Math.min(Math.abs(scaleX), Math.abs(scaleY))));
    const point = p.toFixed([
      bounds.minX + (bounds.width - shape.size[0]) * (scaleX < 0 ? 1 - transformOrigin[0] : transformOrigin[0]),
      bounds.minY + (bounds.height - shape.size[1]) * (scaleY < 0 ? 1 - transformOrigin[1] : transformOrigin[1])
    ]);
    const rotation = scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? initialShape.rotation ? -initialShape.rotation : 0 : initialShape.rotation;
    return {
      size,
      point,
      rotation
    };
  } else {
    return {
      point: p.toFixed([bounds.minX, bounds.minY]),
      size: p.toFixed([bounds.width, bounds.height])
    };
  }
}

// src/components/Tldraw/state/shapes/shared/transformSingleRectangle.ts
function transformSingleRectangle(shape, bounds) {
  return {
    size: p.toFixed([bounds.width, bounds.height]),
    point: p.toFixed([bounds.minX, bounds.minY])
  };
}

// src/components/Tldraw/components/TopPanel/StyleMenu/StyleMenu.tsx
var import_jsx_runtime64 = require("react/jsx-runtime");
var currentStyleSelector = (s5) => s5.appState.currentStyle;
var selectedIdsSelector = (s5) => s5.document.pageStates[s5.appState.currentPageId].selectedIds;
var STYLE_KEYS = Object.keys(defaultTextStyle);
var DASH_ICONS = {
  ["draw" /* Draw */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DashDrawIcon, {}),
  ["solid" /* Solid */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DashSolidIcon, {}),
  ["dashed" /* Dashed */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DashDashedIcon, {}),
  ["dotted" /* Dotted */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DashDottedIcon, {})
};
var SIZE_ICONS = {
  ["small" /* Small */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(SizeSmallIcon, {}),
  ["medium" /* Medium */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(SizeMediumIcon, {}),
  ["large" /* Large */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(SizeLargeIcon, {})
};
var ALIGN_ICONS = {
  ["start" /* Start */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(TextAlignLeftIcon, {}),
  ["middle" /* Middle */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(TextAlignCenterIcon, {}),
  ["end" /* End */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(TextAlignRightIcon, {}),
  ["justify" /* Justify */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(TextAlignJustifyIcon, {})
};
var themeSelector = (s5) => "light";
var keepOpenSelector = (s5) => s5.settings.keepStyleMenuOpen;
var optionsSelector = (s5) => {
  const { activeTool, currentPageId: pageId } = s5.appState;
  switch (activeTool) {
    case "select": {
      const page = s5.document.pages[pageId];
      let hasText = false;
      let hasLabel = false;
      for (const id of s5.document.pageStates[pageId].selectedIds) {
        if ("text" in page.shapes[id])
          hasText = true;
        if ("label" in page.shapes[id])
          hasLabel = true;
      }
      return hasText ? "text" : hasLabel ? "label" : "";
    }
    case "text" /* Text */: {
      return "text";
    }
    case "rectangle" /* Rectangle */: {
      return "label";
    }
    case "ellipse" /* Ellipse */: {
      return "label";
    }
    case "triangle" /* Triangle */: {
      return "label";
    }
    case "arrow" /* Arrow */: {
      return "label";
    }
    case "line" /* Line */: {
      return "label";
    }
  }
  return false;
};
var StyleMenu = React46.memo(function ColorMenu() {
  const app = useTldrawApp();
  const theme = app.useStore(themeSelector);
  const keepOpen = app.useStore(keepOpenSelector);
  const options = app.useStore(optionsSelector);
  const currentStyle = app.useStore(currentStyleSelector);
  const selectedIds = app.useStore(selectedIdsSelector);
  const [displayedStyle, setDisplayedStyle] = React46.useState(currentStyle);
  const rDisplayedStyle = React46.useRef(currentStyle);
  React46.useEffect(() => {
    const {
      appState: { currentStyle: currentStyle2 },
      page,
      selectedIds: selectedIds2
    } = app;
    let commonStyle = {};
    if (selectedIds2.length <= 0) {
      commonStyle = currentStyle2;
    } else {
      const overrides = /* @__PURE__ */ new Set([]);
      app.selectedIds.map((id) => page.shapes[id]).forEach((shape) => {
        STYLE_KEYS.forEach((key) => {
          if (overrides.has(key))
            return;
          if (commonStyle[key] === void 0) {
            commonStyle[key] = shape.style[key];
          } else {
            if (commonStyle[key] === shape.style[key])
              return;
            commonStyle[key] = shape.style[key];
            overrides.add(key);
          }
        });
      });
    }
    if (JSON.stringify(commonStyle) !== JSON.stringify(rDisplayedStyle.current)) {
      rDisplayedStyle.current = commonStyle;
      setDisplayedStyle(commonStyle);
    }
  }, [currentStyle, selectedIds]);
  const handleToggleKeepOpen = React46.useCallback((checked) => {
    app.setSetting("keepStyleMenuOpen", checked);
  }, []);
  const handleToggleFilled = React46.useCallback((checked) => {
    app.style({ isFilled: checked });
  }, []);
  const handleDashChange = React46.useCallback((value) => {
    app.style({ dash: value });
  }, []);
  const handleSizeChange = React46.useCallback((value) => {
    app.style({ size: value });
  }, []);
  const handleFontChange = React46.useCallback((value) => {
    app.style({ font: value });
  }, []);
  const handleTextAlignChange = React46.useCallback((value) => {
    app.style({ textAlign: value });
  }, []);
  const handleMenuOpenChange = React46.useCallback(
    (open) => {
      app.setMenuOpen(open);
    },
    [app]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: "ltr", onOpenChange: handleMenuOpenChange, open: keepOpen ? true : void 0, modal: false, children: [
    /* @__PURE__ */ (0, import_jsx_runtime64.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { asChild: true, id: "TD-Styles", children: /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(ToolButton, { variant: "text", children: [
      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: "styles" }),
      /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(
        OverlapIcons,
        {
          style: {
            color: strokes[theme][displayedStyle.color]
          },
          children: [
            displayedStyle.isFilled && /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(CircleIcon2, { size: 16, stroke: "none", fill: fills[theme][displayedStyle.color] }),
            DASH_ICONS[displayedStyle.dash]
          ]
        }
      )
    ] }) }),
    /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(DMContent, { id: "language-menu", side: "bottom", align: "end", sideOffset: 4, alignOffset: 4, children: [
      /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(StyledRow, { variant: "tall", id: "TD-Styles-Color-Container", children: [
        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("span", { children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: "style.menu.color" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(ColorGrid, { children: Object.keys(strokes.light).map((style) => /* @__PURE__ */ (0, import_jsx_runtime64.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { onSelect: preventEvent, asChild: true, id: `TD-Styles-Color-Swatch-${style}`, children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(ToolButton, { variant: "icon", isActive: displayedStyle.color === style, onClick: () => app.style({ color: style }), children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
          CircleIcon2,
          {
            size: 18,
            strokeWidth: 2.5,
            fill: displayedStyle.isFilled ? fills[theme][style] : "transparent",
            stroke: strokes.light[style]
          }
        ) }) }, style)) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DMCheckboxItem, { variant: "styleMenu", checked: !!displayedStyle.isFilled, onCheckedChange: handleToggleFilled, id: "TD-Styles-Fill", children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: "style.menu.fill" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(StyledRow, { id: "TD-Styles-Dash-Container", children: [
        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: "style.menu.dash" }),
        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(StyledGroup, { dir: "ltr", value: displayedStyle.dash, onValueChange: handleDashChange, children: Object.values(DashStyle).map((style) => /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
          DMRadioItem,
          {
            isActive: style === displayedStyle.dash,
            value: style,
            onSelect: preventEvent,
            bp: breakpoints,
            id: `TD-Styles-Dash-${style}`,
            children: DASH_ICONS[style]
          },
          style
        )) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(StyledRow, { id: "TD-Styles-Size-Container", children: [
        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: "style.menu.size" }),
        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(StyledGroup, { dir: "ltr", value: displayedStyle.size, onValueChange: handleSizeChange, children: Object.values(SizeStyle).map((sizeStyle) => /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
          DMRadioItem,
          {
            isActive: sizeStyle === displayedStyle.size,
            value: sizeStyle,
            onSelect: preventEvent,
            bp: breakpoints,
            id: `TD-Styles-Dash-${sizeStyle}`,
            children: SIZE_ICONS[sizeStyle]
          },
          sizeStyle
        )) })
      ] }),
      (options === "text" || options === "label") && /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(import_jsx_runtime64.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(Divider, {}),
        /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(StyledRow, { id: "TD-Styles-Font-Container", children: [
          /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: "style.menu.font" }),
          /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(StyledGroup, { dir: "ltr", value: displayedStyle.font, onValueChange: handleFontChange, children: Object.values(FontStyle).map((fontStyle) => /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
            DMRadioItem,
            {
              isActive: fontStyle === displayedStyle.font,
              value: fontStyle,
              onSelect: preventEvent,
              bp: breakpoints,
              id: `TD-Styles-Font-${fontStyle}`,
              children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FontIcon, { fontStyle, children: "Aa" })
            },
            fontStyle
          )) })
        ] }),
        options === "text" && /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(StyledRow, { id: "TD-Styles-Align-Container", children: [
          /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: "style.menu.align" }),
          /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(StyledGroup, { dir: "ltr", value: displayedStyle.textAlign, onValueChange: handleTextAlignChange, children: Object.values(AlignStyle).map((style) => /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
            DMRadioItem,
            {
              isActive: style === displayedStyle.textAlign,
              value: style,
              onSelect: preventEvent,
              bp: breakpoints,
              id: `TD-Styles-Align-${style}`,
              children: ALIGN_ICONS[style]
            },
            style
          )) })
        ] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(Divider, {}),
      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DMCheckboxItem, { variant: "styleMenu", checked: keepOpen, onCheckedChange: handleToggleKeepOpen, id: "TD-Styles-Keep-Open", children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: "style.menu.keep.open" }) })
    ] })
  ] });
});
var ColorGrid = styled("div", {
  display: "grid",
  gridTemplateColumns: "repeat(4, auto)",
  gap: 0
});
var StyledRow = styled("div", {
  position: "relative",
  width: "100%",
  background: "none",
  border: "none",
  cursor: "pointer",
  minHeight: "32px",
  outline: "none",
  color: "$text",
  fontFamily: "$ui",
  fontWeight: 400,
  fontSize: "$1",
  padding: "$2 0 $2 $3",
  borderRadius: 4,
  userSelect: "none",
  margin: 0,
  display: "flex",
  gap: "$3",
  flexDirection: "row",
  alignItems: "center",
  justifyContent: "space-between",
  variants: {
    variant: {
      tall: {
        alignItems: "flex-start",
        padding: "0 0 0 $3",
        "& > span": {
          paddingTop: "$4"
        }
      }
    }
  }
});
var StyledGroup = styled($d08ef79370b62062$export$3323ad73d55f587e, {
  display: "flex",
  flexDirection: "row",
  gap: "$1"
});
var OverlapIcons = styled("div", {
  display: "grid",
  "& > *": {
    gridColumn: 1,
    gridRow: 1
  }
});
var FontIcon = styled("div", {
  width: 32,
  height: 32,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  fontSize: "$3",
  variants: {
    fontStyle: {
      ["script" /* Script */]: {
        fontFamily: "Caveat Brush"
      },
      ["sans" /* Sans */]: {
        fontFamily: "Recursive"
      },
      ["serif" /* Serif */]: {
        fontFamily: "Georgia"
      },
      ["mono" /* Mono */]: {
        fontFamily: "Recursive Mono"
      }
    }
  }
});

// src/components/Tldraw/components/TopPanel/ZoomMenu/ZoomMenu.tsx
var import_jsx_runtime65 = require("react/jsx-runtime");
var zoomSelector = (s5) => s5.document.pageStates[s5.appState.currentPageId].camera.zoom;
var ZoomMenu = function ZoomMenu2() {
  const app = useTldrawApp();
  const zoom = app.useStore(zoomSelector);
  return /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: "ltr", children: [
    /* @__PURE__ */ (0, import_jsx_runtime65.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { dir: "ltr", asChild: true, id: "TD-Zoom", children: /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(FixedWidthToolButton, { onDoubleClick: app.resetZoom, variant: "text", children: [
      Math.round(zoom * 100),
      "%"
    ] }) }),
    /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(DMContent, { align: "end", children: [
      /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomIn, kbd: "#+", id: "TD-Zoom-Zoom_In", children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(FormattedMessage, { id: "zoom.in" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomOut, kbd: "#\u2212", id: "TD-Zoom-Zoom_Out", children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(FormattedMessage, { id: "zoom.out" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(DMItem, { onSelect: preventEvent, onClick: app.resetZoom, kbd: "\u21E70", id: "TD-Zoom-Zoom_To_100%", children: [
        /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(FormattedMessage, { id: "zoom.to" }),
        " 100%"
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomToFit, kbd: "\u21E71", id: "TD-Zoom-To_Fit", children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(FormattedMessage, { id: "zoom.to.fit" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomToSelection, kbd: "\u21E72", id: "TD-Zoom-To_Selection", children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(FormattedMessage, { id: "zoom.to.selection" }) })
    ] })
  ] });
};
var FixedWidthToolButton = styled(ToolButton, {
  minWidth: 56
});

// src/components/Tldraw/components/TopPanel/TopPanel.tsx
var import_jsx_runtime66 = require("react/jsx-runtime");
function _TopPanel({ readOnly, showPages, showMenu, showStyles, showZoom }) {
  const app = useTldrawApp();
  return /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(StyledTopPanel, { children: [
    (showMenu || showPages) && /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(Panel, { side: "left", id: "TD-MenuPanel", children: [
      showMenu && /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(Menu, { readOnly }),
      showPages && /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(PageMenu, {})
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(StyledSpacer, {}),
    (showStyles || showZoom) && /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(Panel, { side: "right", children: [
      readOnly ? /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(ReadOnlyLabel, { children: "Read Only" }) : /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(import_jsx_runtime66.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(ToolButton, { children: /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(UndoIcon, { onClick: app.undo }) }),
        /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(ToolButton, { children: /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(UndoIcon, { onClick: app.redo, flipHorizontal: true }) })
      ] }),
      showZoom && /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(ZoomMenu, {}),
      showStyles && !readOnly && /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(StyleMenu, {})
    ] })
  ] });
}
var StyledTopPanel = styled("div", {
  width: "100%",
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  display: "flex",
  flexDirection: "row",
  pointerEvents: "none",
  "& > *": {
    pointerEvents: "all"
  }
});
var StyledSpacer = styled("div", {
  flexGrow: 2,
  pointerEvents: "none"
});
var ReadOnlyLabel = styled("div", {
  width: "100%",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  fontFamily: "$ui",
  fontSize: "$1",
  paddingLeft: "$4",
  paddingRight: "$1",
  userSelect: "none"
});
var TopPanel = React47.memo(_TopPanel);

// src/components/Tldraw/hooks/useCursor.ts
var import_react40 = __toESM(require("react"));
function useCursor(reference) {
  import_react40.default.useEffect(() => {
    let isPointing = false;
    let isSpacePanning = false;
    const elm = reference.current;
    if (elm == void 0)
      return;
    const onKeyDown = (e5) => {
      if (e5.key === " " && !isSpacePanning) {
        isSpacePanning = true;
        if (isPointing) {
          elm.setAttribute("style", "cursor: grabbing !important");
        } else {
          elm.setAttribute("style", "cursor: grab !important");
        }
      }
    };
    const onKeyUp = (e5) => {
      if (e5.key === " ") {
        isSpacePanning = false;
        elm.setAttribute("style", "cursor: initial");
      }
    };
    const onPointerDown = (e5) => {
      isPointing = true;
      if (e5.button === 1) {
        elm.setAttribute("style", "cursor: grabbing !important");
      }
      if (e5.button === 0 && isSpacePanning) {
        elm.setAttribute("style", "cursor: grabbing !important");
      }
    };
    const onPointerUp = () => {
      isPointing = false;
      if (isSpacePanning) {
        elm.setAttribute("style", "cursor: grab !important");
      } else {
        elm.setAttribute("style", "cursor: initial");
      }
    };
    elm.addEventListener("keydown", onKeyDown);
    elm.addEventListener("keyup", onKeyUp);
    elm.addEventListener("pointerdown", onPointerDown);
    elm.addEventListener("pointerup", onPointerUp);
    return () => {
      elm.removeEventListener("keydown", onKeyDown);
      elm.removeEventListener("keyup", onKeyUp);
      elm.removeEventListener("pointerdown", onPointerDown);
      elm.removeEventListener("pointerup", onPointerUp);
    };
  }, [reference.current]);
}

// node_modules/.pnpm/zustand@4.3.8_react@18.2.0/node_modules/zustand/esm/vanilla.mjs
var import_meta = {};
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((import_meta.env && import_meta.env.MODE) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, subscribe, destroy };
  state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
var vanilla = (createState) => {
  if ((import_meta.env && import_meta.env.MODE) !== "production") {
    console.warn(
      "[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'."
    );
  }
  return createStore(createState);
};

// node_modules/.pnpm/zustand@4.3.8_react@18.2.0/node_modules/zustand/esm/index.mjs
var import_react41 = require("react");
var import_with_selector = __toESM(require_with_selector(), 1);
var import_meta2 = {};
var { useSyncExternalStoreWithSelector } = import_with_selector.default;
function useStore(api, selector = api.getState, equalityFn) {
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getState,
    selector,
    equalityFn
  );
  (0, import_react41.useDebugValue)(slice);
  return slice;
}
var createImpl = (createState) => {
  if ((import_meta2.env && import_meta2.env.MODE) !== "production" && typeof createState !== "function") {
    console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
  }
  const api = typeof createState === "function" ? createStore(createState) : createState;
  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
var create = (createState) => createState ? createImpl(createState) : createImpl;
var react = (createState) => {
  if ((import_meta2.env && import_meta2.env.MODE) !== "production") {
    console.warn(
      "[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`."
    );
  }
  return create(createState);
};

// src/components/Tldraw/state/StateManager/StateManager.ts
var StateManager = class {
  /**
   * The initial state.
   */
  initialState;
  /**
   * A zustand store that also holds the state.
   */
  store;
  /**
   * The index of the current command.
   */
  pointer = -1;
  /**
   * The current state.
   */
  _state;
  /**
   * The state manager's current status, with regard to restoring persisted state.
   */
  _status = "loading";
  /**
   * A stack of commands used for history (undo and redo).
   */
  stack = [];
  /**
   * A snapshot of the current state.
   */
  _snapshot;
  /**
   * A React hook for accessing the zustand store.
   */
  useStore;
  /**
   * A promise that will resolve when the state manager has loaded any peristed state.
   */
  ready;
  isPaused = false;
  constructor(initialState, id, version, update) {
    this._state = deepCopy(initialState);
    this._snapshot = deepCopy(initialState);
    this.initialState = deepCopy(initialState);
    this.store = vanilla(() => this._state);
    this.useStore = react(this.store);
    this.ready = new Promise((resolve) => {
      let message = "none";
      this._status = "ready";
      resolve(message);
    }).then((message) => {
      if (this.onReady)
        this.onReady(message);
      return message;
    });
  }
  /**
   * Save the current state to indexdb.
   */
  persist = (patch, id) => {
    if (this._status !== "ready")
      return;
    if (this.onPersist) {
      this.onPersist(this._state, patch, id);
    }
  };
  /**
   * Apply a patch to the current state.
   * This does not effect the undo/redo stack.
   * This does not persist the state.
   * @param patch The patch to apply.
   * @param id (optional) An id for the patch.
   */
  applyPatch = (patch, id) => {
    const prev = this._state;
    const next = C3.deepMerge(this._state, patch);
    const final = this.cleanup(next, prev, patch, id);
    if (this.onStateWillChange) {
      this.onStateWillChange(final, id);
    }
    this._state = final;
    this.store.setState(this._state, true);
    if (this.onStateDidChange) {
      this.onStateDidChange(this._state, id);
    }
    return this;
  };
  // Internal API ---------------------------------
  migrate = (next) => {
    return next;
  };
  /**
   * Perform any last changes to the state before updating.
   * Override this on your extending class.
   * @param nextState The next state.
   * @param prevState The previous state.
   * @param patch The patch that was just applied.
   * @param id (optional) An id for the just-applied patch.
   * @returns The final new state to apply.
   */
  cleanup = (nextState, _prevState, _patch, _id) => nextState;
  /**
   * A life-cycle method called when the state is about to change.
   * @param state The next state.
   * @param id An id for the change.
   */
  onStateWillChange;
  /**
   * A life-cycle method called when the state has changed.
   * @param state The next state.
   * @param id An id for the change.
   */
  onStateDidChange;
  /**
   * Apply a patch to the current state.
   * This does not effect the undo/redo stack.
   * This does not persist the state.
   * @param patch The patch to apply.
   * @param id (optional) An id for this patch.
   */
  patchState = (patch, id) => {
    this.applyPatch(patch, id);
    if (this.onPatch) {
      this.onPatch(this._state, patch, id);
    }
    return this;
  };
  /**
   * Replace the current state.
   * This does not effect the undo/redo stack.
   * This does not persist the state.
   * @param state The new state.
   * @param id An id for this change.
   */
  replaceState = (state, id) => {
    const final = this.cleanup(state, this._state, state, id);
    if (this.onStateWillChange) {
      this.onStateWillChange(final, "replace");
    }
    this._state = final;
    this.store.setState(this._state, true);
    if (this.onStateDidChange) {
      this.onStateDidChange(this._state, "replace");
    }
    return this;
  };
  /**
   * Update the state using a Command.
   * This effects the undo/redo stack.
   * This persists the state.
   * @param command The command to apply and add to the undo/redo stack.
   * @param id (optional) An id for this command.
   */
  setState = (command, id = command.id) => {
    if (this.pointer < this.stack.length - 1) {
      this.stack = this.stack.slice(0, this.pointer + 1);
    }
    this.stack.push({ ...command, id });
    this.pointer = this.stack.length - 1;
    this.applyPatch(command.after, id);
    if (this.onCommand)
      this.onCommand(this._state, command, id);
    this.persist(command.after, id);
    return this;
  };
  // Public API ---------------------------------
  pause() {
    this.isPaused = true;
  }
  resume() {
    this.isPaused = false;
  }
  /**
   * A callback fired when the constructor finishes loading any
   * persisted data.
   */
  onReady;
  /**
   * A callback fired when a patch is applied.
   */
  onPatch;
  /**
   * A callback fired when a patch is applied.
   */
  onCommand;
  /**
   * A callback fired when the state is persisted.
   */
  onPersist;
  /**
   * A callback fired when the state is replaced.
   */
  onReplace;
  /**
   * A callback fired when the state is reset.
   */
  onReset;
  /**
   * A callback fired when the history is reset.
   */
  onResetHistory;
  /**
   * A callback fired when a command is undone.
   */
  onUndo;
  /**
   * A callback fired when a command is redone.
   */
  onRedo;
  /**
   * Reset the state to the initial state and reset history.
   */
  reset = () => {
    if (this.onStateWillChange) {
      this.onStateWillChange(this.initialState, "reset");
    }
    this._state = this.initialState;
    this.store.setState(this._state, true);
    this.resetHistory();
    this.persist({}, "reset");
    if (this.onStateDidChange) {
      this.onStateDidChange(this._state, "reset");
    }
    if (this.onReset) {
      this.onReset(this._state);
    }
    return this;
  };
  /**
   * Force replace a new undo/redo history. It's your responsibility
   * to make sure that this is compatible with the current state!
   * @param history The new array of commands.
   * @param pointer (optional) The new pointer position.
   */
  replaceHistory = (history, pointer = history.length - 1) => {
    this.stack = history;
    this.pointer = pointer;
    if (this.onReplace) {
      this.onReplace(this._state);
    }
    return this;
  };
  /**
   * Reset the history stack (without resetting the state).
   */
  resetHistory = () => {
    this.stack = [];
    this.pointer = -1;
    if (this.onResetHistory) {
      this.onResetHistory(this._state);
    }
    return this;
  };
  /**
   * Move backward in the undo/redo stack.
   */
  undo = () => {
    if (!this.isPaused) {
      if (!this.canUndo)
        return this;
      const command = this.stack[this.pointer];
      this.pointer--;
      this.applyPatch(command.before, `undo`);
      this.persist(command.before, "undo");
    }
    if (this.onUndo)
      this.onUndo(this._state);
    return this;
  };
  /**
   * Move forward in the undo/redo stack.
   */
  redo = () => {
    if (!this.isPaused) {
      if (!this.canRedo)
        return this;
      this.pointer++;
      const command = this.stack[this.pointer];
      this.applyPatch(command.after, "redo");
      this.persist(command.after, "undo");
    }
    if (this.onRedo)
      this.onRedo(this._state);
    return this;
  };
  /**
   * Save a snapshot of the current state, accessible at `this.snapshot`.
   */
  setSnapshot = () => {
    this._snapshot = { ...this._state };
    return this;
  };
  /**
   * Force the zustand state to update.
   */
  forceUpdate = () => {
    this.store.setState(this._state, true);
  };
  /**
   * Get whether the state manager can undo.
   */
  get canUndo() {
    return this.pointer > -1;
  }
  /**
   * Get whether the state manager can redo.
   */
  get canRedo() {
    return this.pointer < this.stack.length - 1;
  }
  /**
   * The current state.
   */
  get state() {
    return this._state;
  }
  /**
   * The current status.
   */
  get status() {
    return this._status;
  }
  /**
   * The most-recent snapshot.
   */
  get snapshot() {
    return this._snapshot;
  }
};

// src/components/Tldraw/state/commands/alignShapes/alignShapes.ts
function alignShapes(app, ids, type) {
  const { currentPageId } = app;
  const initialShapes = ids.map((id) => app.getShape(id));
  const boundsForShapes = initialShapes.map((shape) => {
    return {
      id: shape.id,
      point: [...shape.point],
      bounds: TLDR.getBounds(shape)
    };
  });
  const commonBounds = C3.getCommonBounds(boundsForShapes.map(({ bounds }) => bounds));
  const midX = commonBounds.minX + commonBounds.width / 2;
  const midY = commonBounds.minY + commonBounds.height / 2;
  const deltaMap = Object.fromEntries(
    boundsForShapes.map(({ id, point, bounds }) => {
      return [
        id,
        {
          prev: point,
          next: {
            ["top" /* Top */]: [point[0], commonBounds.minY],
            ["centerVertical" /* CenterVertical */]: [point[0], midY - bounds.height / 2],
            ["bottom" /* Bottom */]: [point[0], commonBounds.maxY - bounds.height],
            ["left" /* Left */]: [commonBounds.minX, point[1]],
            ["centerHorizontal" /* CenterHorizontal */]: [midX - bounds.width / 2, point[1]],
            ["right" /* Right */]: [commonBounds.maxX - bounds.width, point[1]]
          }[type]
        }
      ];
    })
  );
  const { before, after } = TLDR.mutateShapes(
    app.state,
    ids,
    (shape) => {
      if (!deltaMap[shape.id])
        return shape;
      return { point: deltaMap[shape.id].next };
    },
    currentPageId,
    false
  );
  initialShapes.forEach((shape) => {
    if (shape.type === "group" /* Group */) {
      const delta = e.sub(after[shape.id].point, before[shape.id].point);
      shape.children.forEach((id) => {
        const child = app.getShape(id);
        before[child.id] = { point: child.point };
        after[child.id] = { point: e.add(child.point, delta) };
      });
      delete before[shape.id];
      delete after[shape.id];
    }
  });
  return {
    id: "align",
    before: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: before
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: after
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/changePage/changePage.ts
function changePage(app, pageId) {
  return {
    id: "change_page",
    before: {
      appState: {
        currentPageId: app.currentPageId
      }
    },
    after: {
      appState: {
        currentPageId: pageId
      }
    }
  };
}

// src/components/Tldraw/state/commands/shared/getIncrementedName.ts
function getIncrementedName(name, others) {
  let result = name;
  const set = new Set(others);
  while (set.has(result)) {
    result = /^.*(\d+)$/.exec(result)?.[1] ? result.replace(/(\d+)(?=\D?)$/, (m6) => (+m6 + 1).toString()) : `${result} 1`;
  }
  return result;
}

// src/components/Tldraw/state/commands/shared/removeShapesFromPage.ts
function removeShapesFromPage(data, ids, pageId) {
  const before = {
    shapes: {},
    bindings: {}
  };
  const after = {
    shapes: {},
    bindings: {}
  };
  const parentsToUpdate = [];
  const deletedIds = /* @__PURE__ */ new Set();
  const assetsToRemove = /* @__PURE__ */ new Set();
  ids.filter((id) => !TLDR.getShape(data, id, pageId).isLocked).forEach((id) => {
    deletedIds.add(id);
    const shape = TLDR.getShape(data, id, pageId);
    before.shapes[id] = shape;
    after.shapes[id] = void 0;
    if (shape.children !== void 0) {
      shape.children.forEach((childId) => {
        deletedIds.add(childId);
        const child = TLDR.getShape(data, childId, pageId);
        before.shapes[childId] = child;
        after.shapes[childId] = void 0;
      });
    }
    if (shape.parentId !== pageId) {
      parentsToUpdate.push(TLDR.getShape(data, shape.parentId, pageId));
    }
    if (shape.assetId) {
      assetsToRemove.add(shape.assetId);
    }
  });
  parentsToUpdate.forEach((parent) => {
    if (ids.includes(parent.id))
      return;
    deletedIds.add(parent.id);
    before.shapes[parent.id] = { children: parent.children };
    after.shapes[parent.id] = { children: parent.children.filter((id) => !ids.includes(id)) };
    if (after.shapes[parent.id]?.children.length === 0) {
      after.shapes[parent.id] = void 0;
      before.shapes[parent.id] = TLDR.getShape(data, parent.id, pageId);
    }
  });
  const page = TLDR.getPage(data, pageId);
  Object.values(page.bindings).filter((binding) => deletedIds.has(binding.fromId) || deletedIds.has(binding.toId)).forEach((binding) => {
    for (const id of [binding.toId, binding.fromId]) {
      if (after.shapes[id] === void 0) {
        before.bindings[binding.id] = binding;
        after.bindings[binding.id] = void 0;
        const shape = page.shapes[id];
        if (shape && shape.handles) {
          Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {
            before.shapes[id] = {
              ...before.shapes[id],
              handles: {
                ...before.shapes[id]?.handles,
                [handle.id]: {
                  ...before.shapes[id]?.handles?.[handle.id],
                  bindingId: binding.id
                }
              }
            };
            if (!deletedIds.has(id)) {
              after.shapes[id] = {
                ...after.shapes[id],
                handles: {
                  ...after.shapes[id]?.handles,
                  [handle.id]: {
                    ...after.shapes[id]?.handles?.[handle.id],
                    bindingId: void 0
                  }
                }
              };
            }
          });
        }
      }
    }
  });
  Object.values(data.document.pages).flatMap((page2) => Object.values(page2.shapes)).forEach((shape) => {
    if ("assetId" in shape && shape.assetId && !deletedIds.has(shape.id)) {
      assetsToRemove.delete(shape.assetId);
    }
  });
  return { before, after, assetsToRemove: [...assetsToRemove] };
}

// src/components/Tldraw/state/commands/createPage/createPage.ts
function createPage(app, center, pageId = C3.uniqueId(), pageName = "Page") {
  const { currentPageId } = app;
  const pages = Object.values(app.state.document.pages).sort((a7, b6) => (a7.childIndex ?? 0) - (b6.childIndex ?? 0));
  const topPage = pages[pages.length - 1];
  const nextChildIndex = topPage?.childIndex ? topPage?.childIndex + 1 : 1;
  const page = {
    id: pageId,
    name: getIncrementedName(
      pageName,
      pages.map((p6) => p6.name ?? "")
    ),
    childIndex: nextChildIndex,
    shapes: {},
    bindings: {}
  };
  const pageState = {
    id: pageId,
    selectedIds: [],
    camera: { point: center, zoom: 1 },
    editingId: void 0,
    bindingId: void 0,
    hoveredId: void 0,
    pointedId: void 0
  };
  return {
    id: "create_page",
    before: {
      appState: {
        currentPageId
      },
      document: {
        pages: {
          [pageId]: void 0
        },
        pageStates: {
          [pageId]: void 0
        }
      }
    },
    after: {
      appState: {
        currentPageId: page.id
      },
      document: {
        pages: {
          [pageId]: page
        },
        pageStates: {
          [pageId]: pageState
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/createShapes/createShapes.ts
function createShapes(app, shapes, bindings = []) {
  const { currentPageId } = app;
  const beforeShapes = {};
  const afterShapes = {};
  shapes.forEach((shape) => {
    beforeShapes[shape.id] = void 0;
    afterShapes[shape.id] = shape;
  });
  const beforeBindings = {};
  const afterBindings = {};
  bindings.forEach((binding) => {
    beforeBindings[binding.id] = void 0;
    afterBindings[binding.id] = binding;
  });
  return {
    id: "create",
    before: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: beforeShapes,
            bindings: beforeBindings
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: [...app.selectedIds]
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: afterShapes,
            bindings: afterBindings
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: shapes.map((shape) => shape.id)
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/deletePage/deletePage.ts
function deletePage(app, pageId) {
  const {
    currentPageId,
    document: { pages, pageStates }
  } = app;
  const pagesArr = Object.values(pages).sort((a7, b6) => (a7.childIndex || 0) - (b6.childIndex || 0));
  const currentIndex = pagesArr.findIndex((page) => page.id === pageId);
  let nextCurrentPageId;
  if (pageId === currentPageId) {
    if (currentIndex === pagesArr.length - 1) {
      nextCurrentPageId = pagesArr[pagesArr.length - 2].id;
    } else {
      nextCurrentPageId = pagesArr[currentIndex + 1].id;
    }
  } else {
    nextCurrentPageId = currentPageId;
  }
  return {
    id: "delete_page",
    before: {
      appState: {
        currentPageId: pageId
      },
      document: {
        pages: {
          [pageId]: { ...pages[pageId] }
        },
        pageStates: {
          [pageId]: { ...pageStates[pageId] }
        }
      }
    },
    after: {
      appState: {
        currentPageId: nextCurrentPageId
      },
      document: {
        pages: {
          [pageId]: void 0
        },
        pageStates: {
          [pageId]: void 0
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/deleteShapes/deleteShapes.ts
var removeAssetsFromDocument = (assets, idsToRemove) => {
  const afterAssets = { ...assets };
  idsToRemove.forEach((id) => afterAssets[id] = void 0);
  return afterAssets;
};
function deleteShapes(app, ids, pageId = app.currentPageId) {
  const {
    pageState,
    selectedIds,
    document: { assets: beforeAssets }
  } = app;
  const { before, after, assetsToRemove } = removeShapesFromPage(app.state, ids, pageId);
  const afterAssets = removeAssetsFromDocument(beforeAssets, assetsToRemove);
  return {
    id: "delete",
    before: {
      document: {
        assets: beforeAssets,
        pages: {
          [pageId]: before
        },
        pageStates: {
          [pageId]: { selectedIds: [...app.selectedIds] }
        }
      }
    },
    after: {
      document: {
        assets: afterAssets,
        pages: {
          [pageId]: after
        },
        pageStates: {
          [pageId]: {
            selectedIds: selectedIds.filter((id) => !ids.includes(id)),
            hoveredId: pageState.hoveredId && ids.includes(pageState.hoveredId) ? void 0 : pageState.hoveredId
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/distributeShapes/distributeShapes.ts
function distributeShapes(app, ids, type) {
  const { currentPageId } = app;
  const initialShapes = ids.map((id) => app.getShape(id));
  const deltaMap = Object.fromEntries(getDistributions(initialShapes, type).map((d6) => [d6.id, d6]));
  const { before, after } = TLDR.mutateShapes(
    app.state,
    ids.filter((id) => deltaMap[id] !== void 0),
    (shape) => ({ point: deltaMap[shape.id]?.next }),
    currentPageId
  );
  initialShapes.forEach((shape) => {
    if (shape.type === "group" /* Group */) {
      const delta = p.sub(after[shape.id].point, before[shape.id].point);
      shape.children.forEach((id) => {
        const child = app.getShape(id);
        before[child.id] = { point: child.point };
        after[child.id] = { point: p.add(child.point, delta) };
      });
      delete before[shape.id];
      delete after[shape.id];
    }
  });
  return {
    id: "distribute",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function getDistributions(initialShapes, type) {
  const entries = initialShapes.map((shape) => {
    const utils = TLDR.getShapeUtil(shape);
    return {
      id: shape.id,
      point: [...shape.point],
      bounds: utils.getBounds(shape),
      center: utils.getCenter(shape)
    };
  });
  const len = entries.length;
  const commonBounds = C3.getCommonBounds(entries.map(({ bounds }) => bounds));
  const results = [];
  switch (type) {
    case "horizontal" /* Horizontal */: {
      const span = entries.reduce((a7, c5) => a7 + c5.bounds.width, 0);
      if (span > commonBounds.width) {
        const left = entries.sort((a7, b6) => a7.bounds.minX - b6.bounds.minX)[0];
        const right = entries.sort((a7, b6) => b6.bounds.maxX - a7.bounds.maxX)[0];
        const entriesToMove = entries.filter((a7) => a7 !== left && a7 !== right).sort((a7, b6) => a7.center[0] - b6.center[0]);
        const step = (right.center[0] - left.center[0]) / (len - 1);
        const x5 = left.center[0] + step;
        entriesToMove.forEach(({ id, point, bounds }, i4) => {
          results.push({
            id,
            prev: point,
            next: [x5 + step * i4 - bounds.width / 2, bounds.minY]
          });
        });
      } else {
        const entriesToMove = entries.sort((a7, b6) => a7.center[0] - b6.center[0]);
        let x5 = commonBounds.minX;
        const step = (commonBounds.width - span) / (len - 1);
        entriesToMove.forEach(({ id, point, bounds }) => {
          results.push({ id, prev: point, next: [x5, bounds.minY] });
          x5 += bounds.width + step;
        });
      }
      break;
    }
    case "vertical" /* Vertical */: {
      const span = entries.reduce((a7, c5) => a7 + c5.bounds.height, 0);
      if (span > commonBounds.height) {
        const top2 = entries.sort((a7, b6) => a7.bounds.minY - b6.bounds.minY)[0];
        const bottom = entries.sort((a7, b6) => b6.bounds.maxY - a7.bounds.maxY)[0];
        const entriesToMove = entries.filter((a7) => a7 !== top2 && a7 !== bottom).sort((a7, b6) => a7.center[1] - b6.center[1]);
        const step = (bottom.center[1] - top2.center[1]) / (len - 1);
        const y6 = top2.center[1] + step;
        entriesToMove.forEach(({ id, point, bounds }, i4) => {
          results.push({
            id,
            prev: point,
            next: [bounds.minX, y6 + step * i4 - bounds.height / 2]
          });
        });
      } else {
        const entriesToMove = entries.sort((a7, b6) => a7.center[1] - b6.center[1]);
        let y6 = commonBounds.minY;
        const step = (commonBounds.height - span) / (len - 1);
        entriesToMove.forEach(({ id, point, bounds }) => {
          results.push({ id, prev: point, next: [bounds.minX, y6] });
          y6 += bounds.height + step;
        });
      }
      break;
    }
  }
  return results;
}

// src/components/Tldraw/state/commands/duplicatePage/duplicatePage.ts
function duplicatePage(app, pageId) {
  const {
    currentPageId,
    pageState: { camera }
  } = app;
  const page = app.document.pages[pageId];
  const newId = C3.uniqueId();
  const nextPage = {
    ...page,
    id: newId,
    name: page.name + " Copy",
    shapes: Object.fromEntries(
      Object.entries(page.shapes).map(([id, shape]) => {
        return [
          id,
          {
            ...shape,
            parentId: shape.parentId === page.id ? newId : shape.parentId
          }
        ];
      })
    )
  };
  return {
    id: "duplicate_page",
    before: {
      appState: {
        currentPageId
      },
      document: {
        pages: {
          [newId]: void 0
        },
        pageStates: {
          [newId]: void 0
        }
      }
    },
    after: {
      appState: {
        currentPageId: newId
      },
      document: {
        pages: {
          [newId]: nextPage
        },
        pageStates: {
          [newId]: {
            ...page,
            id: newId,
            selectedIds: [],
            camera: { ...camera },
            editingId: void 0,
            bindingId: void 0,
            hoveredId: void 0,
            pointedId: void 0
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/duplicateShapes/duplicateShapes.ts
function duplicateShapes(app, ids, point) {
  const { selectedIds, currentPageId, page, shapes } = app;
  const before = {
    shapes: {},
    bindings: {}
  };
  const after = {
    shapes: {},
    bindings: {}
  };
  const duplicateMap = {};
  const shapesToDuplicate = ids.map((id) => app.getShape(id)).filter((shape) => !ids.includes(shape.parentId));
  shapesToDuplicate.forEach((shape) => {
    const duplicatedId = C3.uniqueId();
    before.shapes[duplicatedId] = void 0;
    after.shapes[duplicatedId] = {
      ...C3.deepClone(shape),
      id: duplicatedId,
      childIndex: TLDR.getChildIndexAbove(app.state, shape.id, currentPageId)
    };
    if (shape.children) {
      after.shapes[duplicatedId].children = [];
    }
    if (shape.parentId !== currentPageId) {
      const parent = app.getShape(shape.parentId);
      before.shapes[parent.id] = {
        ...before.shapes[parent.id],
        children: parent.children
      };
      after.shapes[parent.id] = {
        ...after.shapes[parent.id],
        children: [...(after.shapes[parent.id] || parent).children, duplicatedId]
      };
    }
    duplicateMap[shape.id] = duplicatedId;
  });
  shapesToDuplicate.forEach((shape) => {
    if (shape.children) {
      shape.children.forEach((childId) => {
        const child = app.getShape(childId);
        const duplicatedId = C3.uniqueId();
        const duplicatedParentId = duplicateMap[shape.id];
        before.shapes[duplicatedId] = void 0;
        after.shapes[duplicatedId] = {
          ...C3.deepClone(child),
          id: duplicatedId,
          parentId: duplicatedParentId,
          childIndex: TLDR.getChildIndexAbove(app.state, child.id, currentPageId)
        };
        duplicateMap[childId] = duplicatedId;
        after.shapes[duplicateMap[shape.id]]?.children?.push(duplicatedId);
      });
    }
  });
  const dupedShapeIds = new Set(Object.keys(duplicateMap));
  Object.values(page.bindings).filter((binding) => dupedShapeIds.has(binding.fromId) || dupedShapeIds.has(binding.toId)).forEach((binding) => {
    if (dupedShapeIds.has(binding.fromId)) {
      if (dupedShapeIds.has(binding.toId)) {
        const duplicatedBindingId = C3.uniqueId();
        const duplicatedBinding = {
          ...C3.deepClone(binding),
          id: duplicatedBindingId,
          fromId: duplicateMap[binding.fromId],
          toId: duplicateMap[binding.toId]
        };
        before.bindings[duplicatedBindingId] = void 0;
        after.bindings[duplicatedBindingId] = duplicatedBinding;
        const boundShape = after.shapes[duplicatedBinding.fromId];
        Object.values(boundShape.handles).forEach((handle) => {
          if (handle.bindingId === binding.id) {
            handle.bindingId = duplicatedBindingId;
          }
        });
      } else {
        const boundShape = after.shapes[duplicateMap[binding.fromId]];
        Object.values(boundShape.handles).forEach((handle) => {
          if (handle.bindingId === binding.id) {
            handle.bindingId = void 0;
          }
        });
      }
    }
  });
  const shapesToMove = Object.values(after.shapes);
  if (point) {
    const commonBounds = C3.getCommonBounds(shapesToMove.map((shape) => TLDR.getBounds(shape)));
    const center = C3.getBoundsCenter(commonBounds);
    shapesToMove.forEach((shape) => {
      if (!shape.point)
        return;
      shape.point = e.sub(point, e.sub(center, shape.point));
    });
  } else {
    const offset = [16, 16];
    shapesToMove.forEach((shape) => {
      if (!shape.point)
        return;
      shape.point = e.add(shape.point, offset);
    });
  }
  shapesToMove.forEach((shape) => {
    if (shape.isLocked) {
      shape.isLocked = false;
    }
  });
  return {
    id: "duplicate",
    before: {
      document: {
        pages: {
          [currentPageId]: before
        },
        pageStates: {
          [currentPageId]: { selectedIds }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: after
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: [...dupedShapeIds.values()].map((id) => duplicateMap[id])
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/flipShapes/flipShapes.ts
function flipShapes(app, ids, type) {
  const {
    selectedIds,
    currentPageId,
    page: { shapes }
  } = app;
  const boundsForShapes = ids.map((id) => TLDR.getBounds(shapes[id]));
  const isSinglySelectedGroup = ids.length === 1 && shapes[ids[0]].type === "group";
  const commonBounds = C3.getCommonBounds(boundsForShapes);
  const { before, after } = TLDR.mutateShapes(
    app.state,
    ids,
    (shape) => {
      const shapeBounds = TLDR.getBounds(shape);
      const isChildOfGroup = shape.parentId !== currentPageId;
      switch (type) {
        case "horizontal" /* Horizontal */: {
          if (isChildOfGroup && !isSinglySelectedGroup) {
            const groupBounds = TLDR.getBounds(shapes[shape.parentId]);
            const newGroupBounds = C3.getRelativeTransformedBoundingBox(commonBounds, commonBounds, groupBounds, true, false);
            const dx = newGroupBounds.minX - groupBounds.minX;
            return TLDR.getShapeUtil(shape).transform(
              shape,
              { ...shapeBounds, minX: shapeBounds.minX + dx, maxX: shapeBounds.maxX + dx },
              {
                type: He.TopLeft,
                scaleX: 1,
                scaleY: 1,
                initialShape: shape,
                transformOrigin: [0.5, 0.5]
              }
            );
          }
          const newShapeBounds = C3.getRelativeTransformedBoundingBox(commonBounds, commonBounds, shapeBounds, true, false);
          return TLDR.getShapeUtil(shape).transform(shape, newShapeBounds, {
            type: He.TopLeft,
            scaleX: -1,
            scaleY: 1,
            initialShape: shape,
            transformOrigin: [0.5, 0.5]
          });
        }
        case "vertical" /* Vertical */: {
          if (isChildOfGroup && !isSinglySelectedGroup) {
            const groupBounds = TLDR.getBounds(shapes[shape.parentId]);
            const newGroupBounds = C3.getRelativeTransformedBoundingBox(commonBounds, commonBounds, groupBounds, false, true);
            const dy = newGroupBounds.minY - groupBounds.minY;
            return TLDR.getShapeUtil(shape).transform(
              shape,
              { ...shapeBounds, minY: shapeBounds.minY + dy, maxY: shapeBounds.maxY + dy },
              {
                type: He.TopLeft,
                scaleX: 1,
                scaleY: 1,
                initialShape: shape,
                transformOrigin: [0.5, 0.5]
              }
            );
          }
          const newShapeBounds = C3.getRelativeTransformedBoundingBox(commonBounds, commonBounds, shapeBounds, false, true);
          return TLDR.getShapeUtil(shape).transform(shape, newShapeBounds, {
            type: He.TopLeft,
            scaleX: 1,
            scaleY: -1,
            initialShape: shape,
            transformOrigin: [0.5, 0.5]
          });
        }
      }
    },
    currentPageId,
    true
  );
  return {
    id: "flip",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/groupShapes/groupShapes.ts
function groupShapes(app, ids, groupId, pageId) {
  if (ids.length < 2)
    return;
  const beforeShapes = {};
  const afterShapes = {};
  const beforeBindings = {};
  const afterBindings = {};
  const idsToGroup = [...ids];
  const shapesToGroup = [];
  const deletedGroupIds = [];
  const otherEffectedGroups = [];
  for (const id of ids) {
    const shape = app.getShape(id);
    if (shape.isLocked)
      continue;
    if (shape.children === void 0) {
      shapesToGroup.push(shape);
    } else {
      const childIds = shape.children.filter((id2) => !app.getShape(id2).isLocked);
      otherEffectedGroups.push(shape);
      idsToGroup.push(...childIds);
      shapesToGroup.push(...childIds.map((id2) => app.getShape(id2)).filter(Boolean));
    }
  }
  if (shapesToGroup.every((shape) => shape.parentId === shapesToGroup[0].parentId) && // Is the common parent a shape (not the page)?
  shapesToGroup[0].parentId !== pageId) {
    const commonParent = app.getShape(shapesToGroup[0].parentId);
    if (commonParent.children?.length === idsToGroup.length) {
      return;
    }
  }
  const flattenedShapes = TLDR.flattenPage(app.state, pageId);
  const shapeIndexMap = Object.fromEntries(shapesToGroup.map((shape) => [shape.id, flattenedShapes.indexOf(shape)]));
  const sortedShapes = shapesToGroup.sort((a7, b6) => shapeIndexMap[a7.id] - shapeIndexMap[b6.id]);
  const groupParentId = pageId;
  const groupChildIndex = (sortedShapes.find((shape) => shape.parentId === pageId) || sortedShapes[0]).childIndex;
  const groupBounds = C3.getCommonBounds(shapesToGroup.map((shape) => TLDR.getBounds(shape)));
  beforeShapes[groupId] = void 0;
  afterShapes[groupId] = TLDR.getShapeUtil("group" /* Group */).create({
    id: groupId,
    childIndex: groupChildIndex,
    parentId: groupParentId,
    point: [groupBounds.minX, groupBounds.minY],
    size: [groupBounds.width, groupBounds.height],
    children: sortedShapes.map((shape) => shape.id)
  });
  sortedShapes.forEach((shape, index2) => {
    if (shape.parentId !== pageId) {
      const parentShape = app.getShape(shape.parentId);
      otherEffectedGroups.push(parentShape);
    }
    beforeShapes[shape.id] = {
      ...beforeShapes[shape.id],
      parentId: shape.parentId,
      childIndex: shape.childIndex
    };
    afterShapes[shape.id] = {
      ...afterShapes[shape.id],
      parentId: groupId,
      childIndex: index2 + 1
    };
  });
  while (otherEffectedGroups.length > 0) {
    const shape = otherEffectedGroups.pop();
    if (!shape)
      break;
    const nextChildren = (beforeShapes[shape.id]?.children || shape.children).filter(
      (childId) => childId && !(idsToGroup.includes(childId) || deletedGroupIds.includes(childId))
    );
    if (nextChildren.length === 0) {
      beforeShapes[shape.id] = shape;
      afterShapes[shape.id] = void 0;
      if (shape.parentId !== pageId) {
        deletedGroupIds.push(shape.id);
        otherEffectedGroups.push(app.getShape(shape.parentId));
      }
    } else {
      beforeShapes[shape.id] = {
        ...beforeShapes[shape.id],
        children: shape.children
      };
      afterShapes[shape.id] = {
        ...afterShapes[shape.id],
        children: nextChildren
      };
    }
  }
  const { bindings } = app;
  const deletedGroupIdsSet = new Set(deletedGroupIds);
  bindings.forEach((binding) => {
    for (const id of [binding.toId, binding.fromId]) {
      if (deletedGroupIdsSet.has(id)) {
        beforeBindings[binding.id] = binding;
        afterBindings[binding.id] = void 0;
        const shape = app.getShape(id);
        if (shape.handles) {
          Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {
            beforeShapes[id] = {
              ...beforeShapes[id],
              handles: {
                ...beforeShapes[id]?.handles,
                [handle.id]: { bindingId: binding.id }
              }
            };
            if (!deletedGroupIds.includes(id)) {
              afterShapes[id] = {
                ...afterShapes[id],
                handles: {
                  ...afterShapes[id]?.handles,
                  [handle.id]: { bindingId: void 0 }
                }
              };
            }
          });
        }
      }
    }
  });
  return {
    id: "group",
    before: {
      document: {
        pages: {
          [pageId]: {
            shapes: beforeShapes,
            bindings: beforeBindings
          }
        },
        pageStates: {
          [pageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [pageId]: {
            shapes: afterShapes,
            bindings: beforeBindings
          }
        },
        pageStates: {
          [pageId]: {
            selectedIds: [groupId]
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/moveShapesToPage/moveShapesToPage.ts
function moveShapesToPage(app, ids, viewportBounds, fromPageId, toPageId) {
  const { page } = app;
  const fromPage = {
    before: {
      shapes: {},
      bindings: {}
    },
    after: {
      shapes: {},
      bindings: {}
    }
  };
  const toPage = {
    before: {
      shapes: {},
      bindings: {}
    },
    after: {
      shapes: {},
      bindings: {}
    }
  };
  const movingShapeIds = /* @__PURE__ */ new Set();
  const shapesToMove = /* @__PURE__ */ new Set();
  ids.map((id) => app.getShape(id, fromPageId)).filter((shape) => !shape.isLocked).forEach((shape) => {
    movingShapeIds.add(shape.id);
    shapesToMove.add(shape);
    if (shape.children !== void 0) {
      shape.children.forEach((childId) => {
        movingShapeIds.add(childId);
        shapesToMove.add(app.getShape(childId, fromPageId));
      });
    }
  });
  const startingChildIndex = TLDR.getTopChildIndex(app.state, toPageId);
  const movingShapes = [...shapesToMove.values()];
  movingShapes.forEach((shape, i4) => {
    fromPage.before.shapes[shape.id] = shape;
    fromPage.after.shapes[shape.id] = void 0;
    toPage.before.shapes[shape.id] = void 0;
    toPage.after.shapes[shape.id] = shape;
    if (!movingShapeIds.has(shape.parentId)) {
      toPage.after.shapes[shape.id] = {
        ...shape,
        parentId: toPageId,
        childIndex: startingChildIndex + i4
      };
      if (shape.parentId !== fromPageId) {
        const parent = app.getShape(shape.parentId, fromPageId);
        fromPage.before.shapes[parent.id] = {
          children: parent.children
        };
        fromPage.after.shapes[parent.id] = {
          children: parent.children.filter((childId) => childId !== shape.id)
        };
      }
    }
  });
  Object.values(page.bindings).filter((binding) => movingShapeIds.has(binding.fromId) || movingShapeIds.has(binding.toId)).forEach((binding) => {
    fromPage.before.bindings[binding.id] = binding;
    fromPage.after.bindings[binding.id] = void 0;
    const fromBoundShape = app.getShape(binding.fromId, fromPageId);
    const shouldCopy = movingShapeIds.has(binding.fromId) && movingShapeIds.has(binding.toId);
    if (shouldCopy) {
      toPage.before.bindings[binding.id] = void 0;
      toPage.after.bindings[binding.id] = binding;
    } else {
      if (movingShapeIds.has(binding.fromId)) {
        const fromShape = app.getShape(binding.fromId, fromPageId);
        const handle = Object.values(fromBoundShape.handles).find((handle2) => handle2.bindingId === binding.id);
        const handleId = handle.id;
        const toPageShape = toPage.after.shapes[fromShape.id];
        toPageShape.handles = {
          ...toPageShape.handles,
          [handleId]: {
            ...toPageShape.handles[handleId],
            bindingId: void 0
          }
        };
      } else {
        const fromShape = app.getShape(binding.fromId, fromPageId);
        const handle = Object.values(fromBoundShape.handles).find((handle2) => handle2.bindingId === binding.id);
        fromPage.before.shapes[fromShape.id] = {
          handles: { [handle.id]: { bindingId: binding.id } }
        };
        fromPage.after.shapes[fromShape.id] = {
          handles: { [handle.id]: { bindingId: void 0 } }
        };
      }
    }
  });
  const toPageState = app.state.document.pageStates[toPageId];
  const bounds = C3.getCommonBounds(movingShapes.map((shape) => TLDR.getBounds(shape)));
  const zoom = TLDR.getCameraZoom(
    viewportBounds.width < viewportBounds.height ? (viewportBounds.width - 128) / bounds.width : (viewportBounds.height - 128) / bounds.height
  );
  const mx = (viewportBounds.width - bounds.width * zoom) / 2 / zoom;
  const my = (viewportBounds.height - bounds.height * zoom) / 2 / zoom;
  const point = e.toFixed(e.add([-bounds.minX, -bounds.minY], [mx, my]));
  return {
    id: "move_to_page",
    before: {
      appState: {
        currentPageId: fromPageId
      },
      document: {
        pages: {
          [fromPageId]: fromPage.before,
          [toPageId]: toPage.before
        },
        pageStates: {
          [fromPageId]: { selectedIds: ids },
          [toPageId]: {
            selectedIds: toPageState.selectedIds,
            camera: toPageState.camera
          }
        }
      }
    },
    after: {
      appState: {
        currentPageId: toPageId
      },
      document: {
        pages: {
          [fromPageId]: fromPage.after,
          [toPageId]: toPage.after
        },
        pageStates: {
          [fromPageId]: { selectedIds: [] },
          [toPageId]: {
            selectedIds: ids,
            camera: {
              zoom,
              point
            }
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/movePage/movePage.ts
function movePage(app, pageId, index2) {
  const { pages } = app.document;
  const movingPage = pages[pageId];
  const beforePages = Object.values(pages).sort((a7, b6) => (a7.childIndex ?? 0) - (b6.childIndex ?? 0));
  const fromIndex = beforePages.indexOf(movingPage);
  const afterPages = [...beforePages];
  afterPages.splice(fromIndex, 1);
  afterPages.splice(index2 > fromIndex ? index2 - 1 : index2, 0, movingPage);
  return {
    id: "move_page",
    before: {
      document: {
        pages: Object.fromEntries(beforePages.map((p6) => [p6.id, { childIndex: p6.childIndex }]))
      }
    },
    after: {
      document: {
        pages: Object.fromEntries(afterPages.map((p6, childIndex) => [p6.id, { childIndex }]))
      }
    }
  };
}

// src/components/Tldraw/state/commands/reorderShapes/reorderShapes.ts
function reorderShapes(app, ids, type) {
  const { currentPageId, page } = app;
  const parentIds = new Set(ids.map((id) => app.getShape(id).parentId));
  let result = { before: {}, after: {} };
  let startIndex;
  let startChildIndex;
  let step;
  [...parentIds.values()].forEach((parentId) => {
    let sortedChildren = [];
    if (parentId === page.id) {
      sortedChildren = Object.values(page.shapes).sort((a7, b6) => a7.childIndex - b6.childIndex);
    } else {
      const parent = app.getShape(parentId);
      if (!parent.children)
        throw new Error("No children in parent!");
      sortedChildren = parent.children.map((childId) => app.getShape(childId)).sort((a7, b6) => a7.childIndex - b6.childIndex);
    }
    const sortedChildIds = sortedChildren.map((shape) => shape.id);
    const sortedIndicesToMove = ids.filter((id) => sortedChildIds.includes(id)).map((id) => sortedChildIds.indexOf(id)).sort((a7, b6) => a7 - b6);
    if (sortedIndicesToMove.length === sortedChildIds.length)
      return;
    switch (type) {
      case "toBack" /* ToBack */: {
        for (let i4 = 0; i4 < sortedChildIds.length; i4++) {
          if (sortedIndicesToMove.includes(i4))
            continue;
          startIndex = i4;
          break;
        }
        startChildIndex = sortedChildren[startIndex].childIndex;
        step = startChildIndex / (sortedIndicesToMove.length + 1);
        result = TLDR.mutateShapes(
          app.state,
          sortedIndicesToMove.map((i4) => sortedChildren[i4].id).reverse(),
          (_shape, i4) => ({
            childIndex: startChildIndex - (i4 + 1) * step
          }),
          currentPageId
        );
        break;
      }
      case "toFront" /* ToFront */: {
        for (let i4 = sortedChildIds.length - 1; i4 >= 0; i4--) {
          if (sortedIndicesToMove.includes(i4))
            continue;
          startIndex = i4;
          break;
        }
        startChildIndex = sortedChildren[startIndex].childIndex;
        step = 1;
        result = TLDR.mutateShapes(
          app.state,
          sortedIndicesToMove.map((i4) => sortedChildren[i4].id),
          (_shape, i4) => ({
            childIndex: startChildIndex + (i4 + 1)
          }),
          currentPageId
        );
        break;
      }
      case "backward" /* Backward */: {
        const indexMap = {};
        for (let i4 = sortedChildIds.length - 1; i4 >= 0; i4--) {
          if (sortedIndicesToMove.includes(i4)) {
            for (let j4 = i4; j4 >= 0; j4--) {
              if (!sortedIndicesToMove.includes(j4)) {
                const endChildIndex = sortedChildren[j4].childIndex;
                let startChildIndex2;
                let step2;
                if (j4 === 0) {
                  startChildIndex2 = endChildIndex / 2;
                  step2 = endChildIndex / 2 / (i4 - j4 + 1);
                } else {
                  startChildIndex2 = sortedChildren[j4 - 1].childIndex;
                  step2 = (endChildIndex - startChildIndex2) / (i4 - j4 + 1);
                  startChildIndex2 += step2;
                }
                for (let k7 = 0; k7 < i4 - j4; k7++) {
                  indexMap[sortedChildren[j4 + k7 + 1].id] = startChildIndex2 + step2 * k7;
                }
                break;
              }
            }
          }
        }
        if (Object.values(indexMap).length > 0) {
          result = TLDR.mutateShapes(
            app.state,
            sortedIndicesToMove.map((i4) => sortedChildren[i4].id),
            (shape) => ({
              childIndex: indexMap[shape.id]
            }),
            currentPageId
          );
        }
        break;
      }
      case "forward" /* Forward */: {
        const indexMap = {};
        for (let i4 = 0; i4 < sortedChildIds.length; i4++) {
          if (sortedIndicesToMove.includes(i4)) {
            for (let j4 = i4; j4 < sortedChildIds.length; j4++) {
              if (!sortedIndicesToMove.includes(j4)) {
                startChildIndex = sortedChildren[j4].childIndex;
                const step2 = j4 === sortedChildIds.length - 1 ? 1 : (sortedChildren[j4 + 1].childIndex - startChildIndex) / (j4 - i4 + 1);
                for (let k7 = 0; k7 < j4 - i4; k7++) {
                  indexMap[sortedChildren[i4 + k7].id] = startChildIndex + step2 * (k7 + 1);
                }
                break;
              }
            }
          }
        }
        if (Object.values(indexMap).length > 0) {
          result = TLDR.mutateShapes(
            app.state,
            sortedIndicesToMove.map((i4) => sortedChildren[i4].id),
            (shape) => ({
              childIndex: indexMap[shape.id]
            }),
            currentPageId
          );
        }
        break;
      }
    }
  });
  return {
    id: "move",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: result.before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: result.after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/renamePage/renamePage.ts
function renamePage(app, pageId, name) {
  const { page } = app;
  return {
    id: "rename_page",
    before: {
      document: {
        pages: {
          [pageId]: { name: page.name }
        }
      }
    },
    after: {
      document: {
        pages: {
          [pageId]: { name }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/resetBounds/resetBounds.ts
function resetBounds(app, ids, pageId) {
  const { currentPageId } = app;
  const { before, after } = TLDR.mutateShapes(app.state, ids, (shape) => app.getShapeUtil(shape).onDoubleClickBoundsHandle?.(shape), pageId);
  return {
    id: "reset_bounds",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/rotateShapes/rotateShapes.ts
var PI23 = Math.PI * 2;
function rotateShapes(app, ids, delta = -PI23 / 4) {
  const { currentPageId } = app;
  const before = {};
  const after = {};
  const shapesToRotate = ids.flatMap((id) => {
    const shape = app.getShape(id);
    return shape.children ? shape.children.map((childId) => app.getShape(childId)) : shape;
  }).filter((shape) => !shape.isLocked);
  const origin = C3.getBoundsCenter(C3.getCommonBounds(shapesToRotate.map((shape) => TLDR.getBounds(shape))));
  shapesToRotate.forEach((shape) => {
    const change = TLDR.getRotatedShapeMutation(shape, TLDR.getCenter(shape), origin, delta);
    if (!change)
      return;
    before[shape.id] = TLDR.getBeforeShape(shape, change);
    after[shape.id] = change;
  });
  return {
    id: "rotate",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/stretchShapes/stretchShapes.ts
function stretchShapes(app, ids, type) {
  const { currentPageId, selectedIds } = app;
  const initialShapes = ids.map((id) => app.getShape(id));
  const boundsForShapes = initialShapes.map((shape) => TLDR.getBounds(shape));
  const commonBounds = C3.getCommonBounds(boundsForShapes);
  const idsToMutate = ids.flatMap((id) => {
    const shape = app.getShape(id);
    return shape.children ? shape.children : shape.id;
  }).filter((id) => !app.getShape(id).isLocked);
  const { before, after } = TLDR.mutateShapes(
    app.state,
    idsToMutate,
    (shape) => {
      const bounds = TLDR.getBounds(shape);
      switch (type) {
        case "horizontal" /* Horizontal */: {
          const newBounds = {
            ...bounds,
            minX: commonBounds.minX,
            maxX: commonBounds.maxX,
            width: commonBounds.width
          };
          return TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {
            type: He.TopLeft,
            scaleX: newBounds.width / bounds.width,
            scaleY: 1,
            initialShape: shape,
            transformOrigin: [0.5, 0.5]
          });
        }
        case "vertical" /* Vertical */: {
          const newBounds = {
            ...bounds,
            minY: commonBounds.minY,
            maxY: commonBounds.maxY,
            height: commonBounds.height
          };
          return TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {
            type: He.TopLeft,
            scaleX: 1,
            scaleY: newBounds.height / bounds.height,
            initialShape: shape,
            transformOrigin: [0.5, 0.5]
          });
        }
      }
    },
    currentPageId
  );
  initialShapes.forEach((shape) => {
    if (shape.type === "group" /* Group */) {
      delete before[shape.id];
      delete after[shape.id];
    }
  });
  return {
    id: "stretch",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/styleShapes/styleShapes.ts
function styleShapes(app, ids, changes) {
  const { currentPageId, selectedIds } = app;
  const shapeIdsToMutate = ids.flatMap((id) => TLDR.getDocumentBranch(app.state, id, currentPageId)).filter((id) => !app.getShape(id).isLocked);
  const beforeShapes = {};
  const afterShapes = {};
  shapeIdsToMutate.map((id) => app.getShape(id)).filter((shape) => !shape.isLocked).forEach((shape) => {
    beforeShapes[shape.id] = {
      style: {
        ...Object.fromEntries(Object.keys(changes).map((key) => [key, shape.style[key]]))
      }
    };
    afterShapes[shape.id] = {
      style: changes
    };
    if (shape.type === "text" /* Text */) {
      beforeShapes[shape.id].point = shape.point;
      afterShapes[shape.id].point = e.toFixed(
        e.add(
          shape.point,
          e.sub(
            app.getShapeUtil(shape).getCenter(shape),
            app.getShapeUtil(shape).getCenter({
              ...shape,
              style: { ...shape.style, ...changes }
            })
          )
        )
      );
    }
  });
  return {
    id: "style",
    before: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: beforeShapes
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      },
      appState: {
        currentStyle: { ...app.appState.currentStyle }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: afterShapes
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      },
      appState: {
        currentStyle: changes
      }
    }
  };
}

// src/components/Tldraw/state/commands/toggleShapesDecoration/toggleShapesDecoration.ts
function toggleShapesDecoration(app, ids, decorationId) {
  const { currentPageId, selectedIds } = app;
  const beforeShapes = Object.fromEntries(
    ids.map((id) => [
      id,
      {
        decorations: {
          [decorationId]: app.getShape(id).decorations?.[decorationId]
        }
      }
    ])
  );
  const afterShapes = Object.fromEntries(
    ids.filter((id) => !app.getShape(id).isLocked).map((id) => [
      id,
      {
        decorations: {
          [decorationId]: app.getShape(id).decorations?.[decorationId] ? void 0 : "arrow" /* Arrow */
        }
      }
    ])
  );
  return {
    id: "toggle_decorations",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: beforeShapes }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: afterShapes }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/toggleShapesProp/toggleShapesProp.ts
function toggleShapeProp(app, ids, prop) {
  const { currentPageId } = app;
  const initialShapes = ids.map((id) => app.getShape(id)).filter((shape) => prop === "isLocked" ? true : !shape.isLocked);
  const isAllToggled = initialShapes.every((shape) => shape[prop]);
  const before = {};
  const after = {};
  initialShapes.forEach((shape) => {
    before[shape.id] = { [prop]: shape[prop] };
    after[shape.id] = { [prop]: !isAllToggled };
  });
  return {
    id: "toggle",
    before: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: before
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: after
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/translateShapes/translateShapes.ts
function translateShapes(app, ids, delta) {
  const { currentPageId, selectedIds } = app;
  app.rotationInfo.selectedIds = [...selectedIds];
  const before = {
    shapes: {},
    bindings: {}
  };
  const after = {
    shapes: {},
    bindings: {}
  };
  const idsToMutate = ids.flatMap((id) => {
    const shape = app.getShape(id);
    return shape.children ? shape.children : shape.id;
  }).filter((id) => !app.getShape(id).isLocked);
  const change = TLDR.mutateShapes(
    app.state,
    idsToMutate,
    (shape) => ({
      point: e.toFixed(e.add(shape.point, delta))
    }),
    currentPageId
  );
  before.shapes = change.before;
  after.shapes = change.after;
  const bindingsToDelete = TLDR.getBindings(app.state, currentPageId).filter((binding) => ids.includes(binding.fromId) && !ids.includes(binding.toId));
  bindingsToDelete.forEach((binding) => {
    before.bindings[binding.id] = binding;
    after.bindings[binding.id] = void 0;
    for (const id of [binding.toId, binding.fromId]) {
      const shape = app.getShape(id);
      if (!shape.handles)
        continue;
      Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {
        before.shapes[id] = {
          ...before.shapes[id],
          handles: {
            ...before.shapes[id]?.handles,
            [handle.id]: { bindingId: binding.id }
          }
        };
        after.shapes[id] = {
          ...after.shapes[id],
          handles: { ...after.shapes[id]?.handles, [handle.id]: { bindingId: void 0 } }
        };
      });
    }
  });
  return {
    id: "translate",
    before: {
      document: {
        pages: {
          [currentPageId]: before
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: after
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/ungroupShapes/ungroupShapes.ts
function ungroupShapes(app, selectedIds, groupShapes2, pageId) {
  const { bindings } = app;
  const beforeShapes = {};
  const afterShapes = {};
  const beforeBindings = {};
  const afterBindings = {};
  const beforeSelectedIds = selectedIds;
  const afterSelectedIds = selectedIds.filter((id) => !groupShapes2.find((shape) => shape.id === id));
  groupShapes2.filter((shape) => !shape.isLocked).forEach((groupShape) => {
    const shapesToReparent = [];
    const deletedGroupIds = [];
    beforeShapes[groupShape.id] = groupShape;
    afterShapes[groupShape.id] = void 0;
    groupShape.children.forEach((id) => {
      afterSelectedIds.push(id);
      const shape = app.getShape(id, pageId);
      shapesToReparent.push(shape);
    });
    const startingChildIndex = groupShape.childIndex;
    const endingChildIndex = TLDR.getChildIndexAbove(app.state, groupShape.id, pageId);
    const step = (endingChildIndex - startingChildIndex) / shapesToReparent.length;
    const sortedShapes = shapesToReparent.sort((a7, b6) => a7.childIndex - b6.childIndex);
    sortedShapes.forEach((shape, index2) => {
      beforeShapes[shape.id] = {
        parentId: shape.parentId,
        childIndex: shape.childIndex
      };
      afterShapes[shape.id] = {
        parentId: pageId,
        childIndex: startingChildIndex + step * index2
      };
    });
    bindings.filter((binding) => binding.toId === groupShape.id || binding.fromId === groupShape.id).forEach((binding) => {
      for (const id of [binding.toId, binding.fromId]) {
        if (afterShapes[id] === void 0) {
          beforeBindings[binding.id] = binding;
          afterBindings[binding.id] = void 0;
          const shape = app.getShape(id, pageId);
          if (shape.handles) {
            Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {
              beforeShapes[id] = {
                ...beforeShapes[id],
                handles: {
                  ...beforeShapes[id]?.handles,
                  [handle.id]: { bindingId: binding.id }
                }
              };
              if (!deletedGroupIds.includes(id)) {
                afterShapes[id] = {
                  ...afterShapes[id],
                  handles: {
                    ...afterShapes[id]?.handles,
                    [handle.id]: { bindingId: void 0 }
                  }
                };
              }
            });
          }
        }
      }
    });
  });
  return {
    id: "ungroup",
    before: {
      document: {
        pages: {
          [pageId]: {
            shapes: beforeShapes,
            bindings: beforeBindings
          }
        },
        pageStates: {
          [pageId]: {
            selectedIds: beforeSelectedIds
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [pageId]: {
            shapes: afterShapes,
            bindings: beforeBindings
          }
        },
        pageStates: {
          [pageId]: {
            selectedIds: afterSelectedIds
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/updateShapes/updateShapes.ts
function updateShapes(app, updates, pageId) {
  const ids = updates.map((update) => update.id);
  const change = TLDR.mutateShapes(
    app.state,
    ids.filter((id) => !app.getShape(id, pageId).isLocked),
    (_shape, i4) => updates[i4],
    pageId
  );
  return {
    id: "update",
    before: {
      document: {
        pages: {
          [pageId]: {
            shapes: change.before
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [pageId]: {
            shapes: change.after
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/setShapesProps/setShapesProps.ts
function setShapesProps(app, ids, partial) {
  const { currentPageId, selectedIds } = app;
  const initialShapes = ids.map((id) => app.getShape(id)).filter((shape) => partial.isLocked ? true : !shape.isLocked);
  const before = {};
  const after = {};
  const keys = Object.keys(partial);
  initialShapes.forEach((shape) => {
    before[shape.id] = Object.fromEntries(keys.map((key) => [key, shape[key]]));
    after[shape.id] = partial;
  });
  return {
    id: "set_props",
    before: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: before
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: after
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/commands/insertContent/insertContent.ts
function insertContent(app, content, opts = {}) {
  const { currentPageId } = app;
  const { point, select, overwrite } = opts;
  const page = app.document.pages[currentPageId];
  const before = {
    shapes: {},
    bindings: {}
  };
  const afterAssets = {};
  const after = {
    shapes: {},
    bindings: {}
  };
  if (overwrite) {
    for (const shape of content.shapes) {
      before.shapes[shape.id] = page.shapes[shape.id];
      after.shapes[shape.id] = shape;
    }
    if (content.bindings) {
      for (const binding of content.bindings) {
        before.bindings[binding.id] = page.bindings[binding.id];
        after.bindings[binding.id] = binding;
      }
    }
    if (content.assets) {
      for (const asset of content.assets) {
        afterAssets[asset.id] = asset;
      }
    }
  } else {
    const oldToNewIds = {};
    let nextIndex = TLDR.getTopChildIndex(app.state, currentPageId);
    const shapesToInsert = content.shapes.sort((a7, b6) => a7.childIndex - b6.childIndex).map((shape) => {
      const newShapeId = C3.uniqueId();
      oldToNewIds[shape.id] = newShapeId;
      return {
        ...C3.deepClone(shape),
        id: newShapeId
      };
    });
    const visited = /* @__PURE__ */ new Set();
    while (shapesToInsert.length > 0) {
      const shape = shapesToInsert.shift();
      if (!shape)
        break;
      visited.add(shape.id);
      if (shape.parentId === "currentPageId") {
        shape.parentId = currentPageId;
        shape.childIndex = nextIndex++;
      } else {
        shape.parentId = oldToNewIds[shape.parentId];
        const parent = after.shapes[shape.parentId];
        if (!parent) {
          if (visited.has(shape.id)) {
            shape.parentId = "currentPageId";
          }
          shapesToInsert.push(shape);
          continue;
        }
        parent.children.push(shape.id);
      }
      if (shape.children) {
        shape.children = [];
      }
      before.shapes[shape.id] = void 0;
      after.shapes[shape.id] = shape;
    }
    Object.values(after.shapes).forEach((shape) => {
      if (shape.children && shape.children.length === 0) {
        delete before.shapes[shape.id];
        delete after.shapes[shape.id];
      }
    });
    if (content.bindings) {
      content.bindings.forEach((binding) => {
        const newBindingId = C3.uniqueId();
        oldToNewIds[binding.id] = newBindingId;
        const toId = oldToNewIds[binding.toId];
        const fromId = oldToNewIds[binding.fromId];
        if (!toId || !fromId) {
          if (fromId) {
            const handles = after.shapes[fromId].handles;
            if (handles) {
              Object.values(handles).forEach((handle) => {
                if (handle.bindingId === binding.id) {
                  handle.bindingId = void 0;
                }
              });
            }
          }
          if (toId) {
            const handles = after.shapes[toId].handles;
            if (handles) {
              Object.values(handles).forEach((handle) => {
                if (handle.bindingId === binding.id) {
                  handle.bindingId = void 0;
                }
              });
            }
          }
          return;
        }
        const fromHandles = after.shapes[fromId].handles;
        if (fromHandles) {
          Object.values(fromHandles).forEach((handle) => {
            if (handle.bindingId === binding.id) {
              handle.bindingId = newBindingId;
            }
          });
        }
        const toHandles = after.shapes[toId].handles;
        if (toHandles) {
          Object.values(after.shapes[toId].handles).forEach((handle) => {
            if (handle.bindingId === binding.id) {
              handle.bindingId = newBindingId;
            }
          });
        }
        const newBinding = {
          ...C3.deepClone(binding),
          id: newBindingId,
          toId,
          fromId
        };
        before.bindings[newBinding.id] = void 0;
        after.bindings[newBinding.id] = newBinding;
      });
    }
    const shapesToMove = Object.values(after.shapes);
    if (shapesToMove.length > 0) {
      if (point) {
        const commonBounds = C3.getCommonBounds(shapesToMove.map((shape) => TLDR.getBounds(shape)));
        const center = C3.getBoundsCenter(commonBounds);
        shapesToMove.forEach((shape) => {
          if (!shape.point)
            return;
          shape.point = e.sub(point, e.sub(center, shape.point));
        });
      } else {
        const commonBounds = C3.getCommonBounds(shapesToMove.map(TLDR.getBounds));
        if (!(C3.boundsContain(app.viewport, commonBounds) || C3.boundsCollide(app.viewport, commonBounds))) {
          const center = e.toFixed(app.getPagePoint(app.centerPoint));
          const centeredBounds = C3.centerBounds(commonBounds, center);
          const delta = e.sub(C3.getBoundsCenter(centeredBounds), C3.getBoundsCenter(commonBounds));
          shapesToMove.forEach((shape) => {
            shape.point = e.toFixed(e.add(shape.point, delta));
          });
        }
      }
    }
    if (content.assets) {
      for (const asset of content.assets) {
        afterAssets[asset.id] = asset;
      }
    }
  }
  const elm = document.createElement("textarea");
  Object.values(after.shapes).forEach((shape) => {
    if ("text" in shape) {
      elm.innerHTML = shape.text;
      shape.text = elm.value;
    }
    if ("label" in shape) {
      elm.innerHTML = shape.label;
      shape.label = elm.value;
    }
  });
  elm.remove();
  return {
    id: "insert",
    before: {
      document: {
        pages: {
          [currentPageId]: before
        },
        pageStates: {
          [currentPageId]: { selectedIds: [...app.selectedIds] }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: after
        },
        assets: afterAssets,
        pageStates: {
          [currentPageId]: {
            selectedIds: select ? Object.keys(after.shapes) : [...app.selectedIds]
          }
        }
      }
    }
  };
}

// src/components/Tldraw/state/data/migrate.ts
function migrate(state, newVersion) {
  const { document: document2, settings } = state;
  const { version = 0 } = document2;
  if (!("assets" in document2)) {
    document2.assets = {};
  }
  const assetIdsInUse = /* @__PURE__ */ new Set();
  Object.values(document2.pages).forEach(
    (page) => Object.values(page.shapes).forEach((shape) => {
      const { parentId, children, assetId } = shape;
      if (assetId) {
        assetIdsInUse.add(assetId);
      }
      if (parentId !== page.id && !page.shapes[parentId]) {
        console.warn("Encountered a shape with a missing parent!");
        shape.parentId = page.id;
      }
      if (shape.type === "group" /* Group */ && children) {
        children.forEach((childId) => {
          if (!page.shapes[childId]) {
            console.warn("Encountered a parent with a missing child!", shape.id, childId);
            children?.splice(children.indexOf(childId), 1);
          }
        });
      }
    })
  );
  Object.keys(document2.assets).forEach((assetId) => {
    if (!assetIdsInUse.has(assetId)) {
      delete document2.assets[assetId];
    }
  });
  if (version !== newVersion) {
    if (version < 14) {
      Object.values(document2.pages).forEach((page) => {
        Object.values(page.shapes).filter((shape) => shape.type === "text" /* Text */).forEach((shape) => shape.style.font === "script" /* Script */);
      });
    }
    if (version <= 13) {
      Object.values(document2.pages).forEach((page) => {
        Object.values(page.bindings).forEach((binding) => {
          Object.assign(binding, binding.meta);
        });
        Object.values(page.shapes).forEach((shape) => {
          Object.entries(shape.style).forEach(([id, style]) => {
            if (typeof style === "string") {
              shape.style[id] = style.toLowerCase();
            }
          });
          if (shape.type === "arrow" /* Arrow */ && shape.decorations) {
            Object.entries(shape.decorations).forEach(([id, decoration]) => {
              if (decoration === "Arrow") {
                shape.decorations = {
                  ...shape.decorations,
                  [id]: "arrow" /* Arrow */
                };
              }
            });
          }
        });
      });
    }
    if (version <= 13.1) {
      document2.name = "New Document";
    }
    if (version < 15) {
      document2.assets = {};
    }
    Object.values(document2.pages).forEach((page) => {
      Object.values(page.shapes).forEach((shape) => {
        if (version < 15.2 && shape.type === "image" /* Image */) {
          shape.style.isFilled = true;
        }
        if (version < 15.3 && (shape.type === "rectangle" /* Rectangle */ || shape.type === "triangle" /* Triangle */ || shape.type === "ellipse" /* Ellipse */ || shape.type === "arrow" /* Arrow */)) {
          shape.label = shape.text || "";
          shape.labelPoint = [0.5, 0.5];
        }
      });
    });
    if (version < 15.4) {
      settings.dockPosition = "bottom";
    }
    if (version < 15.5) {
      settings.exportBackground = "transparent" /* Transparent */;
    }
  }
  Object.values(document2.pageStates).forEach((pageState) => {
    pageState.selectedIds = pageState.selectedIds.filter((id) => {
      return document2.pages[pageState.id].shapes[id] !== void 0;
    });
    pageState.bindingId = void 0;
    pageState.editingId = void 0;
    pageState.hoveredId = void 0;
    pageState.pointedId = void 0;
  });
  document2.version = newVersion;
  return state;
}

// node_modules/.pnpm/browser-fs-access@0.34.1/node_modules/browser-fs-access/dist/index.modern.js
var e4 = (() => {
  if ("undefined" == typeof self)
    return false;
  if ("top" in self && self !== top)
    try {
      top;
    } catch (e5) {
      return false;
    }
  return "showOpenFilePicker" in self;
})();
var t4 = e4 ? Promise.resolve().then(function() {
  return l6;
}) : Promise.resolve().then(function() {
  return v5;
});
async function n4(...e5) {
  return (await t4).default(...e5);
}
var r4 = e4 ? Promise.resolve().then(function() {
  return y5;
}) : Promise.resolve().then(function() {
  return b5;
});
var a6 = e4 ? Promise.resolve().then(function() {
  return m5;
}) : Promise.resolve().then(function() {
  return k6;
});
var s4 = async (e5) => {
  const t5 = await e5.getFile();
  return t5.handle = e5, t5;
};
var c4 = async (e5 = [{}]) => {
  Array.isArray(e5) || (e5 = [e5]);
  const t5 = [];
  e5.forEach((e6, n6) => {
    t5[n6] = { description: e6.description || "Files", accept: {} }, e6.mimeTypes ? e6.mimeTypes.map((r6) => {
      t5[n6].accept[r6] = e6.extensions || [];
    }) : t5[n6].accept["*/*"] = e6.extensions || [];
  });
  const n5 = await window.showOpenFilePicker({ id: e5[0].id, startIn: e5[0].startIn, types: t5, multiple: e5[0].multiple || false, excludeAcceptAllOption: e5[0].excludeAcceptAllOption || false }), r5 = await Promise.all(n5.map(s4));
  return e5[0].multiple ? r5 : r5[0];
};
var l6 = { __proto__: null, default: c4 };
function u4(e5) {
  function t5(e6) {
    if (Object(e6) !== e6)
      return Promise.reject(new TypeError(e6 + " is not an object."));
    var t6 = e6.done;
    return Promise.resolve(e6.value).then(function(e7) {
      return { value: e7, done: t6 };
    });
  }
  return u4 = function(e6) {
    this.s = e6, this.n = e6.next;
  }, u4.prototype = { s: null, n: null, next: function() {
    return t5(this.n.apply(this.s, arguments));
  }, return: function(e6) {
    var n5 = this.s.return;
    return void 0 === n5 ? Promise.resolve({ value: e6, done: true }) : t5(n5.apply(this.s, arguments));
  }, throw: function(e6) {
    var n5 = this.s.return;
    return void 0 === n5 ? Promise.reject(e6) : t5(n5.apply(this.s, arguments));
  } }, new u4(e5);
}
var p5 = async (e5, t5, n5 = e5.name, r5) => {
  const i4 = [], a7 = [];
  var o5, s5 = false, c5 = false;
  try {
    for (var l7, d6 = function(e6) {
      var t6, n6, r6, i5 = 2;
      for ("undefined" != typeof Symbol && (n6 = Symbol.asyncIterator, r6 = Symbol.iterator); i5--; ) {
        if (n6 && null != (t6 = e6[n6]))
          return t6.call(e6);
        if (r6 && null != (t6 = e6[r6]))
          return new u4(t6.call(e6));
        n6 = "@@asyncIterator", r6 = "@@iterator";
      }
      throw new TypeError("Object is not async iterable");
    }(e5.values()); s5 = !(l7 = await d6.next()).done; s5 = false) {
      const o6 = l7.value, s6 = `${n5}/${o6.name}`;
      "file" === o6.kind ? a7.push(o6.getFile().then((t6) => (t6.directoryHandle = e5, t6.handle = o6, Object.defineProperty(t6, "webkitRelativePath", { configurable: true, enumerable: true, get: () => s6 })))) : "directory" !== o6.kind || !t5 || r5 && r5(o6) || i4.push(p5(o6, t5, s6, r5));
    }
  } catch (e6) {
    c5 = true, o5 = e6;
  } finally {
    try {
      s5 && null != d6.return && await d6.return();
    } finally {
      if (c5)
        throw o5;
    }
  }
  return [...(await Promise.all(i4)).flat(), ...await Promise.all(a7)];
};
var d5 = async (e5 = {}) => {
  e5.recursive = e5.recursive || false, e5.mode = e5.mode || "read";
  const t5 = await window.showDirectoryPicker({ id: e5.id, startIn: e5.startIn, mode: e5.mode });
  return (await (await t5.values()).next()).done ? [t5] : p5(t5, e5.recursive, void 0, e5.skipDirectory);
};
var y5 = { __proto__: null, default: d5 };
var f4 = async (e5, t5 = [{}], n5 = null, r5 = false, i4 = null) => {
  Array.isArray(t5) || (t5 = [t5]), t5[0].fileName = t5[0].fileName || "Untitled";
  const a7 = [];
  let o5 = null;
  if (e5 instanceof Blob && e5.type ? o5 = e5.type : e5.headers && e5.headers.get("content-type") && (o5 = e5.headers.get("content-type")), t5.forEach((e6, t6) => {
    a7[t6] = { description: e6.description || "Files", accept: {} }, e6.mimeTypes ? (0 === t6 && o5 && e6.mimeTypes.push(o5), e6.mimeTypes.map((n6) => {
      a7[t6].accept[n6] = e6.extensions || [];
    })) : o5 ? a7[t6].accept[o5] = e6.extensions || [] : a7[t6].accept["*/*"] = e6.extensions || [];
  }), n5)
    try {
      await n5.getFile();
    } catch (e6) {
      if (n5 = null, r5)
        throw e6;
    }
  const s5 = n5 || await window.showSaveFilePicker({ suggestedName: t5[0].fileName, id: t5[0].id, startIn: t5[0].startIn, types: a7, excludeAcceptAllOption: t5[0].excludeAcceptAllOption || false });
  !n5 && i4 && i4(s5);
  const c5 = await s5.createWritable();
  if ("stream" in e5) {
    const t6 = e5.stream();
    return await t6.pipeTo(c5), s5;
  }
  return "body" in e5 ? (await e5.body.pipeTo(c5), s5) : (await c5.write(await e5), await c5.close(), s5);
};
var m5 = { __proto__: null, default: f4 };
var w6 = async (e5 = [{}]) => (Array.isArray(e5) || (e5 = [e5]), new Promise((t5, n5) => {
  const r5 = document.createElement("input");
  r5.type = "file";
  const i4 = [...e5.map((e6) => e6.mimeTypes || []), ...e5.map((e6) => e6.extensions || [])].join();
  r5.multiple = e5[0].multiple || false, r5.accept = i4 || "", r5.style.display = "none", document.body.append(r5);
  const a7 = (e6) => {
    "function" == typeof o5 && o5(), t5(e6);
  }, o5 = e5[0].legacySetup && e5[0].legacySetup(a7, () => o5(n5), r5), s5 = () => {
    window.removeEventListener("focus", s5), r5.remove();
  };
  r5.addEventListener("click", () => {
    window.addEventListener("focus", s5);
  }), r5.addEventListener("change", () => {
    window.removeEventListener("focus", s5), r5.remove(), a7(r5.multiple ? Array.from(r5.files) : r5.files[0]);
  }), "showPicker" in HTMLInputElement.prototype ? r5.showPicker() : r5.click();
}));
var v5 = { __proto__: null, default: w6 };
var h5 = async (e5 = [{}]) => (Array.isArray(e5) || (e5 = [e5]), e5[0].recursive = e5[0].recursive || false, new Promise((t5, n5) => {
  const r5 = document.createElement("input");
  r5.type = "file", r5.webkitdirectory = true;
  const i4 = (e6) => {
    "function" == typeof a7 && a7(), t5(e6);
  }, a7 = e5[0].legacySetup && e5[0].legacySetup(i4, () => a7(n5), r5);
  r5.addEventListener("change", () => {
    let t6 = Array.from(r5.files);
    e5[0].recursive ? e5[0].recursive && e5[0].skipDirectory && (t6 = t6.filter((t7) => t7.webkitRelativePath.split("/").every((t8) => !e5[0].skipDirectory({ name: t8, kind: "directory" })))) : t6 = t6.filter((e6) => 2 === e6.webkitRelativePath.split("/").length), i4(t6);
  }), "showPicker" in HTMLInputElement.prototype ? r5.showPicker() : r5.click();
}));
var b5 = { __proto__: null, default: h5 };
var P4 = async (e5, t5 = {}) => {
  Array.isArray(t5) && (t5 = t5[0]);
  const n5 = document.createElement("a");
  let r5 = e5;
  "body" in e5 && (r5 = await async function(e6, t6) {
    const n6 = e6.getReader(), r6 = new ReadableStream({ start: (e7) => async function t7() {
      return n6.read().then(({ done: n7, value: r7 }) => {
        if (!n7)
          return e7.enqueue(r7), t7();
        e7.close();
      });
    }() }), i5 = new Response(r6), a8 = await i5.blob();
    return n6.releaseLock(), new Blob([a8], { type: t6 });
  }(e5.body, e5.headers.get("content-type"))), n5.download = t5.fileName || "Untitled", n5.href = URL.createObjectURL(await r5);
  const i4 = () => {
    "function" == typeof a7 && a7();
  }, a7 = t5.legacySetup && t5.legacySetup(i4, () => a7(), n5);
  return n5.addEventListener("click", () => {
    setTimeout(() => URL.revokeObjectURL(n5.href), 3e4), i4();
  }), n5.click(), null;
};
var k6 = { __proto__: null, default: P4 };

// src/components/Tldraw/state/data/filesystem.ts
async function openAssetsFromFileSystem() {
  return await n4({
    description: "Image",
    extensions: [...IMAGE_EXTENSIONS],
    multiple: true
  });
}
async function fileToBase64(file) {
  return await new Promise((resolve, reject) => {
    if (file) {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = () => resolve(reader.result);
      reader.onerror = (error) => reject(error);
      reader.onabort = (error) => reject(error);
    }
  });
}
async function fileToText(file) {
  return await new Promise((resolve, reject) => {
    if (file) {
      const reader = new FileReader();
      reader.readAsText(file);
      reader.onload = () => resolve(reader.result);
      reader.onerror = (error) => reject(error);
      reader.onabort = (error) => reject(error);
    }
  });
}
async function getImageSizeFromSrc(src) {
  return await new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve([img.width, img.height]);
    img.onerror = () => reject(new Error("Could not get image size"));
    img.src = src;
  });
}

// src/components/Tldraw/state/sessions/BaseSession.ts
var BaseSession = class {
  constructor(app) {
    this.app = app;
  }
};

// src/components/Tldraw/state/sessions/ArrowSession/ArrowSession.ts
var ArrowSession = class extends BaseSession {
  type = "arrow" /* Arrow */;
  performanceMode = void 0;
  status = "translatingHandle" /* TranslatingHandle */;
  newStartBindingId = C3.uniqueId();
  draggedBindingId = C3.uniqueId();
  didBind = false;
  initialShape;
  handleId;
  bindableShapeIds;
  initialBinding;
  startBindingShapeId;
  isCreate;
  constructor(app, shapeId, handleId, isCreate = false) {
    super(app);
    this.isCreate = isCreate;
    const { currentPageId } = app.state.appState;
    const page = app.state.document.pages[currentPageId];
    this.handleId = handleId;
    this.initialShape = deepCopy(page.shapes[shapeId]);
    this.bindableShapeIds = TLDR.getBindableShapeIds(app.state).filter((id) => !(id === this.initialShape.id || id === this.initialShape.parentId));
    const oppositeHandleBindingId = this.initialShape.handles[handleId === "start" ? "end" : "start"]?.bindingId;
    if (oppositeHandleBindingId) {
      const oppositeToId = page.bindings[oppositeHandleBindingId]?.toId;
      if (oppositeToId) {
        this.bindableShapeIds = this.bindableShapeIds.filter((id) => id !== oppositeToId);
      }
    }
    const { originPoint } = this.app;
    if (this.isCreate) {
      this.startBindingShapeId = this.bindableShapeIds.map((id) => page.shapes[id]).filter((shape) => !shape.isLocked && C3.pointInBounds(originPoint, TLDR.getShapeUtil(shape).getBounds(shape))).sort((a7, b6) => {
        return b6.childIndex - a7.childIndex;
      })[0]?.id;
      if (this.startBindingShapeId) {
        this.bindableShapeIds.splice(this.bindableShapeIds.indexOf(this.startBindingShapeId), 1);
      }
    } else {
      const initialBindingId = this.initialShape.handles[this.handleId].bindingId;
      if (initialBindingId) {
        this.initialBinding = page.bindings[initialBindingId];
      } else {
        this.initialShape.handles[this.handleId].bindingId = void 0;
      }
    }
  }
  start = () => void 0;
  update = () => {
    const { initialShape } = this;
    const {
      currentPoint,
      shiftKey,
      altKey,
      metaKey,
      currentGrid,
      settings: { showGrid }
    } = this.app;
    const shape = this.app.getShape(initialShape.id);
    if (shape.isLocked)
      return;
    const { handles } = initialShape;
    const handleId = this.handleId;
    if (!handles[handleId].canBind)
      return;
    let delta = e.sub(currentPoint, e.add(handles[handleId].point, initialShape.point));
    if (shiftKey) {
      const A6 = altKey ? e.med(handles.start.point, handles.end.point) : handles[handleId === "start" ? "end" : "start"].point;
      const B5 = handles[handleId].point;
      const C6 = e.add(B5, delta);
      const angle = e.angle(A6, C6);
      const adjusted = e.rotWith(C6, A6, C3.snapAngleToSegments(angle, 24) - angle);
      delta = e.add(delta, e.sub(adjusted, C6));
    }
    const nextPoint = e.add(handles[handleId].point, delta);
    const handleChanges = {
      [handleId]: {
        ...handles[handleId],
        point: showGrid ? e.snap(nextPoint, currentGrid) : e.toFixed(nextPoint),
        bindingId: void 0
      }
    };
    const utils = shapeUtils["arrow" /* Arrow */];
    const handleChange = utils.onHandleChange?.(initialShape, handleChanges);
    if (!handleChange)
      return;
    const next = {
      shape: C3.deepMerge(shape, handleChange),
      bindings: {}
    };
    let draggedBinding;
    const draggingHandle = next.shape.handles[this.handleId];
    const oppositeHandle = next.shape.handles[this.handleId === "start" ? "end" : "start"];
    if (this.startBindingShapeId) {
      let nextStartBinding;
      const startTarget = this.app.page.shapes[this.startBindingShapeId];
      const startTargetUtils = TLDR.getShapeUtil(startTarget);
      const center = startTargetUtils.getCenter(startTarget);
      const startHandle = next.shape.handles.start;
      const endHandle = next.shape.handles.end;
      const rayPoint = e.add(startHandle.point, next.shape.point);
      if (e.isEqual(rayPoint, center))
        rayPoint[1]++;
      const rayOrigin = center;
      const isInsideShape = startTargetUtils.hitTestPoint(startTarget, currentPoint);
      const rayDirection = e.uni(e.sub(rayPoint, rayOrigin));
      const hasStartBinding = this.app.getBinding(this.newStartBindingId) !== void 0;
      if (!metaKey && !startTargetUtils.hitTestPoint(startTarget, e.add(next.shape.point, endHandle.point))) {
        nextStartBinding = this.findBindingPoint(shape, startTarget, "start", this.newStartBindingId, center, rayOrigin, rayDirection, isInsideShape);
      }
      if (nextStartBinding && !hasStartBinding) {
        this.didBind = true;
        next.bindings[this.newStartBindingId] = nextStartBinding;
        next.shape = C3.deepMerge(next.shape, {
          handles: {
            start: {
              bindingId: nextStartBinding.id
            }
          }
        });
      } else if (!nextStartBinding && hasStartBinding) {
        this.didBind = false;
        next.bindings[this.newStartBindingId] = void 0;
        next.shape = C3.deepMerge(initialShape, {
          handles: {
            start: {
              bindingId: void 0
            }
          }
        });
      }
    }
    if (!metaKey) {
      const rayOrigin = e.add(oppositeHandle.point, next.shape.point);
      const rayPoint = e.add(draggingHandle.point, next.shape.point);
      const rayDirection = e.uni(e.sub(rayPoint, rayOrigin));
      const startPoint = e.add(next.shape.point, next.shape.handles.start.point);
      const endPoint = e.add(next.shape.point, next.shape.handles.end.point);
      const targets = this.bindableShapeIds.map((id) => this.app.page.shapes[id]).sort((a7, b6) => b6.childIndex - a7.childIndex).filter((shape2) => {
        if (shape2.isLocked)
          return false;
        const utils2 = TLDR.getShapeUtil(shape2);
        return ![startPoint, endPoint].every((point) => utils2.hitTestPoint(shape2, point));
      });
      for (const target of targets) {
        draggedBinding = this.findBindingPoint(shape, target, this.handleId, this.draggedBindingId, rayPoint, rayOrigin, rayDirection, altKey);
        if (draggedBinding)
          break;
      }
    }
    if (draggedBinding) {
      this.didBind = true;
      next.bindings[this.draggedBindingId] = draggedBinding;
      next.shape = C3.deepMerge(next.shape, {
        handles: {
          [this.handleId]: {
            bindingId: this.draggedBindingId
          }
        }
      });
    } else {
      this.didBind = this.didBind || false;
      const currentBindingId = shape.handles[this.handleId].bindingId;
      if (currentBindingId !== void 0) {
        next.bindings[currentBindingId] = void 0;
        next.shape = C3.deepMerge(next.shape, {
          handles: {
            [this.handleId]: {
              bindingId: void 0
            }
          }
        });
      }
    }
    const change = TLDR.getShapeUtil(next.shape).onHandleChange?.(next.shape, next.shape.handles);
    return {
      document: {
        pages: {
          [this.app.currentPageId]: {
            shapes: {
              [shape.id]: { ...next.shape, ...change }
            },
            bindings: next.bindings
          }
        },
        pageStates: {
          [this.app.currentPageId]: {
            bindingId: next.shape.handles[handleId].bindingId
          }
        }
      }
    };
  };
  cancel = () => {
    const { initialShape, initialBinding, newStartBindingId, draggedBindingId } = this;
    const currentShape = TLDR.onSessionComplete(this.app.page.shapes[initialShape.id]);
    const isDeleting = this.isCreate || e.dist(currentShape.handles.start.point, currentShape.handles.end.point) < 4;
    const afterBindings = {};
    afterBindings[draggedBindingId] = void 0;
    if (initialBinding) {
      afterBindings[initialBinding.id] = isDeleting ? void 0 : initialBinding;
    }
    if (newStartBindingId) {
      afterBindings[newStartBindingId] = void 0;
    }
    return {
      document: {
        pages: {
          [this.app.currentPageId]: {
            shapes: {
              [initialShape.id]: isDeleting ? void 0 : initialShape
            },
            bindings: afterBindings
          }
        },
        pageStates: {
          [this.app.currentPageId]: {
            selectedIds: isDeleting ? [] : [initialShape.id],
            bindingId: void 0,
            hoveredId: void 0,
            editingId: void 0
          }
        }
      }
    };
  };
  complete = () => {
    const { initialShape, initialBinding, newStartBindingId, startBindingShapeId, handleId } = this;
    const currentShape = TLDR.onSessionComplete(this.app.page.shapes[initialShape.id]);
    const currentBindingId = currentShape.handles[handleId].bindingId;
    const length = e.dist(currentShape.handles.start.point, currentShape.handles.end.point);
    if (!(currentBindingId || initialBinding) && length < 4)
      return this.cancel();
    const beforeBindings = {};
    const afterBindings = {};
    if (initialBinding) {
      beforeBindings[initialBinding.id] = this.isCreate ? void 0 : initialBinding;
      afterBindings[initialBinding.id] = void 0;
    }
    if (currentBindingId) {
      beforeBindings[currentBindingId] = void 0;
      afterBindings[currentBindingId] = this.app.page.bindings[currentBindingId];
    }
    if (startBindingShapeId) {
      beforeBindings[newStartBindingId] = void 0;
      afterBindings[newStartBindingId] = this.app.page.bindings[newStartBindingId];
    }
    return {
      id: "arrow",
      before: {
        document: {
          pages: {
            [this.app.currentPageId]: {
              shapes: {
                [initialShape.id]: this.isCreate ? void 0 : initialShape
              },
              bindings: beforeBindings
            }
          },
          pageStates: {
            [this.app.currentPageId]: {
              selectedIds: this.isCreate ? [] : [initialShape.id],
              bindingId: void 0,
              hoveredId: void 0,
              editingId: void 0
            }
          }
        }
      },
      after: {
        document: {
          pages: {
            [this.app.currentPageId]: {
              shapes: {
                [initialShape.id]: currentShape
              },
              bindings: afterBindings
            }
          },
          pageStates: {
            [this.app.currentPageId]: {
              selectedIds: [initialShape.id],
              bindingId: void 0,
              hoveredId: void 0,
              editingId: void 0
            }
          }
        }
      }
    };
  };
  findBindingPoint = (shape, target, handleId, bindingId, point, origin, direction, bindAnywhere) => {
    const util = TLDR.getShapeUtil(target.type);
    const bindingPoint = util.getBindingPoint(
      target,
      shape,
      point,
      // fix dead center bug
      origin,
      direction,
      bindAnywhere
    );
    if (!bindingPoint)
      return;
    return {
      id: bindingId,
      type: "arrow",
      fromId: shape.id,
      toId: target.id,
      handleId,
      point: e.toFixed(bindingPoint.point),
      distance: bindingPoint.distance
    };
  };
};

// src/components/Tldraw/state/sessions/BrushSession/BrushSession.ts
var BrushSession = class extends BaseSession {
  type = "brush" /* Brush */;
  performanceMode = void 0;
  status = "brushing" /* Brushing */;
  initialSelectedIds;
  shapesToTest;
  constructor(app) {
    super(app);
    const { currentPageId } = app;
    this.initialSelectedIds = new Set(this.app.selectedIds);
    this.shapesToTest = this.app.shapes.filter(
      (shape) => !(shape.isLocked || shape.isHidden || shape.parentId !== currentPageId || this.initialSelectedIds.has(shape.id) || this.initialSelectedIds.has(shape.parentId))
    ).map((shape) => ({
      id: shape.id,
      bounds: this.app.getShapeUtil(shape).getBounds(shape),
      selectId: shape.id
      // TLDR.getTopParentId(data, shape.id, currentPageId),
    }));
    this.update();
  }
  start = () => void 0;
  update = () => {
    const {
      initialSelectedIds,
      shapesToTest,
      app: { metaKey, settings, originPoint, currentPoint }
    } = this;
    const brush = C3.getBoundsFromPoints([originPoint, currentPoint]);
    const selectByContain = settings.isCadSelectMode ? !metaKey && originPoint[0] < currentPoint[0] : metaKey;
    const hits = /* @__PURE__ */ new Set();
    const selectedIds = new Set(initialSelectedIds);
    shapesToTest.forEach(({ id, selectId }) => {
      const shape = this.app.getShape(id);
      if (!hits.has(selectId)) {
        const util = this.app.getShapeUtil(shape);
        if (selectByContain ? C3.boundsContain(brush, util.getBounds(shape)) : util.hitTestBounds(shape, brush)) {
          hits.add(selectId);
          if (!selectedIds.has(selectId)) {
            selectedIds.add(selectId);
          }
        } else if (selectedIds.has(selectId)) {
          selectedIds.delete(selectId);
        }
      }
    });
    const currentSelectedIds = this.app.selectedIds;
    const didChange = selectedIds.size !== currentSelectedIds.length || currentSelectedIds.some((id) => !selectedIds.has(id));
    const afterSelectedIds = didChange ? [...selectedIds.values()] : currentSelectedIds;
    if (!didChange)
      return {
        appState: {
          selectByContain
        },
        document: {
          pageStates: {
            [this.app.currentPageId]: {
              brush
            }
          }
        }
      };
    return {
      appState: {
        selectByContain
      },
      document: {
        pageStates: {
          [this.app.currentPageId]: {
            brush,
            selectedIds: afterSelectedIds
          }
        }
      }
    };
  };
  cancel = () => {
    return {
      appState: {
        selectByContain: false
      },
      document: {
        pageStates: {
          [this.app.currentPageId]: {
            brush: null,
            selectedIds: [...this.initialSelectedIds.values()]
          }
        }
      }
    };
  };
  complete = () => {
    return {
      appState: {
        selectByContain: false
      },
      document: {
        pageStates: {
          [this.app.currentPageId]: {
            brush: null,
            selectedIds: [...this.app.selectedIds]
          }
        }
      }
    };
  };
};

// src/components/Tldraw/state/sessions/DrawSession/DrawSession.ts
var DrawSession = class extends BaseSession {
  type = "draw" /* Draw */;
  performanceMode = void 0;
  status = "creating" /* Creating */;
  topLeft;
  points;
  initialShape;
  lastAdjustedPoint;
  shiftedPoints = [];
  shapeId;
  isLocked;
  isExtending;
  lockedDirection;
  constructor(app, id) {
    super(app);
    const { originPoint } = this.app;
    this.shapeId = id;
    this.initialShape = this.app.getShape(id);
    this.topLeft = [...this.initialShape.point];
    const currentPoint = [0, 0, originPoint[2] ?? 0.5];
    const delta = e.sub(originPoint, this.topLeft);
    const initialPoints = this.initialShape.points.map((pt2) => e.sub(pt2, delta).concat(pt2[2]));
    this.isExtending = initialPoints.length > 0;
    const newPoints = [];
    if (this.isExtending) {
      const prevPoint = initialPoints[initialPoints.length - 1];
      if (prevPoint) {
        newPoints.push(prevPoint, prevPoint);
        const len = Math.floor(e.dist(prevPoint, currentPoint) / 16);
        if (len > 1) {
          for (let i4 = 0; i4 < len; i4++) {
            const t5 = i4 / (len - 1);
            newPoints.push(e.lrp(prevPoint, currentPoint, t5).concat(prevPoint[2]));
          }
        } else {
          newPoints.push(currentPoint, currentPoint);
        }
      }
    } else {
      newPoints.push(currentPoint);
    }
    this.points = [...initialPoints, ...newPoints];
    this.shiftedPoints = this.points.map((pt2) => e.add(pt2, delta).concat(pt2[2]));
    this.lastAdjustedPoint = this.points[this.points.length - 1];
  }
  start = () => {
    const currentPoint = this.app.originPoint;
    const newAdjustedPoint = [0, 0, currentPoint[2] ?? 0.5];
    this.points.push(newAdjustedPoint);
    const topLeft = [Math.min(this.topLeft[0], currentPoint[0]), Math.min(this.topLeft[1], currentPoint[1])];
    const delta = e.sub(topLeft, currentPoint);
    this.topLeft = topLeft;
    this.shiftedPoints = this.points.map((pt2) => e.toFixed(e.sub(pt2, delta)).concat(pt2[2]));
    return {
      document: {
        pages: {
          [this.app.currentPageId]: {
            shapes: {
              [this.shapeId]: {
                point: this.topLeft,
                points: this.shiftedPoints
              }
            }
          }
        },
        pageStates: {
          [this.app.currentPageId]: {
            selectedIds: [this.shapeId]
          }
        }
      }
    };
  };
  update = () => {
    const { shapeId } = this;
    const { currentPoint, originPoint, shiftKey, zoom } = this.app;
    if (!this.lockedDirection && this.points.length > 1) {
      const delta = e.sub(currentPoint, originPoint);
      if (e.len(delta) > 3 / zoom) {
        this.lockedDirection = Math.abs(delta[0]) > Math.abs(delta[1]) ? "horizontal" : "vertical";
      }
    }
    if (shiftKey) {
      if (!this.isLocked && this.points.length > 2) {
        if (!this.lockedDirection) {
          const delta = e.sub(currentPoint, originPoint);
          if (e.len(delta) > 3 / zoom) {
            this.lockedDirection = Math.abs(delta[0]) > Math.abs(delta[1]) ? "horizontal" : "vertical";
          }
        }
        this.isLocked = true;
        const returning = [...this.lastAdjustedPoint];
        if (this.lockedDirection === "vertical") {
          returning[0] = 0;
        } else {
          returning[1] = 0;
        }
        this.points.push(returning.concat(currentPoint[2]));
      }
    } else if (this.isLocked) {
      this.isLocked = false;
    }
    if (this.isLocked) {
      if (this.lockedDirection === "vertical") {
        currentPoint[0] = originPoint[0];
      } else {
        currentPoint[1] = originPoint[1];
      }
    }
    const change = this.addPoint(currentPoint);
    if (!change)
      return;
    return {
      document: {
        pages: {
          [this.app.currentPageId]: {
            shapes: {
              [shapeId]: change
            }
          }
        },
        pageStates: {
          [this.app.currentPageId]: {
            selectedIds: [shapeId]
          }
        }
      }
    };
  };
  cancel = () => {
    const { shapeId } = this;
    const pageId = this.app.currentPageId;
    return {
      document: {
        pages: {
          [pageId]: {
            shapes: {
              [shapeId]: this.isExtending ? this.initialShape : void 0
            }
          }
        },
        pageStates: {
          [pageId]: {
            selectedIds: []
          }
        }
      }
    };
  };
  complete = () => {
    const { shapeId } = this;
    const pageId = this.app.currentPageId;
    const shape = this.app.getShape(shapeId);
    return {
      id: "create_draw",
      before: {
        document: {
          pages: {
            [pageId]: {
              shapes: {
                [shapeId]: this.isExtending ? this.initialShape : void 0
              }
            }
          },
          pageStates: {
            [pageId]: {
              selectedIds: []
            }
          }
        }
      },
      after: {
        document: {
          pages: {
            [pageId]: {
              shapes: {
                [shapeId]: {
                  ...shape,
                  point: e.toFixed(shape.point),
                  points: shape.points.map((pt2) => e.toFixed(pt2)),
                  isComplete: true
                }
              }
            }
          },
          pageStates: {
            [this.app.currentPageId]: {
              selectedIds: []
            }
          }
        }
      }
    };
  };
  addPoint = (currentPoint) => {
    const { originPoint } = this.app;
    const newAdjustedPoint = e.toFixed(e.sub(currentPoint, originPoint)).concat(currentPoint[2]);
    if (e.isEqual(this.lastAdjustedPoint, newAdjustedPoint))
      return;
    this.points.push(newAdjustedPoint);
    this.lastAdjustedPoint = newAdjustedPoint;
    const prevTopLeft = [...this.topLeft];
    const topLeft = [Math.min(this.topLeft[0], currentPoint[0]), Math.min(this.topLeft[1], currentPoint[1])];
    const delta = e.sub(topLeft, originPoint);
    let points;
    if (prevTopLeft[0] !== topLeft[0] || prevTopLeft[1] !== topLeft[1]) {
      this.topLeft = topLeft;
      points = this.points.map((pt2) => e.toFixed(e.sub(pt2, delta)).concat(pt2[2]));
    } else {
      points = [...this.shiftedPoints, e.sub(newAdjustedPoint, delta).concat(newAdjustedPoint[2])];
    }
    this.shiftedPoints = points;
    return {
      point: this.topLeft,
      points
    };
  };
};

// src/components/Tldraw/state/sessions/EditSession/EditSession.ts
var EditSession = class extends BaseSession {
  type = "edit" /* Edit */;
  performanceMode = void 0;
  initialShape;
  initialSelectedIds;
  currentPageId;
  isCreating;
  constructor(app, id, isCreating) {
    super(app);
    this.initialShape = app.getShape(id, app.currentPageId);
    this.currentPageId = app.currentPageId;
    this.isCreating = isCreating;
    this.initialSelectedIds = [...app.selectedIds];
  }
  start = () => void 0;
  update = () => void 0;
  cancel = () => {
    return {
      document: {
        pages: {
          [this.currentPageId]: {
            shapes: {
              [this.initialShape.id]: this.isCreating ? void 0 : this.initialShape
            }
          }
        },
        pageStates: {
          [this.currentPageId]: {
            selectedIds: this.isCreating ? [] : this.initialSelectedIds,
            editingId: void 0
          }
        }
      }
    };
  };
  complete = () => {
    const shape = this.app.getShape(this.initialShape.id);
    return {
      id: "edit",
      before: {
        document: {
          pages: {
            [this.currentPageId]: {
              shapes: {
                [this.initialShape.id]: this.isCreating ? void 0 : this.initialShape
              }
            }
          },
          pageStates: {
            [this.currentPageId]: {
              selectedIds: this.isCreating ? [] : this.initialSelectedIds,
              editingId: void 0
            }
          }
        }
      },
      after: {
        document: {
          pages: {
            [this.currentPageId]: {
              shapes: {
                [this.initialShape.id]: shape
              }
            }
          },
          pageStates: {
            [this.currentPageId]: {
              selectedIds: [shape.id],
              editingId: void 0
            }
          }
        }
      }
    };
  };
};

// src/components/Tldraw/state/sessions/EraseSession/EraseSession.ts
var EraseSession = class extends BaseSession {
  type = "draw" /* Draw */;
  performanceMode = void 0;
  status = "creating" /* Creating */;
  isLocked;
  lockedDirection;
  erasedShapes = /* @__PURE__ */ new Set();
  erasedBindings = /* @__PURE__ */ new Set();
  initialSelectedShapes;
  erasableShapes;
  prevPoint;
  prevEraseShapesSize = 0;
  constructor(app) {
    super(app);
    this.prevPoint = [...app.originPoint];
    this.initialSelectedShapes = this.app.selectedIds.map((id) => this.app.getShape(id));
    this.erasableShapes = new Set(this.app.shapes.filter((shape) => !shape.isLocked));
    this.interval = this.loop();
  }
  interval;
  timestamp1 = 0;
  timestamp2 = 0;
  prevErasePoint = [];
  loop = () => {
    const now = Date.now();
    const elapsed1 = now - this.timestamp1;
    const elapsed2 = now - this.timestamp2;
    const { eraseLine } = this.app.appState;
    let next = [...eraseLine];
    let didUpdate = false;
    if (elapsed1 > 16 && this.prevErasePoint !== this.prevPoint) {
      didUpdate = true;
      next = [...eraseLine, this.prevPoint];
      this.prevErasePoint = this.prevPoint;
    }
    if (elapsed2 > 32 && next.length > 1) {
      didUpdate = true;
      next.splice(0, Math.ceil(next.length * 0.1));
      this.timestamp2 = now;
    }
    if (didUpdate) {
      this.app.patchState(
        {
          appState: {
            eraseLine: next
          }
        },
        "eraseline"
      );
    }
    this.interval = requestAnimationFrame(this.loop);
  };
  start = () => void 0;
  update = () => {
    const { page, shiftKey, originPoint, currentPoint, zoom } = this.app;
    if (shiftKey) {
      const delta = e.sub(currentPoint, originPoint);
      if (!this.isLocked && e.len(delta) > 3 / zoom) {
        if (!this.lockedDirection) {
          const delta2 = e.sub(currentPoint, originPoint);
          this.lockedDirection = Math.abs(delta2[0]) > Math.abs(delta2[1]) ? "horizontal" : "vertical";
        }
        this.isLocked = true;
      }
    } else if (this.isLocked) {
      this.isLocked = false;
    }
    if (this.isLocked) {
      if (this.lockedDirection === "vertical") {
        currentPoint[0] = originPoint[0];
      } else {
        currentPoint[1] = originPoint[1];
      }
    }
    const newPoint = e.toFixed(e.add(originPoint, e.sub(currentPoint, originPoint)));
    const deletedShapeIds = /* @__PURE__ */ new Set([]);
    this.erasableShapes.forEach((shape) => {
      if (this.erasedShapes.has(shape))
        return;
      if (this.app.getShapeUtil(shape).hitTestLineSegment(shape, this.prevPoint, newPoint)) {
        this.erasedShapes.add(shape);
        deletedShapeIds.add(shape.id);
        if (shape.children !== void 0) {
          for (const childId of shape.children) {
            this.erasedShapes.add(this.app.getShape(childId));
            deletedShapeIds.add(childId);
          }
        }
      }
    });
    Object.values(page.bindings).forEach((binding) => {
      for (const id of [binding.toId, binding.fromId]) {
        if (deletedShapeIds.has(id)) {
          this.erasedBindings.add(binding);
        }
      }
    });
    this.erasedShapes.forEach((shape) => {
      if (!this.app.getShape(shape.id)) {
        this.erasedShapes.delete(shape);
        this.erasableShapes.delete(shape);
        deletedShapeIds.delete(shape.id);
      }
    });
    const erasedShapes = [...this.erasedShapes.values()];
    this.prevPoint = newPoint;
    if (erasedShapes.length === this.prevEraseShapesSize) {
      return;
    }
    this.prevEraseShapesSize = erasedShapes.length;
    return {
      document: {
        pages: {
          [page.id]: {
            shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, { isGhost: true }]))
          }
        }
      }
    };
  };
  cancel = () => {
    const { page } = this.app;
    cancelAnimationFrame(this.interval);
    this.erasedShapes.forEach((shape) => {
      if (!this.app.getShape(shape.id)) {
        this.erasedShapes.delete(shape);
        this.erasableShapes.delete(shape);
      }
    });
    const erasedShapes = [...this.erasedShapes.values()];
    return {
      document: {
        pages: {
          [page.id]: {
            shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, { isGhost: false }]))
          }
        },
        pageStates: {
          [page.id]: {
            selectedIds: this.initialSelectedShapes.map((shape) => shape.id)
          }
        }
      },
      appState: {
        eraseLine: []
      }
    };
  };
  complete = () => {
    const { page } = this.app;
    cancelAnimationFrame(this.interval);
    this.erasedShapes.forEach((shape) => {
      if (!this.app.getShape(shape.id)) {
        this.erasedShapes.delete(shape);
        this.erasableShapes.delete(shape);
      }
    });
    this.erasedBindings.forEach((binding) => {
      if (!this.app.getBinding(binding.id)) {
        this.erasedBindings.delete(binding);
      }
    });
    const erasedShapes = [...this.erasedShapes.values()];
    const erasedBindings = [...this.erasedBindings.values()];
    const erasedShapeIds = new Set(erasedShapes.map((shape) => shape.id));
    const erasedBindingIds = new Set(erasedBindings.map((binding) => binding.id));
    const before = {
      shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, shape])),
      bindings: Object.fromEntries(erasedBindings.map((binding) => [binding.id, binding]))
    };
    const after = {
      shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, void 0])),
      bindings: Object.fromEntries(erasedBindings.map((binding) => [binding.id, void 0]))
    };
    this.app.shapes.forEach((shape) => {
      if (shape.handles && !after.shapes[shape.id]) {
        Object.values(shape.handles).forEach((handle) => {
          if (handle.bindingId && erasedBindingIds.has(handle.bindingId)) {
            before.shapes[shape.id] = {
              ...before.shapes[shape.id],
              handles: {
                ...before.shapes[shape.id]?.handles,
                [handle.id]: handle
              }
            };
            if (!erasedShapeIds.has(shape.id)) {
              after.shapes[shape.id] = {
                ...after.shapes[shape.id],
                handles: {
                  ...after.shapes[shape.id]?.handles,
                  [handle.id]: {
                    ...handle,
                    bindingId: void 0
                  }
                }
              };
            }
          }
        });
      }
    });
    return {
      id: "erase",
      before: {
        document: {
          pages: {
            [page.id]: before
          },
          pageStates: {
            [page.id]: {
              selectedIds: this.initialSelectedShapes.filter((shape) => !!this.app.getShape(shape.id)).map((shape) => shape.id)
            }
          }
        },
        appState: {
          eraseLine: []
        }
      },
      after: {
        document: {
          pages: {
            [page.id]: after
          },
          pageStates: {
            [page.id]: {
              selectedIds: this.initialSelectedShapes.filter((shape) => !!this.app.getShape(shape.id)).filter((shape) => !erasedShapeIds.has(shape.id)).map((shape) => shape.id)
            }
          }
        },
        appState: {
          eraseLine: []
        }
      }
    };
  };
};

// src/components/Tldraw/state/sessions/GridSession/GridSession.ts
var GridSession = class extends BaseSession {
  type = "grid" /* Grid */;
  performanceMode = void 0;
  status = "translating" /* Translating */;
  shape;
  bounds;
  initialSelectedIds;
  initialSiblings;
  grid = {};
  columns = 1;
  rows = 1;
  isCopying = false;
  constructor(app, id) {
    super(app);
    this.shape = this.app.getShape(id);
    this.grid["0_0"] = this.shape.id;
    this.bounds = this.app.getShapeBounds(id);
    this.initialSelectedIds = [...this.app.selectedIds];
    if (this.shape.parentId !== this.app.currentPageId) {
      this.initialSiblings = this.app.getShape(this.shape.parentId).children?.filter((id2) => id2 !== this.shape.id);
    }
  }
  start = () => void 0;
  update = () => {
    const { currentPageId, altKey, shiftKey, currentPoint } = this.app;
    const nextShapes = {};
    const nextPageState = {};
    const center = C3.getBoundsCenter(this.bounds);
    const offset = e.sub(currentPoint, center);
    if (shiftKey) {
      if (Math.abs(offset[0]) < Math.abs(offset[1])) {
        offset[0] = 0;
      } else {
        offset[1] = 0;
      }
    }
    const gapX = this.bounds.width + 32;
    const gapY = this.bounds.height + 32;
    const columns = Math.ceil(offset[0] / gapX);
    const rows = Math.ceil(offset[1] / gapY);
    const minX = Math.min(columns, 0);
    const minY = Math.min(rows, 0);
    const maxX = Math.max(columns, 1);
    const maxY = Math.max(rows, 1);
    const inGrid = /* @__PURE__ */ new Set();
    const isCopying = altKey;
    if (isCopying !== this.isCopying) {
      Object.values(this.grid).filter((id) => id !== this.shape.id).forEach((id) => nextShapes[id] = void 0);
      this.grid = { "0_0": this.shape.id };
      this.isCopying = isCopying;
    }
    for (let x5 = minX; x5 < maxX; x5++) {
      for (let y6 = minY; y6 < maxY; y6++) {
        const position = `${x5}_${y6}`;
        inGrid.add(position);
        if (this.grid[position])
          continue;
        if (x5 === 0 && y6 === 0)
          continue;
        const clone = this.getClone(e.add(this.shape.point, [x5 * gapX, y6 * gapY]), isCopying);
        nextShapes[clone.id] = clone;
        this.grid[position] = clone.id;
      }
    }
    Object.entries(this.grid).forEach(([position, id]) => {
      if (!inGrid.has(position)) {
        nextShapes[id] = void 0;
        delete this.grid[position];
      }
    });
    if (Object.values(nextShapes).length === 0)
      return;
    if (this.initialSiblings) {
      nextShapes[this.shape.parentId] = {
        children: [...this.initialSiblings, ...Object.values(this.grid)]
      };
    }
    return {
      document: {
        pages: {
          [currentPageId]: {
            shapes: nextShapes
          }
        },
        pageStates: {
          [currentPageId]: nextPageState
        }
      }
    };
  };
  cancel = () => {
    const { currentPageId } = this.app;
    const nextShapes = {};
    Object.values(this.grid).forEach((id) => {
      nextShapes[id] = void 0;
    });
    nextShapes[this.shape.id] = { ...nextShapes[this.shape.id], point: this.shape.point };
    if (this.initialSiblings) {
      nextShapes[this.shape.parentId] = {
        children: [...this.initialSiblings, this.shape.id]
      };
    }
    return {
      document: {
        pages: {
          [currentPageId]: {
            shapes: nextShapes
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: [this.shape.id]
          }
        }
      }
    };
  };
  complete = () => {
    const { currentPageId } = this.app;
    const beforeShapes = {};
    const afterShapes = {};
    const afterSelectedIds = [];
    Object.values(this.grid).forEach((id) => {
      beforeShapes[id] = void 0;
      afterShapes[id] = this.app.getShape(id);
      afterSelectedIds.push(id);
    });
    beforeShapes[this.shape.id] = this.shape;
    if (this.initialSiblings) {
      beforeShapes[this.shape.parentId] = {
        children: [...this.initialSiblings, this.shape.id]
      };
      afterShapes[this.shape.parentId] = {
        children: [...this.initialSiblings, ...Object.values(this.grid)]
      };
    }
    if (afterSelectedIds.length === 1)
      return;
    return {
      id: "grid",
      before: {
        document: {
          pages: {
            [currentPageId]: {
              shapes: beforeShapes
            }
          },
          pageStates: {
            [currentPageId]: {
              selectedIds: [],
              hoveredId: void 0
            }
          }
        }
      },
      after: {
        document: {
          pages: {
            [currentPageId]: {
              shapes: afterShapes
            }
          },
          pageStates: {
            [currentPageId]: {
              selectedIds: afterSelectedIds,
              hoveredId: void 0
            }
          }
        }
      }
    };
  };
  getClone = (point, copy) => {
    const clone = {
      ...this.shape,
      id: C3.uniqueId(),
      point
    };
    if (!copy && clone.type === "sticky" /* Sticky */) {
      clone.text = "";
    }
    return clone;
  };
};

// src/components/Tldraw/state/sessions/HandleSession/HandleSession.ts
var HandleSession = class extends BaseSession {
  type = "handle" /* Handle */;
  performanceMode = void 0;
  status = "translatingHandle" /* TranslatingHandle */;
  commandId;
  topLeft;
  shiftKey = false;
  initialShape;
  handleId;
  constructor(app, shapeId, handleId, commandId = "move_handle") {
    super(app);
    const { originPoint } = app;
    this.topLeft = [...originPoint];
    this.handleId = handleId;
    this.initialShape = this.app.getShape(shapeId);
    this.commandId = commandId;
  }
  start = () => void 0;
  update = () => {
    const {
      initialShape,
      app: { currentPageId, currentPoint }
    } = this;
    const shape = this.app.getShape(initialShape.id);
    if (shape.isLocked)
      return void 0;
    const handles = shape.handles;
    const handleId = this.handleId;
    const delta = e.sub(currentPoint, handles[handleId].point);
    const handleChanges = {
      [handleId]: {
        ...handles[handleId],
        point: e.sub(e.add(handles[handleId].point, delta), shape.point)
      }
    };
    const change = TLDR.getShapeUtil(shape).onHandleChange?.(shape, handleChanges);
    if (!change)
      return;
    return {
      document: {
        pages: {
          [currentPageId]: {
            shapes: {
              [shape.id]: change
            }
          }
        }
      }
    };
  };
  cancel = () => {
    const {
      initialShape,
      app: { currentPageId }
    } = this;
    return {
      document: {
        pages: {
          [currentPageId]: {
            shapes: {
              [initialShape.id]: initialShape
            }
          }
        }
      }
    };
  };
  complete = () => {
    const {
      initialShape,
      app: { currentPageId }
    } = this;
    return {
      id: this.commandId,
      before: {
        document: {
          pages: {
            [currentPageId]: {
              shapes: {
                [initialShape.id]: initialShape
              }
            }
          }
        }
      },
      after: {
        document: {
          pages: {
            [currentPageId]: {
              shapes: {
                [initialShape.id]: TLDR.onSessionComplete(this.app.getShape(this.initialShape.id))
              }
            }
          }
        }
      }
    };
  };
};

// src/components/Tldraw/state/sessions/RotateSession/RotateSession.ts
var RotateSession = class extends BaseSession {
  type = "rotate" /* Rotate */;
  status = "transforming" /* Transforming */;
  performanceMode = void 0;
  delta = [0, 0];
  commonBoundsCenter;
  initialAngle;
  initialShapes;
  changes = {};
  constructor(app) {
    super(app);
    const {
      app: { currentPageId, pageState, originPoint }
    } = this;
    const initialShapes = TLDR.getSelectedBranchSnapshot(app.state, currentPageId).filter((shape) => !shape.isLocked);
    if (initialShapes.length === 0) {
      throw new Error("No selected shapes!");
    }
    if (app.rotationInfo.selectedIds === pageState.selectedIds) {
      if (app.rotationInfo.center === void 0) {
        throw new Error("We should have a center for rotation!");
      }
      this.commonBoundsCenter = app.rotationInfo.center;
    } else {
      this.commonBoundsCenter = C3.getBoundsCenter(C3.getCommonBounds(initialShapes.map(TLDR.getBounds)));
      app.rotationInfo.selectedIds = pageState.selectedIds;
      app.rotationInfo.center = this.commonBoundsCenter;
    }
    this.initialShapes = initialShapes.filter((shape) => shape.children === void 0).map((shape) => {
      return {
        shape,
        center: this.app.getShapeUtil(shape).getCenter(shape)
      };
    });
    this.initialAngle = e.angle(this.commonBoundsCenter, originPoint);
  }
  start = () => void 0;
  update = () => {
    const {
      commonBoundsCenter,
      initialShapes,
      app: { currentPageId, currentPoint, shiftKey }
    } = this;
    const shapes = {};
    let directionDelta = e.angle(commonBoundsCenter, currentPoint) - this.initialAngle;
    if (shiftKey) {
      directionDelta = C3.snapAngleToSegments(directionDelta, 24);
    }
    initialShapes.forEach(({ center, shape }) => {
      const { rotation = 0 } = shape;
      let shapeDelta = 0;
      if (shiftKey) {
        const snappedRotation = C3.snapAngleToSegments(rotation, 24);
        shapeDelta = snappedRotation - rotation;
      }
      const change = TLDR.getRotatedShapeMutation(shape, center, commonBoundsCenter, shiftKey ? directionDelta + shapeDelta : directionDelta);
      if (change) {
        shapes[shape.id] = change;
      }
    });
    this.changes = shapes;
    return {
      document: {
        pages: {
          [currentPageId]: {
            shapes
          }
        }
      }
    };
  };
  cancel = () => {
    const {
      initialShapes,
      app: { currentPageId }
    } = this;
    const shapes = {};
    initialShapes.forEach(({ shape }) => shapes[shape.id] = shape);
    return {
      document: {
        pages: {
          [currentPageId]: {
            shapes
          }
        }
      }
    };
  };
  complete = () => {
    const {
      initialShapes,
      app: { currentPageId }
    } = this;
    const beforeShapes = {};
    const afterShapes = this.changes;
    initialShapes.forEach(({ shape: { id, point, rotation, handles } }) => {
      beforeShapes[id] = { point, rotation, handles };
    });
    return {
      id: "rotate",
      before: {
        document: {
          pages: {
            [currentPageId]: {
              shapes: beforeShapes
            }
          }
        }
      },
      after: {
        document: {
          pages: {
            [currentPageId]: {
              shapes: afterShapes
            }
          }
        }
      }
    };
  };
};

// src/components/Tldraw/state/sessions/TransformSession/TransformSession.ts
var TransformSession = class extends BaseSession {
  constructor(app, transformType = He.BottomRight, isCreate = false) {
    super(app);
    this.transformType = transformType;
    this.isCreate = isCreate;
    this.initialSelectedIds = [...this.app.selectedIds];
    this.app.rotationInfo.selectedIds = [...this.initialSelectedIds];
    this.initialShapes = TLDR.getSelectedBranchSnapshot(this.app.state, this.app.currentPageId).filter((shape) => !shape.isLocked);
    this.initialShapeIds = this.initialShapes.map((shape) => shape.id);
    this.hasUnlockedShapes = this.initialShapes.length > 0;
    this.isAllAspectRatioLocked = this.initialShapes.every((shape) => shape.isAspectRatioLocked || TLDR.getShapeUtil(shape).isAspectRatioLocked);
    const shapesBounds = Object.fromEntries(this.initialShapes.map((shape) => [shape.id, TLDR.getBounds(shape)]));
    const boundsArr = Object.values(shapesBounds);
    this.initialCommonBounds = C3.getCommonBounds(boundsArr);
    const initialInnerBounds = C3.getBoundsFromPoints(boundsArr.map(C3.getBoundsCenter));
    this.shapeBounds = this.initialShapes.map((shape) => {
      const initialShapeBounds = shapesBounds[shape.id];
      const ic = C3.getBoundsCenter(initialShapeBounds);
      const ix = (ic[0] - initialInnerBounds.minX) / initialInnerBounds.width;
      const iy = (ic[1] - initialInnerBounds.minY) / initialInnerBounds.height;
      return {
        initialShape: shape,
        initialShapeBounds,
        transformOrigin: [ix, iy]
      };
    });
  }
  type = "transform" /* Transform */;
  performanceMode = void 0;
  status = "transforming" /* Transforming */;
  scaleX = 1;
  scaleY = 1;
  initialShapes;
  initialShapeIds;
  initialSelectedIds;
  shapeBounds;
  hasUnlockedShapes;
  isAllAspectRatioLocked;
  initialCommonBounds;
  snapInfo = { state: "empty" };
  prevPoint = [0, 0];
  speed = 1;
  start = () => {
    this.snapInfo = {
      state: "ready",
      bounds: this.app.shapes.filter((shape) => !this.initialShapeIds.includes(shape.id)).map((shape) => C3.getBoundsWithCenter(TLDR.getRotatedBounds(shape)))
    };
    return void 0;
  };
  update = () => {
    const {
      transformType,
      shapeBounds,
      initialCommonBounds,
      isAllAspectRatioLocked,
      app: {
        currentPageId,
        pageState: { camera },
        viewport,
        currentPoint,
        previousPoint,
        originPoint,
        shiftKey,
        altKey,
        metaKey,
        currentGrid,
        settings: { isSnapping, showGrid }
      }
    } = this;
    const shapes = {};
    const delta = altKey ? e.mul(e.sub(currentPoint, originPoint), 2) : e.sub(currentPoint, originPoint);
    let newBounds = C3.getTransformedBoundingBox(initialCommonBounds, transformType, delta, 0, shiftKey || isAllAspectRatioLocked);
    if (altKey) {
      newBounds = {
        ...newBounds,
        ...C3.centerBounds(newBounds, C3.getBoundsCenter(initialCommonBounds))
      };
    }
    if (showGrid) {
      newBounds = {
        ...newBounds,
        ...C3.snapBoundsToGrid(newBounds, currentGrid)
      };
    }
    const speed = e.dist(currentPoint, previousPoint);
    const speedChange = speed - this.speed;
    this.speed = this.speed + speedChange * (speedChange > 1 ? 0.5 : 0.15);
    let snapLines = [];
    if ((isSnapping && !metaKey || !isSnapping && metaKey) && this.speed * camera.zoom < SLOW_SPEED && this.snapInfo.state === "ready") {
      const snapResult = C3.getSnapPoints(
        C3.getBoundsWithCenter(newBounds),
        this.snapInfo.bounds.filter((bounds) => C3.boundsContain(viewport, bounds) || C3.boundsCollide(viewport, bounds)),
        SNAP_DISTANCE / camera.zoom
      );
      if (snapResult) {
        snapLines = snapResult.snapLines;
        newBounds = C3.getTransformedBoundingBox(
          initialCommonBounds,
          transformType,
          e.sub(delta, snapResult.offset),
          0,
          shiftKey || isAllAspectRatioLocked
        );
      }
    }
    this.scaleX = newBounds.scaleX;
    this.scaleY = newBounds.scaleY;
    shapeBounds.forEach(({ initialShape, initialShapeBounds, transformOrigin }) => {
      let newShapeBounds = C3.getRelativeTransformedBoundingBox(newBounds, initialCommonBounds, initialShapeBounds, this.scaleX < 0, this.scaleY < 0);
      if (showGrid) {
        newShapeBounds = C3.snapBoundsToGrid(newShapeBounds, currentGrid);
      }
      const afterShape = TLDR.transform(this.app.getShape(initialShape.id), newShapeBounds, {
        type: this.transformType,
        initialShape,
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        transformOrigin
      });
      shapes[initialShape.id] = afterShape;
    });
    return {
      appState: {
        snapLines
      },
      document: {
        pages: {
          [currentPageId]: {
            shapes
          }
        }
      }
    };
  };
  cancel = () => {
    const {
      shapeBounds,
      app: { currentPageId }
    } = this;
    const shapes = {};
    if (this.isCreate) {
      shapeBounds.forEach((shape) => shapes[shape.initialShape.id] = void 0);
    } else {
      shapeBounds.forEach((shape) => shapes[shape.initialShape.id] = shape.initialShape);
    }
    return {
      appState: {
        snapLines: []
      },
      document: {
        pages: {
          [currentPageId]: {
            shapes
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: this.isCreate ? [] : shapeBounds.map((shape) => shape.initialShape.id)
          }
        }
      }
    };
  };
  complete = () => {
    const {
      isCreate,
      shapeBounds,
      hasUnlockedShapes,
      app: { currentPageId }
    } = this;
    if (!hasUnlockedShapes)
      return;
    if (this.isCreate && e.dist(this.app.originPoint, this.app.currentPoint) < 2) {
      return this.cancel();
    }
    const beforeShapes = {};
    const afterShapes = {};
    let beforeSelectedIds;
    let afterSelectedIds;
    if (isCreate) {
      beforeSelectedIds = [];
      afterSelectedIds = [];
      shapeBounds.forEach(({ initialShape }) => {
        beforeShapes[initialShape.id] = void 0;
        afterShapes[initialShape.id] = this.app.getShape(initialShape.id);
      });
    } else {
      beforeSelectedIds = this.initialSelectedIds;
      afterSelectedIds = this.initialSelectedIds;
      shapeBounds.forEach(({ initialShape }) => {
        beforeShapes[initialShape.id] = initialShape;
        afterShapes[initialShape.id] = this.app.getShape(initialShape.id);
      });
    }
    return {
      id: "transform",
      before: {
        appState: {
          snapLines: []
        },
        document: {
          pages: {
            [currentPageId]: {
              shapes: beforeShapes
            }
          },
          pageStates: {
            [currentPageId]: {
              selectedIds: beforeSelectedIds,
              hoveredId: void 0,
              editingId: void 0
            }
          }
        }
      },
      after: {
        appState: {
          snapLines: []
        },
        document: {
          pages: {
            [currentPageId]: {
              shapes: afterShapes
            }
          },
          pageStates: {
            [currentPageId]: {
              selectedIds: afterSelectedIds,
              hoveredId: void 0,
              editingId: void 0
            }
          }
        }
      }
    };
  };
};

// src/components/Tldraw/state/sessions/TransformSingleSession/TransformSingleSession.ts
var TransformSingleSession = class extends BaseSession {
  type = "transformSingle" /* TransformSingle */;
  status = "transforming" /* Transforming */;
  performanceMode = void 0;
  transformType;
  scaleX = 1;
  scaleY = 1;
  isCreate;
  initialShape;
  initialShapeBounds;
  initialCommonBounds;
  snapInfo = { state: "empty" };
  prevPoint = [0, 0];
  speed = 1;
  constructor(app, id, transformType, isCreate = false) {
    super(app);
    this.isCreate = isCreate;
    this.transformType = transformType;
    const shape = this.app.getShape(id);
    this.initialShape = shape;
    this.initialShapeBounds = TLDR.getBounds(shape);
    this.initialCommonBounds = TLDR.getRotatedBounds(shape);
    this.app.rotationInfo.selectedIds = [shape.id];
  }
  start = () => {
    this.snapInfo = {
      state: "ready",
      bounds: this.app.shapes.filter((shape) => shape.id !== this.initialShape.id).map((shape) => C3.getBoundsWithCenter(TLDR.getRotatedBounds(shape)))
    };
    return void 0;
  };
  update = () => {
    const {
      transformType,
      initialShape,
      initialShapeBounds,
      app: {
        settings: { isSnapping, showGrid },
        currentPageId,
        pageState: { camera },
        viewport,
        currentPoint,
        previousPoint,
        originPoint,
        currentGrid,
        shiftKey,
        altKey,
        metaKey
      }
    } = this;
    if (initialShape.isLocked)
      return void 0;
    const shapes = {};
    const delta = altKey ? e.mul(e.sub(currentPoint, originPoint), 2) : e.sub(currentPoint, originPoint);
    const shape = this.app.getShape(initialShape.id);
    const utils = TLDR.getShapeUtil(shape);
    let newBounds = C3.getTransformedBoundingBox(
      initialShapeBounds,
      transformType,
      delta,
      shape.rotation,
      shiftKey || shape.isAspectRatioLocked || utils.isAspectRatioLocked
    );
    if (altKey) {
      newBounds = {
        ...newBounds,
        ...C3.centerBounds(newBounds, C3.getBoundsCenter(initialShapeBounds))
      };
    }
    if (showGrid) {
      newBounds = {
        ...newBounds,
        ...C3.snapBoundsToGrid(newBounds, currentGrid)
      };
    }
    const speed = e.dist(currentPoint, previousPoint);
    const speedChange = speed - this.speed;
    this.speed = this.speed + speedChange * (speedChange > 1 ? 0.5 : 0.15);
    let snapLines = [];
    if ((isSnapping && !metaKey || !isSnapping && metaKey) && !initialShape.rotation && // not now anyway
    this.speed * camera.zoom < SLOW_SPEED && this.snapInfo.state === "ready") {
      const snapResult = C3.getSnapPoints(
        C3.getBoundsWithCenter(newBounds),
        this.snapInfo.bounds.filter((bounds) => C3.boundsContain(viewport, bounds) || C3.boundsCollide(viewport, bounds)),
        SNAP_DISTANCE / camera.zoom
      );
      if (snapResult) {
        snapLines = snapResult.snapLines;
        newBounds = C3.getTransformedBoundingBox(
          initialShapeBounds,
          transformType,
          e.sub(delta, snapResult.offset),
          shape.rotation,
          shiftKey || shape.isAspectRatioLocked || utils.isAspectRatioLocked
        );
      }
    }
    const afterShape = TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {
      initialShape,
      type: this.transformType,
      scaleX: newBounds.scaleX,
      scaleY: newBounds.scaleY,
      transformOrigin: [0.5, 0.5]
    });
    if (afterShape) {
      shapes[shape.id] = afterShape;
    }
    if (showGrid && afterShape && afterShape.point) {
      afterShape.point = e.snap(afterShape.point, currentGrid);
    }
    return {
      appState: {
        snapLines
      },
      document: {
        pages: {
          [currentPageId]: {
            shapes
          }
        }
      }
    };
  };
  cancel = () => {
    const {
      initialShape,
      app: { currentPageId }
    } = this;
    const shapes = {};
    if (this.isCreate) {
      shapes[initialShape.id] = void 0;
    } else {
      shapes[initialShape.id] = initialShape;
    }
    return {
      appState: {
        snapLines: []
      },
      document: {
        pages: {
          [currentPageId]: {
            shapes
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: this.isCreate ? [] : [initialShape.id]
          }
        }
      }
    };
  };
  complete = () => {
    const {
      initialShape,
      app: { currentPageId }
    } = this;
    if (initialShape.isLocked)
      return;
    if (this.isCreate && e.dist(this.app.originPoint, this.app.currentPoint) < 2) {
      return this.cancel();
    }
    const beforeShapes = {};
    const afterShapes = {};
    beforeShapes[initialShape.id] = this.isCreate ? void 0 : initialShape;
    afterShapes[initialShape.id] = TLDR.onSessionComplete(this.app.getShape(initialShape.id));
    return {
      id: "transform_single",
      before: {
        appState: {
          snapLines: []
        },
        document: {
          pages: {
            [currentPageId]: {
              shapes: beforeShapes
            }
          },
          pageStates: {
            [currentPageId]: {
              selectedIds: this.isCreate ? [] : [initialShape.id],
              editingId: void 0,
              hoveredId: void 0
            }
          }
        }
      },
      after: {
        appState: {
          snapLines: []
        },
        document: {
          pages: {
            [currentPageId]: {
              shapes: afterShapes
            }
          },
          pageStates: {
            [currentPageId]: {
              selectedIds: [initialShape.id],
              editingId: void 0,
              hoveredId: void 0
            }
          }
        }
      }
    };
  };
};

// src/components/Tldraw/state/sessions/TranslateSession/TranslateSession.ts
var TranslateSession = class extends BaseSession {
  performanceMode = void 0;
  type = "translate" /* Translate */;
  status = "translating" /* Translating */;
  delta = [0, 0];
  prev = [0, 0];
  prevPoint = [0, 0];
  speed = 1;
  cloneInfo = {
    state: "empty"
  };
  snapInfo = {
    state: "empty"
  };
  snapLines = [];
  isCloning = false;
  isCreate;
  link;
  initialIds;
  hasUnlockedShapes;
  initialSelectedIds;
  initialCommonBounds;
  initialShapes;
  initialParentChildren;
  bindingsToDelete;
  constructor(app, isCreate = false, link = false) {
    super(app);
    this.isCreate = isCreate;
    this.link = link;
    const { currentPageId, selectedIds, page } = this.app;
    this.initialSelectedIds = [...selectedIds];
    const selectedShapes = (link ? TLDR.getLinkedShapeIds(this.app.state, currentPageId, link, false) : selectedIds).map((id) => this.app.getShape(id)).filter((shape) => !shape.isLocked);
    const selectedShapeIds = new Set(selectedShapes.map((shape) => shape.id));
    this.hasUnlockedShapes = selectedShapes.length > 0;
    this.initialShapes = [
      ...new Set(
        selectedShapes.filter((shape) => !selectedShapeIds.has(shape.parentId)).flatMap((shape) => {
          return shape.children ? [shape, ...shape.children.map((childId) => this.app.getShape(childId))] : [shape];
        })
      ).values()
    ];
    this.initialIds = new Set(this.initialShapes.map((shape) => shape.id));
    this.bindingsToDelete = [];
    Object.values(page.bindings).filter((binding) => this.initialIds.has(binding.fromId) || this.initialIds.has(binding.toId)).forEach((binding) => {
      if (this.initialIds.has(binding.fromId) && !this.initialIds.has(binding.toId)) {
        this.bindingsToDelete.push(binding);
      }
    });
    this.initialParentChildren = {};
    this.initialShapes.map((s5) => s5.parentId).filter((id) => id !== page.id).forEach((id) => {
      this.initialParentChildren[id] = this.app.getShape(id).children;
    });
    this.initialCommonBounds = C3.getCommonBounds(this.initialShapes.map(TLDR.getRotatedBounds));
    this.app.rotationInfo.selectedIds = [...this.app.selectedIds];
  }
  start = () => {
    const {
      bindingsToDelete,
      initialIds,
      app: { currentPageId, page }
    } = this;
    const allBounds = [];
    const otherBounds = [];
    Object.values(page.shapes).forEach((shape) => {
      const bounds = C3.getBoundsWithCenter(TLDR.getRotatedBounds(shape));
      allBounds.push(bounds);
      if (!initialIds.has(shape.id)) {
        otherBounds.push(bounds);
      }
    });
    this.snapInfo = {
      state: "ready",
      bounds: allBounds,
      others: otherBounds
    };
    if (bindingsToDelete.length === 0)
      return;
    const nextBindings = {};
    const nextShapes = {};
    bindingsToDelete.forEach((binding) => {
      nextBindings[binding.id] = void 0;
      const fromShape = this.app.getShape(binding.fromId);
      nextShapes[binding.fromId] = {
        handles: {
          ...fromShape.handles,
          [binding.handleId]: {
            // @ts-expect-error
            ...fromShape.handles[binding.handleId],
            bindingId: void 0
          }
        }
      };
    });
    return {
      document: {
        pages: {
          [currentPageId]: {
            bindings: nextBindings,
            shapes: nextShapes
          }
        }
      }
    };
  };
  update = () => {
    const {
      initialParentChildren,
      initialShapes,
      initialCommonBounds,
      bindingsToDelete,
      app: {
        pageState: { camera },
        settings: { isSnapping, showGrid },
        currentPageId,
        viewport,
        selectedIds,
        currentPoint,
        previousPoint,
        originPoint,
        altKey,
        shiftKey,
        metaKey,
        currentGrid
      }
    } = this;
    const nextBindings = {};
    const nextShapes = {};
    const nextPageState = {};
    let delta = e.sub(currentPoint, originPoint);
    let didChangeCloning = false;
    if (!this.isCreate) {
      if (altKey && !this.isCloning) {
        this.isCloning = true;
        didChangeCloning = true;
      } else if (!altKey && this.isCloning) {
        this.isCloning = false;
        didChangeCloning = true;
      }
    }
    if (shiftKey) {
      if (Math.abs(delta[0]) < Math.abs(delta[1])) {
        delta[0] = 0;
      } else {
        delta[1] = 0;
      }
    }
    const speed = e.dist(currentPoint, previousPoint);
    const change = speed - this.speed;
    this.speed = this.speed + change * (change > 1 ? 0.5 : 0.15);
    this.snapLines = [];
    if ((isSnapping && !metaKey || !isSnapping && metaKey) && this.speed * camera.zoom < SLOW_SPEED && this.snapInfo.state === "ready") {
      const snapResult = C3.getSnapPoints(
        C3.getBoundsWithCenter(
          showGrid ? C3.snapBoundsToGrid(C3.translateBounds(initialCommonBounds, delta), currentGrid) : C3.translateBounds(initialCommonBounds, delta)
        ),
        (this.isCloning ? this.snapInfo.bounds : this.snapInfo.others).filter((bounds) => {
          return C3.boundsContain(viewport, bounds) || C3.boundsCollide(viewport, bounds);
        }),
        SNAP_DISTANCE / camera.zoom
      );
      if (snapResult) {
        this.snapLines = snapResult.snapLines;
        delta = e.sub(delta, snapResult.offset);
      }
    }
    this.prev = delta;
    if (this.isCloning) {
      if (didChangeCloning) {
        if (this.cloneInfo.state === "empty") {
          this.createCloneInfo();
        }
        if (this.cloneInfo.state === "empty") {
          throw Error;
        }
        const { clones, clonedBindings } = this.cloneInfo;
        this.isCloning = true;
        bindingsToDelete.forEach((binding) => nextBindings[binding.id] = binding);
        initialShapes.forEach((shape) => nextShapes[shape.id] = { point: shape.point });
        clones.forEach((clone) => {
          nextShapes[clone.id] = { ...clone };
          if (clone.parentId !== currentPageId && !selectedIds.includes(clone.parentId)) {
            const children = nextShapes[clone.parentId]?.children || initialParentChildren[clone.parentId];
            if (!children.includes(clone.id)) {
              nextShapes[clone.parentId] = {
                ...nextShapes[clone.parentId],
                children: [...children, clone.id]
              };
            }
          }
        });
        for (const binding of clonedBindings) {
          nextBindings[binding.id] = binding;
        }
        nextPageState.selectedIds = clones.map((clone) => clone.id);
        clones.forEach((clone) => {
          nextShapes[clone.id] = {
            ...clone,
            point: showGrid ? e.snap(e.toFixed(e.add(clone.point, delta)), currentGrid) : e.toFixed(e.add(clone.point, delta))
          };
        });
      } else {
        if (this.cloneInfo.state === "empty")
          throw Error;
        const { clones } = this.cloneInfo;
        clones.forEach((clone) => {
          nextShapes[clone.id] = {
            point: showGrid ? e.snap(e.toFixed(e.add(clone.point, delta)), currentGrid) : e.toFixed(e.add(clone.point, delta))
          };
        });
      }
    } else {
      if (didChangeCloning) {
        if (this.cloneInfo.state === "empty")
          throw Error;
        const { clones, clonedBindings } = this.cloneInfo;
        this.isCloning = false;
        bindingsToDelete.forEach((binding) => nextBindings[binding.id] = void 0);
        clones.forEach((clone) => {
          if (clone.parentId !== currentPageId) {
            nextShapes[clone.parentId] = {
              ...nextShapes[clone.parentId],
              children: initialParentChildren[clone.parentId]
            };
          }
        });
        clones.forEach((clone) => nextShapes[clone.id] = void 0);
        initialShapes.forEach((shape) => {
          nextShapes[shape.id] = {
            point: showGrid ? e.snap(e.toFixed(e.add(shape.point, delta)), currentGrid) : e.toFixed(e.add(shape.point, delta))
          };
        });
        for (const binding of clonedBindings) {
          nextBindings[binding.id] = void 0;
        }
        nextPageState.selectedIds = initialShapes.map((shape) => shape.id);
      } else {
        initialShapes.forEach((shape) => {
          nextShapes[shape.id] = {
            point: showGrid ? e.snap(e.toFixed(e.add(shape.point, delta)), currentGrid) : e.toFixed(e.add(shape.point, delta))
          };
        });
      }
    }
    return {
      appState: {
        snapLines: this.snapLines
      },
      document: {
        pages: {
          [currentPageId]: {
            shapes: nextShapes,
            bindings: nextBindings
          }
        },
        pageStates: {
          [currentPageId]: nextPageState
        }
      }
    };
  };
  cancel = () => {
    const {
      initialShapes,
      initialSelectedIds,
      bindingsToDelete,
      app: { currentPageId }
    } = this;
    const nextBindings = {};
    const nextShapes = {};
    const nextPageState = {
      editingId: void 0,
      hoveredId: void 0
    };
    if (this.isCreate) {
      initialShapes.forEach(({ id }) => nextShapes[id] = void 0);
      nextPageState.selectedIds = [];
    } else {
      initialShapes.forEach(
        ({ id, point, handles }) => nextShapes[id] = handles ? { ...nextShapes[id], point, handles } : { ...nextShapes[id], point }
      );
      nextPageState.selectedIds = initialSelectedIds;
      bindingsToDelete.forEach((binding) => {
        nextBindings[binding.id] = binding;
      });
    }
    if (this.cloneInfo.state === "ready") {
      const { clones, clonedBindings } = this.cloneInfo;
      clones.forEach((clone) => nextShapes[clone.id] = void 0);
      clonedBindings.forEach((binding) => nextBindings[binding.id] = void 0);
    }
    return {
      appState: {
        snapLines: []
      },
      document: {
        pages: {
          [currentPageId]: {
            shapes: nextShapes,
            bindings: nextBindings
          }
        },
        pageStates: {
          [currentPageId]: nextPageState
        }
      }
    };
  };
  complete = () => {
    const {
      initialShapes,
      initialParentChildren,
      bindingsToDelete,
      app: { currentPageId }
    } = this;
    const beforeBindings = {};
    const beforeShapes = {};
    const afterBindings = {};
    const afterShapes = {};
    if (this.isCloning) {
      if (this.cloneInfo.state === "empty") {
        this.createCloneInfo();
      }
      if (this.cloneInfo.state !== "ready")
        throw Error;
      const { clones, clonedBindings } = this.cloneInfo;
      clones.forEach((clone) => {
        beforeShapes[clone.id] = void 0;
        afterShapes[clone.id] = this.app.getShape(clone.id);
        if (clone.parentId !== currentPageId) {
          beforeShapes[clone.parentId] = {
            ...beforeShapes[clone.parentId],
            children: initialParentChildren[clone.parentId]
          };
          afterShapes[clone.parentId] = {
            ...afterShapes[clone.parentId],
            children: this.app.getShape(clone.parentId).children
          };
        }
      });
      clonedBindings.forEach((binding) => {
        beforeBindings[binding.id] = void 0;
        afterBindings[binding.id] = this.app.getBinding(binding.id);
      });
    } else {
      initialShapes.forEach((shape) => {
        beforeShapes[shape.id] = this.isCreate ? void 0 : {
          ...beforeShapes[shape.id],
          point: shape.point
        };
        afterShapes[shape.id] = {
          ...afterShapes[shape.id],
          ...this.isCreate ? this.app.getShape(shape.id) : { point: this.app.getShape(shape.id).point }
        };
      });
    }
    bindingsToDelete.forEach((binding) => {
      beforeBindings[binding.id] = binding;
      beforeShapes[binding.fromId] = {
        ...beforeShapes[binding.fromId],
        id: binding.fromId,
        handles: {
          ...beforeShapes[binding.fromId]?.handles,
          [binding.handleId]: {
            ...beforeShapes[binding.fromId]?.handles?.[binding.handleId],
            bindingId: binding.id
          }
        }
      };
      afterShapes[binding.fromId] = {
        ...afterShapes[binding.fromId],
        id: binding.fromId,
        handles: {
          // @ts-expect-error
          ...afterShapes[binding.fromId].handles,
          [binding.handleId]: {
            ...afterShapes[binding.fromId]?.handles?.[binding.handleId],
            bindingId: void 0
          }
        }
      };
    });
    bindingsToDelete.forEach((binding) => afterBindings[binding.id] = void 0);
    return {
      id: "translate",
      before: {
        appState: {
          snapLines: []
        },
        document: {
          pages: {
            [currentPageId]: {
              shapes: beforeShapes,
              bindings: beforeBindings
            }
          },
          pageStates: {
            [currentPageId]: {
              selectedIds: this.isCreate ? [] : [...this.initialSelectedIds]
            }
          }
        }
      },
      after: {
        appState: {
          snapLines: []
        },
        document: {
          pages: {
            [currentPageId]: {
              shapes: afterShapes,
              bindings: afterBindings
            }
          },
          pageStates: {
            [currentPageId]: {
              selectedIds: [...this.app.selectedIds]
            }
          }
        }
      }
    };
  };
  createCloneInfo = () => {
    const {
      initialShapes,
      initialParentChildren,
      app: { selectedIds, currentPageId, page }
    } = this;
    const cloneMap = {};
    const clonedBindingsMap = {};
    const clonedBindings = [];
    const clones = [];
    initialShapes.forEach((shape) => {
      const newId = C3.uniqueId();
      initialParentChildren[newId] = initialParentChildren[shape.id];
      cloneMap[shape.id] = newId;
      const clone = {
        ...C3.deepClone(shape),
        id: newId,
        parentId: shape.parentId,
        childIndex: TLDR.getChildIndexAbove(this.app.state, shape.id, currentPageId)
      };
      clones.push(clone);
    });
    clones.forEach((clone) => {
      if (clone.children !== void 0) {
        clone.children = clone.children.map((childId) => cloneMap[childId]);
      }
    });
    clones.forEach((clone) => {
      if (selectedIds.includes(clone.parentId)) {
        clone.parentId = cloneMap[clone.parentId];
      }
    });
    const clonedShapeIds = new Set(Object.keys(cloneMap));
    Object.values(page.bindings).filter((binding) => clonedShapeIds.has(binding.fromId) || clonedShapeIds.has(binding.toId)).forEach((binding) => {
      if (clonedShapeIds.has(binding.fromId) && clonedShapeIds.has(binding.toId)) {
        const cloneId = C3.uniqueId();
        const cloneBinding = {
          ...C3.deepClone(binding),
          id: cloneId,
          fromId: cloneMap[binding.fromId] || binding.fromId,
          toId: cloneMap[binding.toId] || binding.toId
        };
        clonedBindingsMap[binding.id] = cloneId;
        clonedBindings.push(cloneBinding);
      }
    });
    clones.forEach((clone) => {
      if (clone.handles && clone.handles) {
        for (const id in clone.handles) {
          const handle = clone.handles[id];
          handle.bindingId = handle.bindingId ? clonedBindingsMap[handle.bindingId] : void 0;
        }
      }
    });
    clones.forEach((clone) => {
      if (page.shapes[clone.id]) {
        throw new Error("uh oh, we didn't clone correctly");
      }
    });
    this.cloneInfo = {
      state: "ready",
      clones,
      cloneMap,
      clonedBindings
    };
  };
};

// src/components/Tldraw/state/sessions/index.ts
var sessions = {
  ["arrow" /* Arrow */]: ArrowSession,
  ["brush" /* Brush */]: BrushSession,
  ["draw" /* Draw */]: DrawSession,
  ["erase" /* Erase */]: EraseSession,
  ["handle" /* Handle */]: HandleSession,
  ["rotate" /* Rotate */]: RotateSession,
  ["transform" /* Transform */]: TransformSession,
  ["transformSingle" /* TransformSingle */]: TransformSingleSession,
  ["translate" /* Translate */]: TranslateSession,
  ["grid" /* Grid */]: GridSession,
  ["edit" /* Edit */]: EditSession
};
var getSession = (type) => {
  return sessions[type];
};

// src/components/Tldraw/state/tools/BaseTool.ts
var BaseTool = class extends TDEventHandler {
  constructor(app) {
    super();
    this.app = app;
  }
  type = "select";
  previous;
  status = "idle" /* Idle */;
  setStatus = (status) => {
    this.status = status;
    this.app.setStatus(this.status);
  };
  onEnter = () => {
    this.setStatus("idle" /* Idle */);
  };
  onExit = () => {
    this.setStatus("idle" /* Idle */);
  };
  onCancel = () => {
    if (this.status === "idle" /* Idle */) {
      this.app.selectTool("select");
    } else {
      this.setStatus("idle" /* Idle */);
    }
    this.app.cancelSession();
  };
  getNextChildIndex = () => {
    const {
      shapes,
      appState: { currentPageId }
    } = this.app;
    return shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === currentPageId).sort((a7, b6) => b6.childIndex - a7.childIndex)[0].childIndex + 1;
  };
  /* --------------------- Camera --------------------- */
  onPinchStart = () => {
    this.app.cancelSession();
    this.setStatus("pinching" /* Pinching */);
  };
  onPinchEnd = () => {
    if (C3.isMobileSafari()) {
      this.app.undoSelect();
    }
    this.setStatus("idle" /* Idle */);
  };
  onPinch = (info, e5) => {
    if (this.status !== "pinching")
      return;
    if (isNaN(info.delta[0]) || isNaN(info.delta[1]))
      return;
    this.app.pinchZoom(info.point, info.delta, info.delta[2]);
    this.onPointerMove?.(info, e5);
  };
  /* ---------------------- Keys ---------------------- */
  onKeyDown = (key) => {
    if (key === "Escape") {
      this.onCancel();
      return;
    }
    if (key === "Meta" || key === "Control" || key === "Alt") {
      this.app.updateSession();
    }
  };
  onKeyUp = (key) => {
    if (key === "Meta" || key === "Control" || key === "Alt") {
      this.app.updateSession();
    }
  };
  /* --------------------- Pointer -------------------- */
  onPointerMove = () => {
    if (this.status === "creating" /* Creating */) {
      this.app.updateSession();
    }
  };
  onPointerUp = () => {
    if (this.status === "creating" /* Creating */) {
      this.app.completeSession();
      const { isToolLocked } = this.app.appState;
      if (!isToolLocked) {
        this.app.selectTool("select");
      }
    }
    this.setStatus("idle" /* Idle */);
  };
};

// src/components/Tldraw/state/tools/ArrowTool/ArrowTool.ts
var ArrowTool = class extends BaseTool {
  type = "arrow" /* Arrow */;
  /* ----------------- Event Handlers ----------------- */
  onPointerDown = () => {
    if (this.status !== "idle" /* Idle */)
      return;
    const {
      currentPoint,
      currentGrid,
      settings: { showGrid },
      appState: { currentPageId, currentStyle }
    } = this.app;
    const childIndex = this.getNextChildIndex();
    const id = C3.uniqueId();
    const newShape = Arrow.create({
      id,
      parentId: currentPageId,
      childIndex,
      point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,
      style: { ...currentStyle }
    });
    this.app.patchCreate([newShape]);
    this.app.startSession("arrow" /* Arrow */, newShape.id, "end", true);
    this.setStatus("creating" /* Creating */);
  };
};

// src/components/Tldraw/state/tools/DrawTool/DrawTool.ts
var DrawTool = class extends BaseTool {
  type = "draw" /* Draw */;
  lastShapeId;
  onEnter = () => {
    this.lastShapeId = void 0;
  };
  onCancel = () => {
    switch (this.status) {
      case "idle" /* Idle */: {
        this.app.selectTool("select");
        break;
      }
      default: {
        this.setStatus("idle" /* Idle */);
        break;
      }
    }
    this.app.cancelSession();
  };
  /* ----------------- Event Handlers ----------------- */
  onPointerDown = (info) => {
    if (this.status !== "idle" /* Idle */)
      return;
    if (this.app.readOnly)
      return;
    const {
      currentPoint,
      appState: { currentPageId, currentStyle }
    } = this.app;
    const previous = this.lastShapeId && this.app.getShape(this.lastShapeId);
    if (info.shiftKey && previous) {
      this.app.startSession("draw" /* Draw */, previous.id);
      this.setStatus("extending" /* Extending */);
    } else {
      const childIndex = this.getNextChildIndex();
      const id = C3.uniqueId();
      const newShape = Draw.create({
        id,
        parentId: currentPageId,
        childIndex,
        point: currentPoint,
        style: { ...currentStyle }
      });
      this.lastShapeId = id;
      this.app.patchCreate([newShape]);
      this.app.startSession("draw" /* Draw */, id);
      this.setStatus("creating" /* Creating */);
    }
  };
  onPointerMove = () => {
    if (this.app.readOnly)
      return;
    switch (this.status) {
      case "extending" /* Extending */:
      case "creating" /* Creating */: {
        this.app.updateSession();
      }
    }
  };
  onPointerUp = () => {
    this.app.completeSession();
    this.setStatus("idle" /* Idle */);
  };
};

// src/components/Tldraw/state/tools/EllipseTool/EllipseTool.ts
var EllipseTool = class extends BaseTool {
  type = "ellipse" /* Ellipse */;
  /* ----------------- Event Handlers ----------------- */
  onPointerDown = () => {
    if (this.app.readOnly)
      return;
    if (this.status !== "idle" /* Idle */)
      return;
    const {
      currentPoint,
      currentGrid,
      settings: { showGrid },
      appState: { currentPageId, currentStyle }
    } = this.app;
    const childIndex = this.getNextChildIndex();
    const id = C3.uniqueId();
    const newShape = Ellipse.create({
      id,
      parentId: currentPageId,
      childIndex,
      point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,
      style: { ...currentStyle }
    });
    this.app.patchCreate([newShape]);
    this.app.startSession("transformSingle" /* TransformSingle */, newShape.id, He.BottomRight, true);
    this.setStatus("creating" /* Creating */);
  };
};

// src/components/Tldraw/state/tools/EraseTool/EraseTool.ts
var EraseTool = class extends BaseTool {
  type = "erase";
  status = "idle" /* Idle */;
  /* ----------------- Event Handlers ----------------- */
  onPointerDown = () => {
    if (this.app.readOnly)
      return;
    if (this.status !== "idle" /* Idle */)
      return;
    this.setStatus("pointing" /* Pointing */);
  };
  onPointerMove = (info) => {
    if (this.app.readOnly)
      return;
    switch (this.status) {
      case "pointing" /* Pointing */: {
        if (p.dist(info.origin, info.point) > DEAD_ZONE) {
          this.app.startSession("erase" /* Erase */);
          this.app.updateSession();
          this.setStatus("erasing" /* Erasing */);
        }
        break;
      }
      case "erasing" /* Erasing */: {
        this.app.updateSession();
      }
    }
  };
  onPointerUp = () => {
    if (this.app.readOnly)
      return;
    switch (this.status) {
      case "pointing" /* Pointing */: {
        const shapeIdsAtPoint = this.app.shapes.filter((shape) => !shape.isLocked).filter((shape) => this.app.getShapeUtil(shape).hitTestPoint(shape, this.app.currentPoint)).flatMap((shape) => shape.children ? [shape.id, ...shape.children] : shape.id);
        this.app.delete(shapeIdsAtPoint);
        break;
      }
      case "erasing" /* Erasing */: {
        this.app.completeSession();
      }
    }
    this.setStatus("idle" /* Idle */);
  };
  onCancel = () => {
    if (this.status === "idle" /* Idle */) {
      if (this.previous) {
        this.app.selectTool(this.previous);
      } else {
        this.app.selectTool("select");
      }
    } else {
      this.setStatus("idle" /* Idle */);
    }
    this.app.cancelSession();
  };
};

// src/components/Tldraw/state/tools/LineTool/LineTool.ts
var LineTool = class extends BaseTool {
  type = "line" /* Line */;
  /* ----------------- Event Handlers ----------------- */
  onPointerDown = () => {
    if (this.app.readOnly)
      return;
    if (this.status !== "idle" /* Idle */)
      return;
    const {
      currentPoint,
      currentGrid,
      settings: { showGrid },
      appState: { currentPageId, currentStyle }
    } = this.app;
    const childIndex = this.getNextChildIndex();
    const id = C3.uniqueId();
    const newShape = Arrow.create({
      id,
      parentId: currentPageId,
      childIndex,
      point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,
      decorations: {
        start: void 0,
        end: void 0
      },
      style: { ...currentStyle }
    });
    this.app.patchCreate([newShape]);
    this.app.startSession("arrow" /* Arrow */, newShape.id, "end", true);
    this.setStatus("creating" /* Creating */);
  };
};

// src/components/Tldraw/state/tools/RectangleTool/RectangleTool.ts
var RectangleTool = class extends BaseTool {
  type = "rectangle" /* Rectangle */;
  /* ----------------- Event Handlers ----------------- */
  onPointerDown = () => {
    if (this.app.readOnly)
      return;
    if (this.status !== "idle" /* Idle */)
      return;
    const {
      currentPoint,
      currentGrid,
      settings: { showGrid },
      appState: { currentPageId, currentStyle }
    } = this.app;
    const childIndex = this.getNextChildIndex();
    const id = C3.uniqueId();
    const newShape = Rectangle.create({
      id,
      parentId: currentPageId,
      childIndex,
      point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,
      style: { ...currentStyle }
    });
    this.app.patchCreate([newShape]);
    this.app.startSession("transformSingle" /* TransformSingle */, newShape.id, He.BottomRight, true);
    this.setStatus("creating" /* Creating */);
  };
};

// src/components/Tldraw/state/tools/SelectTool/SelectTool.ts
var SelectTool = class extends BaseTool {
  type = "select";
  pointedId;
  selectedGroupId;
  pointedHandleId;
  pointedBoundsHandle;
  pointedLinkHandleId;
  /* --------------------- Methods -------------------- */
  deselect(id) {
    this.app.select(...this.app.selectedIds.filter((oid) => oid !== id));
  }
  select(id) {
    this.app.select(id);
  }
  pushSelect(id) {
    const shape = this.app.getShape(id);
    this.app.select(...this.app.selectedIds.filter((oid) => oid !== shape.parentId), id);
  }
  selectNone() {
    this.app.selectNone();
  }
  onEnter = () => {
    this.setStatus("idle" /* Idle */);
  };
  onExit = () => {
    this.setStatus("idle" /* Idle */);
  };
  clonePaint = (point) => {
    if (this.app.selectedIds.length === 0)
      return;
    const shapes = this.app.selectedIds.map((id) => this.app.getShape(id));
    const bounds = C3.expandBounds(C3.getCommonBounds(shapes.map(TLDR.getBounds)), 16);
    const center = C3.getBoundsCenter(bounds);
    const size = [bounds.width, bounds.height];
    const gridPoint = [
      center[0] + size[0] * Math.floor((point[0] + size[0] / 2 - center[0]) / size[0]),
      center[1] + size[1] * Math.floor((point[1] + size[1] / 2 - center[1]) / size[1])
    ];
    const centeredBounds = C3.centerBounds(bounds, gridPoint);
    const hit = this.app.shapes.some((shape) => TLDR.getShapeUtil(shape).hitTestBounds(shape, centeredBounds));
    if (!hit) {
      this.app.duplicate(this.app.selectedIds, gridPoint);
    }
  };
  getShapeClone = (id, side) => {
    const shape = this.app.getShape(id);
    const utils = TLDR.getShapeUtil(shape);
    if (utils.canClone) {
      const bounds = utils.getBounds(shape);
      const center = utils.getCenter(shape);
      let point = {
        top: [bounds.minX, bounds.minY - (bounds.height + CLONING_DISTANCE)],
        right: [bounds.maxX + CLONING_DISTANCE, bounds.minY],
        bottom: [bounds.minX, bounds.maxY + CLONING_DISTANCE],
        left: [bounds.minX - (bounds.width + CLONING_DISTANCE), bounds.minY],
        topLeft: [bounds.minX - (bounds.width + CLONING_DISTANCE), bounds.minY - (bounds.height + CLONING_DISTANCE)],
        topRight: [bounds.maxX + CLONING_DISTANCE, bounds.minY - (bounds.height + CLONING_DISTANCE)],
        bottomLeft: [bounds.minX - (bounds.width + CLONING_DISTANCE), bounds.maxY + CLONING_DISTANCE],
        bottomRight: [bounds.maxX + CLONING_DISTANCE, bounds.maxY + CLONING_DISTANCE]
      }[side];
      if (shape.rotation !== 0) {
        const newCenter = p.add(point, [bounds.width / 2, bounds.height / 2]);
        const rotatedCenter = p.rotWith(newCenter, center, shape.rotation || 0);
        point = p.sub(rotatedCenter, [bounds.width / 2, bounds.height / 2]);
      }
      const id2 = C3.uniqueId();
      const clone = {
        ...shape,
        id: id2,
        point
      };
      if (clone.type === "sticky" /* Sticky */) {
        clone.text = "";
      }
      return clone;
    }
  };
  /* ----------------- Event Handlers ----------------- */
  onCancel = () => {
    if (this.app.session) {
      this.app.cancelSession();
    } else {
      this.selectNone();
    }
    this.setStatus("idle" /* Idle */);
  };
  onKeyDown = (key, info, e5) => {
    switch (key) {
      case "Escape": {
        this.onCancel();
        break;
      }
      case "Tab": {
        if (this.app.readOnly)
          return;
        if (!this.app.pageState.editingId && this.status === "idle" /* Idle */ && this.app.selectedIds.length === 1) {
          const [selectedId] = this.app.selectedIds;
          const clonedShape = this.getShapeClone(selectedId, "right");
          if (clonedShape) {
            this.app.createShapes(clonedShape);
            this.setStatus("idle" /* Idle */);
            if (clonedShape.type === "sticky" /* Sticky */) {
              this.app.select(clonedShape.id);
              this.app.setEditingId(clonedShape.id);
            }
          }
        }
        break;
      }
      case "Meta":
      case "Control":
      case "Alt": {
        this.app.updateSession();
        break;
      }
      case "Enter": {
        if (this.app.readOnly)
          return;
        const { pageState } = this.app;
        if (pageState.selectedIds.length === 1 && !pageState.editingId) {
          this.app.setEditingId(pageState.selectedIds[0]);
          e5.preventDefault();
        }
      }
    }
  };
  onKeyUp = (key, info) => {
    if (this.status === "clonePainting" /* ClonePainting */ && !(info.altKey && info.shiftKey)) {
      this.setStatus("idle" /* Idle */);
      return;
    }
    if (key === "Meta" || key === "Control" || key === "Alt") {
      this.app.updateSession();
    }
  };
  // Keyup is handled on BaseTool
  // Pointer Events (generic)
  onPointerMove = () => {
    const { originPoint, currentPoint } = this.app;
    if (this.app.readOnly && this.app.isPointing) {
      if (this.app.session) {
        this.app.updateSession();
      } else {
        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {
          this.app.startSession("brush" /* Brush */);
          this.setStatus("brushing" /* Brushing */);
        }
      }
      return;
    }
    switch (this.status) {
      case "pointingBoundsHandle" /* PointingBoundsHandle */: {
        if (!this.pointedBoundsHandle)
          throw new Error("No pointed bounds handle");
        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {
          if (this.pointedBoundsHandle === "rotate") {
            this.setStatus("rotating" /* Rotating */);
            this.app.startSession("rotate" /* Rotate */);
          } else if (this.pointedBoundsHandle === "center" || this.pointedBoundsHandle === "left" || this.pointedBoundsHandle === "right") {
            this.setStatus("translating" /* Translating */);
            this.app.startSession("translate" /* Translate */, false, this.pointedBoundsHandle);
          } else {
            this.setStatus("transforming" /* Transforming */);
            const idsToTransform = this.app.selectedIds.flatMap((id) => TLDR.getDocumentBranch(this.app.state, id, this.app.currentPageId));
            if (idsToTransform.length === 1) {
              this.app.startSession("transformSingle" /* TransformSingle */, idsToTransform[0], this.pointedBoundsHandle);
            } else {
              this.app.startSession("transform" /* Transform */, this.pointedBoundsHandle);
            }
          }
          this.app.updateSession();
        }
        break;
      }
      case "pointingCanvas" /* PointingCanvas */: {
        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {
          this.app.startSession("brush" /* Brush */);
          this.setStatus("brushing" /* Brushing */);
        }
        break;
      }
      case "pointingClone" /* PointingClone */: {
        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {
          this.setStatus("translatingClone" /* TranslatingClone */);
          this.app.startSession("translate" /* Translate */);
          this.app.updateSession();
        }
        break;
      }
      case "pointingBounds" /* PointingBounds */: {
        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {
          this.setStatus("translating" /* Translating */);
          this.app.startSession("translate" /* Translate */);
          this.app.updateSession();
        }
        break;
      }
      case "pointingHandle" /* PointingHandle */: {
        if (!this.pointedHandleId)
          throw new Error("No pointed handle");
        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {
          this.setStatus("translatingHandle" /* TranslatingHandle */);
          const selectedShape = this.app.getShape(this.app.selectedIds[0]);
          if (selectedShape) {
            if (this.pointedHandleId === "bend") {
              this.app.startSession("handle" /* Handle */, selectedShape.id, this.pointedHandleId);
              this.app.updateSession();
            } else {
              this.app.startSession("arrow" /* Arrow */, selectedShape.id, this.pointedHandleId, false);
              this.app.updateSession();
            }
          }
        }
        break;
      }
      case "clonePainting" /* ClonePainting */: {
        this.clonePaint(currentPoint);
        break;
      }
      default: {
        if (this.app.session) {
          this.app.updateSession();
          break;
        }
      }
    }
  };
  onPointerDown = (info, e5) => {
    if (info.target === "canvas" && this.status === "idle" /* Idle */) {
      const { currentPoint } = this.app;
      if (info.spaceKey && e5.buttons === 1)
        return;
      if (this.status === "idle" /* Idle */ && info.altKey && info.shiftKey) {
        this.setStatus("clonePainting" /* ClonePainting */);
        this.clonePaint(currentPoint);
        return;
      }
      if (!info.shiftKey) {
        this.app.onShapeBlur();
        if (info.altKey && this.app.selectedIds.length > 0) {
          this.app.duplicate(this.app.selectedIds, currentPoint);
          return;
        }
        this.selectNone();
      }
      this.setStatus("pointingCanvas" /* PointingCanvas */);
    }
  };
  onPointerUp = (info) => {
    if (this.status === "translatingClone" /* TranslatingClone */ || this.status === "pointingClone" /* PointingClone */) {
      if (this.pointedId) {
        this.app.completeSession();
        this.app.setEditingId(this.pointedId);
      }
      this.setStatus("idle" /* Idle */);
      this.pointedId = void 0;
      return;
    }
    if (this.status === "pointingBounds" /* PointingBounds */) {
      if (info.target === "bounds") {
        this.selectNone();
      } else if (this.app.isSelected(info.target)) {
        if (info.shiftKey) {
          if (this.pointedId !== info.target) {
            this.deselect(info.target);
          }
        } else {
          if (this.pointedId !== info.target && this.app.selectedIds.length > 1) {
            this.select(info.target);
          }
        }
      } else if (this.pointedId === info.target) {
        if (this.app.getShape(info.target).isLocked)
          return;
        if (info.shiftKey) {
          this.pushSelect(info.target);
        } else {
          this.select(info.target);
        }
      }
    }
    this.setStatus("idle" /* Idle */);
    this.pointedBoundsHandle = void 0;
    this.pointedHandleId = void 0;
    this.pointedId = void 0;
    if (this.app.session?.type === "edit" /* Edit */) {
      return;
    }
    this.app.completeSession();
  };
  // Canvas
  onDoubleClickCanvas = () => {
    if (this.app.readOnly)
      return;
  };
  // Shape
  onPointShape = (info, e5) => {
    if (info.spaceKey && e5.buttons === 1)
      return;
    if (this.app.getShape(info.target).isLocked)
      return;
    const { editingId, hoveredId } = this.app.pageState;
    if (editingId && info.target !== editingId) {
      this.app.onShapeBlur();
    }
    if ((this.status === "idle" /* Idle */ || this.status === "pointingBounds" /* PointingBounds */) && info.metaKey && info.shiftKey && hoveredId) {
      this.pointedId = hoveredId;
      if (this.app.isSelected(hoveredId)) {
        this.deselect(hoveredId);
      } else {
        this.pushSelect(hoveredId);
        this.setStatus("pointingBounds" /* PointingBounds */);
      }
      return;
    }
    if (this.status === "pointingBounds" /* PointingBounds */) {
      const { parentId } = this.app.getShape(info.target);
      this.pointedId = parentId === this.app.currentPageId ? info.target : parentId;
      return;
    }
    if (this.status === "idle" /* Idle */) {
      this.setStatus("pointingBounds" /* PointingBounds */);
      if (info.metaKey) {
        if (!info.shiftKey) {
          this.selectNone();
        }
        this.app.startSession("brush" /* Brush */);
        this.setStatus("brushing" /* Brushing */);
        return;
      }
      let shapeIdToSelect;
      const { parentId } = this.app.getShape(info.target);
      if (parentId === this.app.currentPageId) {
        shapeIdToSelect = info.target;
        this.selectedGroupId = void 0;
      } else {
        if (parentId === this.selectedGroupId) {
          shapeIdToSelect = info.target;
        } else {
          shapeIdToSelect = parentId;
          this.selectedGroupId = void 0;
        }
      }
      if (!this.app.isSelected(shapeIdToSelect)) {
        this.pointedId = shapeIdToSelect;
        if (info.shiftKey) {
          this.pushSelect(shapeIdToSelect);
        } else {
          this.select(shapeIdToSelect);
        }
      }
    }
  };
  onDoubleClickShape = (info) => {
    if (this.app.readOnly)
      return;
    const shape = this.app.getShape(info.target);
    if (shape.isLocked) {
      this.app.select(info.target);
      return;
    }
    if (TLDR.getShapeUtil(shape.type).canEdit && (shape.parentId === this.app.currentPageId || shape.parentId === this.selectedGroupId)) {
      this.app.setEditingId(info.target);
    }
    if (shape.parentId !== this.app.currentPageId) {
      this.selectedGroupId = shape.parentId;
    }
    this.app.select(info.target);
  };
  onRightPointShape = (info) => {
    if (!this.app.isSelected(info.target)) {
      this.app.select(info.target);
    }
  };
  onHoverShape = (info) => {
    this.app.setHoveredId(info.target);
  };
  onUnhoverShape = (info) => {
    const { currentPageId: oldCurrentPageId } = this.app;
    requestAnimationFrame(() => {
      if (oldCurrentPageId === this.app.currentPageId && this.app.pageState.hoveredId === info.target) {
        this.app.setHoveredId();
      }
    });
  };
  /* --------------------- Bounds --------------------- */
  onPointBounds = (info) => {
    if (info.metaKey) {
      if (!info.shiftKey) {
        this.selectNone();
      }
      this.app.startSession("brush" /* Brush */);
      this.setStatus("brushing" /* Brushing */);
      return;
    }
    this.setStatus("pointingBounds" /* PointingBounds */);
  };
  onRightPointBounds = (info, e5) => {
    e5.stopPropagation();
  };
  onReleaseBounds = () => {
    if (this.status === "translating" /* Translating */ || this.status === "brushing" /* Brushing */) {
      this.app.completeSession();
    }
    this.setStatus("idle" /* Idle */);
  };
  /* ----------------- Bounds Handles ----------------- */
  onPointBoundsHandle = (info) => {
    this.pointedBoundsHandle = info.target;
    this.setStatus("pointingBoundsHandle" /* PointingBoundsHandle */);
  };
  onDoubleClickBoundsHandle = (info) => {
    switch (info.target) {
      case "center":
      case "left":
      case "right": {
        this.app.select(...TLDR.getLinkedShapeIds(this.app.state, this.app.currentPageId, info.target, info.shiftKey));
        break;
      }
      default: {
        if (this.app.selectedIds.length === 1) {
          this.app.resetBounds(this.app.selectedIds);
          const shape = this.app.getShape(this.app.selectedIds[0]);
          if ("label" in shape) {
            this.app.setEditingId(shape.id);
          }
        }
      }
    }
  };
  onReleaseBoundsHandle = () => {
    this.setStatus("idle" /* Idle */);
  };
  /* --------------------- Handles -------------------- */
  onPointHandle = (info) => {
    this.pointedHandleId = info.target;
    this.setStatus("pointingHandle" /* PointingHandle */);
  };
  onDoubleClickHandle = (info) => {
    if (info.target === "bend") {
      const { selectedIds } = this.app;
      if (selectedIds.length !== 1)
        return;
      const shape = this.app.getShape(selectedIds[0]);
      if (TLDR.getShapeUtil(shape.type).canEdit && (shape.parentId === this.app.currentPageId || shape.parentId === this.selectedGroupId)) {
        this.app.setEditingId(shape.id);
      }
      return;
    }
    this.app.toggleDecoration(info.target);
  };
  onReleaseHandle = () => {
    this.setStatus("idle" /* Idle */);
  };
  /* ---------------------- Misc ---------------------- */
  onShapeClone = (info) => {
    const selectedShapeId = this.app.selectedIds[0];
    const clonedShape = this.getShapeClone(selectedShapeId, info.target);
    if (info.target === "left" || info.target === "right" || info.target === "top" || info.target === "bottom") {
      if (clonedShape) {
        this.app.createShapes(clonedShape);
        this.pointedId = clonedShape.id;
        this.setStatus("pointingClone" /* PointingClone */);
      }
    } else {
      this.setStatus("gridCloning" /* GridCloning */);
      this.app.startSession("grid" /* Grid */, selectedShapeId);
    }
  };
};

// src/components/Tldraw/state/tools/StickyTool/StickyTool.ts
var StickyTool = class extends BaseTool {
  type = "sticky" /* Sticky */;
  shapeId;
  /* ----------------- Event Handlers ----------------- */
  onPointerDown = () => {
    if (this.app.readOnly)
      return;
    if (this.status === "creating" /* Creating */) {
      this.setStatus("idle" /* Idle */);
      if (!this.app.appState.isToolLocked) {
        this.app.selectTool("select");
      }
      return;
    }
    if (this.status === "idle" /* Idle */) {
      const {
        currentPoint,
        currentGrid,
        settings: { showGrid },
        appState: { currentPageId, currentStyle }
      } = this.app;
      const childIndex = this.getNextChildIndex();
      const id = C3.uniqueId();
      this.shapeId = id;
      const newShape = Sticky.create({
        id,
        parentId: currentPageId,
        childIndex,
        point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,
        style: { ...currentStyle }
      });
      const bounds = Sticky.getBounds(newShape);
      newShape.point = p.sub(newShape.point, [bounds.width / 2, bounds.height / 2]);
      this.app.patchCreate([newShape]);
      this.app.startSession("translate" /* Translate */);
      this.setStatus("creating" /* Creating */);
    }
  };
  onPointerUp = () => {
    if (this.app.readOnly)
      return;
    if (this.status === "creating" /* Creating */) {
      this.setStatus("idle" /* Idle */);
      this.app.completeSession();
      this.app.selectTool("select");
      this.app.setEditingId(this.shapeId);
    }
  };
};

// src/components/Tldraw/state/tools/TextTool/TextTool.ts
var TextTool = class extends BaseTool {
  type = "text" /* Text */;
  /* --------------------- Methods -------------------- */
  stopEditingShape = () => {
    this.setStatus("idle" /* Idle */);
    if (!this.app.appState.isToolLocked) {
      this.app.selectTool("select");
    }
  };
  /* ----------------- Event Handlers ----------------- */
  onKeyUp = () => {
  };
  onKeyDown = () => {
  };
  onPointerDown = () => {
    if (this.status === "creating" /* Creating */) {
      this.stopEditingShape();
      return;
    }
    if (this.status === "idle" /* Idle */) {
      const {
        currentPoint,
        currentGrid,
        settings: { showGrid }
      } = this.app;
      this.app.createTextShapeAtPoint(showGrid ? p.snap(currentPoint, currentGrid) : currentPoint, void 0, true);
      this.setStatus("creating" /* Creating */);
    }
  };
  onPointerUp = () => {
  };
  onPointShape = (info) => {
    if (this.app.readOnly)
      return;
    const shape = this.app.getShape(info.target);
    if (shape.type === "text" /* Text */) {
      this.setStatus("idle" /* Idle */);
      this.app.setEditingId(shape.id);
    }
  };
  onShapeBlur = () => {
    if (this.app.readOnly)
      return;
    this.stopEditingShape();
  };
};

// src/components/Tldraw/state/tools/TriangleTool/TriangleTool.ts
var TriangleTool = class extends BaseTool {
  type = "triangle" /* Triangle */;
  /* ----------------- Event Handlers ----------------- */
  onPointerDown = () => {
    if (this.app.readOnly)
      return;
    if (this.status !== "idle" /* Idle */)
      return;
    const {
      currentPoint,
      currentGrid,
      settings: { showGrid },
      appState: { currentPageId, currentStyle }
    } = this.app;
    const childIndex = this.getNextChildIndex();
    const id = C3.uniqueId();
    const newShape = Triangle.create({
      id,
      parentId: currentPageId,
      childIndex,
      point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,
      style: { ...currentStyle }
    });
    this.app.patchCreate([newShape]);
    this.app.startSession("transformSingle" /* TransformSingle */, newShape.id, He.BottomRight, true);
    this.setStatus("creating" /* Creating */);
  };
};

// src/components/Tldraw/state/TldrawApp.ts
var uuid = C3.uniqueId();
var _TldrawApp = class extends StateManager {
  callbacks = {};
  tools = {
    select: new SelectTool(this),
    erase: new EraseTool(this),
    ["text" /* Text */]: new TextTool(this),
    ["draw" /* Draw */]: new DrawTool(this),
    ["ellipse" /* Ellipse */]: new EllipseTool(this),
    ["rectangle" /* Rectangle */]: new RectangleTool(this),
    ["triangle" /* Triangle */]: new TriangleTool(this),
    ["line" /* Line */]: new LineTool(this),
    ["arrow" /* Arrow */]: new ArrowTool(this),
    ["sticky" /* Sticky */]: new StickyTool(this)
  };
  currentTool = this.tools.select;
  session;
  readOnly = false;
  isDirty = false;
  isCreating = false;
  originPoint = [0, 0];
  currentPoint = [0, 0];
  previousPoint = [0, 0];
  shiftKey = false;
  altKey = false;
  metaKey = false;
  ctrlKey = false;
  spaceKey = false;
  isPointing = false;
  isForcePanning = false;
  isErasingWithPen = false;
  isPastePrevented = false;
  editingStartTime = -1;
  fileSystemHandle = null;
  viewport = C3.getBoundsFromPoints([
    [0, 0],
    [100, 100]
  ]);
  rendererBounds = C3.getBoundsFromPoints([
    [0, 0],
    [100, 100]
  ]);
  selectHistory = {
    stack: [[]],
    pointer: 0
  };
  clipboard;
  rotationInfo = {
    selectedIds: [],
    center: [0, 0]
  };
  constructor(id, callbacks = {}) {
    super(_TldrawApp.defaultState, id, _TldrawApp.version, (prev, next, prevVersion) => {
      return migrate(
        {
          ...next,
          document: { ...next.document, ...prev.document, version: prevVersion }
        },
        _TldrawApp.version
      );
    });
    this.callbacks = callbacks;
  }
  /* -------------------- Internal -------------------- */
  migrate = (state) => {
    return migrate(state, _TldrawApp.version);
  };
  onReady = () => {
    this.loadDocument(this.document);
    try {
      this.patchState({
        ...migrate(this.state, _TldrawApp.version),
        appState: {
          status: "idle" /* Idle */
        }
      });
    } catch (error) {
      console.error("The data appears to be corrupted. Resetting!", error);
      localStorage.setItem(this.document.id + "_corrupted", JSON.stringify(this.document));
      this.patchState({
        ..._TldrawApp.defaultState,
        appState: {
          ..._TldrawApp.defaultState.appState,
          status: "idle" /* Idle */
        }
      });
    }
    this.callbacks.onMount?.(this);
  };
  /**
   * Cleanup the state after each state change.
   * @param state The new state
   * @param prev The previous state
   * @protected
   * @returns The final state
   */
  cleanup = (state, prev) => {
    const next = { ...state };
    if (next.document !== prev.document) {
      Object.entries(next.document.pages).forEach(([pageId, page]) => {
        if (page === void 0) {
          delete next.document.pages[pageId];
          delete next.document.pageStates[pageId];
          return;
        }
        const prevPage = prev.document.pages[pageId];
        const changedShapes = {};
        if (!prevPage || page.shapes !== prevPage.shapes || page.bindings !== prevPage.bindings) {
          page.shapes = { ...page.shapes };
          page.bindings = { ...page.bindings };
          const groupsToUpdate = /* @__PURE__ */ new Set();
          Object.entries(page.shapes).forEach(([id, shape]) => {
            let parentId;
            if (shape) {
              parentId = shape.parentId;
            } else {
              parentId = prevPage?.shapes[id]?.parentId;
              delete page.shapes[id];
            }
            if (page.id === next.appState.currentPageId && prevPage?.shapes[id] !== shape) {
              changedShapes[id] = shape;
            }
            if (parentId && parentId !== pageId) {
              const group = page.shapes[parentId];
              if (group !== void 0) {
                groupsToUpdate.add(page.shapes[parentId]);
              }
            }
          });
          Object.keys(page.bindings).forEach((id) => {
            if (!page.bindings[id]) {
              delete page.bindings[id];
            }
          });
          next.document.pages[pageId] = page;
          const bindingsToUpdate = TLDR.getRelatedBindings(next, Object.keys(changedShapes), pageId);
          const visitedShapes = /* @__PURE__ */ new Set();
          bindingsToUpdate.forEach((binding) => {
            if (!page.bindings[binding.id]) {
              return;
            }
            const toShape = page.shapes[binding.toId];
            const fromShape = page.shapes[binding.fromId];
            if (!(toShape && fromShape)) {
              delete next.document.pages[pageId].bindings[binding.id];
              return;
            }
            if (visitedShapes.has(fromShape)) {
              return;
            }
            const fromDelta = TLDR.updateArrowBindings(page, fromShape);
            visitedShapes.add(fromShape);
            if (fromDelta) {
              const nextShape = {
                ...fromShape,
                ...fromDelta
              };
              page.shapes[fromShape.id] = nextShape;
            }
          });
          groupsToUpdate.forEach((group) => {
            if (!group)
              throw new Error("no group!");
            const children = group.children.filter((id) => page.shapes[id] !== void 0);
            const commonBounds = C3.getCommonBounds(
              children.map((id) => page.shapes[id]).filter(Boolean).map((shape) => TLDR.getRotatedBounds(shape))
            );
            page.shapes[group.id] = {
              ...group,
              point: [commonBounds.minX, commonBounds.minY],
              size: [commonBounds.width, commonBounds.height],
              children
            };
          });
        }
        const nextPageState = {
          ...next.document.pageStates[pageId]
        };
        if (!nextPageState.brush) {
          delete nextPageState.brush;
        }
        if (nextPageState.hoveredId && !page.shapes[nextPageState.hoveredId]) {
          delete nextPageState.hoveredId;
        }
        if (nextPageState.bindingId && !page.bindings[nextPageState.bindingId]) {
          TLDR.warn(`Could not find the binding of ${pageId}`);
          delete nextPageState.bindingId;
        }
        if (nextPageState.editingId && !page.shapes[nextPageState.editingId]) {
          TLDR.warn("Could not find the editing shape!");
          delete nextPageState.editingId;
        }
        next.document.pageStates[pageId] = nextPageState;
      });
    }
    Object.keys(next.document.assets ?? {}).forEach((id) => {
      if (!next.document.assets?.[id]) {
        delete next.document.assets?.[id];
      }
    });
    if (this.readOnly) {
      next.document.pages = prev.document.pages;
    }
    return next;
  };
  onPatch = (state, patch, id) => {
    this.callbacks.onPatch?.(this, patch, id);
  };
  onCommand = (state, command, id) => {
    this.clearSelectHistory();
    this.isDirty = true;
    this.callbacks.onCommand?.(this, command, id);
  };
  onReplace = () => {
    this.clearSelectHistory();
    this.isDirty = false;
  };
  onUndo = () => {
    this.rotationInfo.selectedIds = [...this.selectedIds];
    this.callbacks.onUndo?.(this);
  };
  onRedo = () => {
    this.rotationInfo.selectedIds = [...this.selectedIds];
    this.callbacks.onRedo?.(this);
  };
  onPersist = (state, patch) => {
    this.callbacks.onPersist?.(this);
  };
  prevSelectedIds = this.selectedIds;
  /**
   * Clear the selection history after each new command, undo or redo.
   * @param state
   * @param id
   */
  onStateDidChange = (_state, id) => {
    this.callbacks.onChange?.(this, id);
  };
  preventPaste = () => {
    if (this.isPastePrevented)
      return;
    const prevent = (event) => event.stopImmediatePropagation();
    const enable = () => {
      setTimeout(() => {
        document.removeEventListener("paste", prevent, { capture: true });
        this.isPastePrevented = false;
      }, 50);
    };
    document.addEventListener("paste", prevent, { capture: true });
    window.addEventListener("pointerup", enable, { once: true });
    this.isPastePrevented = true;
  };
  /**
   * Set the current status.
   * @param status The new status to set.
   * @private
   * @returns
   */
  setStatus(status) {
    return this.patchState(
      {
        appState: { status }
      },
      `set_status:${status}`
    );
  }
  /**
   * Update the bounding box when the renderer's bounds change.
   * @param bounds
   */
  updateBounds = (bounds) => {
    this.rendererBounds = bounds;
    const { point, zoom } = this.camera;
    this.updateViewport(point, zoom);
    if (!this.readOnly && this.session) {
      this.session.update();
    }
  };
  updateViewport = (point, zoom) => {
    const { width, height } = this.rendererBounds;
    const [minX, minY] = e.sub(e.div([0, 0], zoom), point);
    const [maxX, maxY] = e.sub(e.div([width, height], zoom), point);
    this.viewport = {
      minX,
      minY,
      maxX,
      maxY,
      height: maxX - minX,
      width: maxY - minY
    };
  };
  /**
   * Set or clear the editing id
   * @param id [string]
   */
  setEditingId = (id, isCreating = false) => {
    if (this.readOnly)
      return;
    if (id) {
      this.startSession("edit" /* Edit */, id, isCreating);
    } else {
      if (!this.pageState.editingId)
        return;
      this.completeSession();
    }
    this.editingStartTime = performance.now();
    this.patchState(
      {
        document: {
          pageStates: {
            [this.currentPageId]: {
              editingId: id
            }
          }
        }
      },
      `set_editing_id`
    );
  };
  /**
   * Set or clear the hovered id
   * @param id [string]
   */
  setHoveredId = (id) => {
    this.patchState(
      {
        document: {
          pageStates: {
            [this.currentPageId]: {
              hoveredId: id
            }
          }
        }
      },
      `set_hovered_id`
    );
  };
  /* -------------------------------------------------- */
  /*                    Settings & UI                   */
  /* -------------------------------------------------- */
  /**
   * Set a setting.
   */
  setSetting = (name, value) => {
    if (this.session)
      return this;
    const patch = {
      settings: {
        [name]: typeof value === "function" ? value(this.settings[name]) : value
      }
    };
    this.patchState(patch, `settings:${name}`);
    this.persist(patch);
    return this;
  };
  /**
   * Toggle pen mode.
   */
  toggleFocusMode = () => {
    if (this.session)
      return this;
    const patch = {
      settings: {
        isFocusMode: !this.settings.isFocusMode
      }
    };
    this.patchState(patch, `settings:toggled_focus_mode`);
    this.persist(patch);
    return this;
  };
  /**
   * Toggle pen mode.
   */
  togglePenMode = () => {
    if (this.session)
      return this;
    const patch = {
      settings: {
        isPenMode: !this.settings.isPenMode
      }
    };
    this.patchState(patch, `settings:toggled_pen_mode`);
    this.persist(patch);
    return this;
  };
  /**
   * Toggle zoom snap.
   */
  toggleZoomSnap = () => {
    if (this.session)
      return this;
    const patch = { settings: { isZoomSnap: !this.settings.isZoomSnap } };
    this.patchState(patch, `settings:toggled_zoom_snap`);
    this.persist(patch);
    return this;
  };
  /**
   * Toggle debug mode.
   */
  toggleDebugMode = () => {
    if (this.session)
      return this;
    const patch = { settings: { isDebugMode: !this.settings.isDebugMode } };
    this.patchState(patch, `settings:toggled_debug`);
    this.persist(patch);
    return this;
  };
  /**
   * Toggles the state if menu is opened
   */
  setMenuOpen = (isOpen) => {
    const patch = { appState: { isMenuOpen: isOpen } };
    this.patchState(patch, "ui:toggled_menu_opened");
    this.persist(patch);
    return this;
  };
  /**
   * Toggles the state if something is loading
   */
  setIsLoading = (isLoading) => {
    const patch = { appState: { isLoading } };
    this.patchState(patch, "ui:toggled_is_loading");
    this.persist(patch);
    return this;
  };
  /**
   * Toggles the state if mouse move into/out-of the edit area
   */
  setMouseInBound = (mouseInBound) => {
    const patch = { appState: { mouseInBound } };
    this.patchState(patch, "ui:toggled_mouse_in_bound");
    return this;
  };
  setDisableAssets = (disableAssets) => {
    this.patchState({ appState: { disableAssets } }, "ui:toggled_disable_images");
    return this;
  };
  get isMenuOpen() {
    return this.appState.isMenuOpen;
  }
  get isMouseInBound() {
    return this.appState.mouseInBound;
  }
  get isLoading() {
    return this.appState.isLoading;
  }
  get disableAssets() {
    return this.appState.disableAssets;
  }
  /**
   * Toggle grids.
   */
  toggleGrid = () => {
    if (this.session)
      return this;
    const patch = { settings: { showGrid: !this.settings.showGrid } };
    this.patchState(patch, "settings:toggled_grid");
    this.persist(patch);
    return this;
  };
  /**
   * Select a tool.
   * @param tool The tool to select, or "select".
   */
  selectTool = (type) => {
    if (this.readOnly || this.session)
      return this;
    this.isPointing = false;
    const tool = this.tools[type];
    if (tool === this.currentTool) {
      this.patchState({
        appState: {
          isToolLocked: false
        }
      });
      return this;
    }
    this.currentTool.onExit();
    tool.previous = this.currentTool.type;
    this.currentTool = tool;
    this.currentTool.onEnter();
    return this.patchState(
      {
        appState: {
          activeTool: type,
          isToolLocked: false
        }
      },
      `selected_tool:${type}`
    );
  };
  /**
   * Toggle the tool lock option.
   */
  toggleToolLock = () => {
    if (this.session)
      return this;
    return this.patchState(
      {
        appState: {
          isToolLocked: !this.appState.isToolLocked
        }
      },
      `toggled_tool_lock`
    );
  };
  /* -------------------------------------------------- */
  /*                      Document                      */
  /* -------------------------------------------------- */
  /**
   * Reset the document to a blank state.
   */
  resetDocument = () => {
    if (this.session)
      return this;
    this.session = void 0;
    this.currentTool = this.tools.select;
    const doc = _TldrawApp.defaultDocument;
    doc.pages.page.name = "Page 1";
    this.resetHistory().clearSelectHistory().loadDocument(_TldrawApp.defaultDocument).persist({});
    return this;
  };
  /**
   * Update the current document.
   * @param document
   */
  updateDocument = (document2, reason = "updated_document") => {
    const prevState = this.state;
    const nextState = {
      ...prevState,
      document: {
        ...prevState.document,
        assets: document2.assets
      }
    };
    if (!document2.pages[this.currentPageId]) {
      nextState.appState = {
        ...prevState.appState,
        currentPageId: Object.keys(document2.pages)[0]
      };
    }
    let i4 = 1;
    for (const nextPage of Object.values(document2.pages)) {
      if (nextPage !== prevState.document.pages[nextPage.id]) {
        nextState.document.pages[nextPage.id] = nextPage;
        if (!nextPage.name) {
          nextState.document.pages[nextPage.id].name = `Page ${i4 + 1}`;
          i4++;
        }
      }
    }
    for (const nextPageState of Object.values(document2.pageStates)) {
      if (nextPageState !== prevState.document.pageStates[nextPageState.id]) {
        nextState.document.pageStates[nextPageState.id] = nextPageState;
        const nextPage = document2.pages[nextPageState.id];
        const keysToCheck = ["bindingId", "editingId", "hoveredId", "pointedId"];
        for (const key of keysToCheck) {
          if (!nextPage.shapes[key]) {
            nextPageState[key] = void 0;
          }
        }
        nextPageState.selectedIds = nextPageState.selectedIds.filter((id) => !!document2.pages[nextPage.id].shapes[id]);
      }
    }
    return this.replaceState(migrate(nextState, nextState.document.version || 0), `${reason}:${document2.id}`);
  };
  /**
   * Load a new document.
   * @param document The document to load
   */
  loadDocument = (document2) => {
    this.setIsLoading(true);
    this.selectNone();
    this.resetHistory();
    this.clearSelectHistory();
    this.session = void 0;
    const state = {
      ..._TldrawApp.defaultState,
      settings: {
        ...this.state.settings
      },
      document: document2,
      appState: {
        ..._TldrawApp.defaultState.appState,
        ...this.state.appState,
        currentPageId: Object.keys(document2.pages)[0],
        disableAssets: this.disableAssets
      }
    };
    this.replaceState(migrate(state, _TldrawApp.version), "loaded_document");
    const { point, zoom } = this.camera;
    this.updateViewport(point, zoom);
    this.setIsLoading(false);
    return this;
  };
  /**
   * Upload media from file
   */
  openAsset = async () => {
    if (!this.disableAssets)
      try {
        const file = await openAssetsFromFileSystem();
        if (Array.isArray(file)) {
          await this.addMediaFromFiles(file, this.centerPoint);
        } else {
          if (!file)
            return;
          await this.addMediaFromFiles([file]);
        }
      } catch (error) {
        console.error(error);
      } finally {
        await this.persist({});
      }
  };
  /* -------------------- Getters --------------------- */
  /**
   * Get the current app state.
   */
  getAppState = () => {
    return this.appState;
  };
  /**
   * Get a page.
   * @param pageId (optional) The page's id.
   */
  getPage = (pageId = this.currentPageId) => {
    return TLDR.getPage(this.state, pageId || this.currentPageId);
  };
  /**
   * Get the shapes (as an array) from a given page.
   * @param pageId (optional) The page's id.
   */
  getShapes = (pageId = this.currentPageId) => {
    return TLDR.getShapes(this.state, pageId || this.currentPageId);
  };
  /**
   * Get the bindings from a given page.
   * @param pageId (optional) The page's id.
   */
  getBindings = (pageId = this.currentPageId) => {
    return TLDR.getBindings(this.state, pageId || this.currentPageId);
  };
  /**
   * Get a shape from a given page.
   * @param id The shape's id.
   * @param pageId (optional) The page's id.
   */
  getShape = (id, pageId = this.currentPageId) => {
    return TLDR.getShape(this.state, id, pageId);
  };
  /**
   * Get the bounds of a shape on a given page.
   * @param id The shape's id.
   * @param pageId (optional) The page's id.
   */
  getShapeBounds = (id, pageId = this.currentPageId) => {
    return TLDR.getBounds(this.getShape(id, pageId));
  };
  /**
   * Get a binding from a given page.
   * @param id The binding's id.
   * @param pageId (optional) The page's id.
   */
  getBinding = (id, pageId = this.currentPageId) => {
    return TLDR.getBinding(this.state, id, pageId);
  };
  /**
   * Get the page state for a given page.
   * @param pageId (optional) The page's id.
   */
  getPageState = (pageId = this.currentPageId) => {
    return TLDR.getPageState(this.state, pageId || this.currentPageId);
  };
  /**
   * Turn a screen point into a point on the page.
   * @param point The screen point
   * @param pageId (optional) The page to use
   */
  getPagePoint = (point, pageId = this.currentPageId) => {
    const { camera } = this.getPageState(pageId);
    return e.sub(e.div(point, camera.zoom), camera.point);
  };
  /**
   * Get the current undo/redo stack.
   */
  get history() {
    return this.stack.slice(0, this.pointer + 1);
  }
  /**
   * Replace the current history stack.
   */
  set history(commands) {
    this.replaceHistory(commands);
  }
  /**
   * The current document.
   */
  get document() {
    return this.state.document;
  }
  /**
   * The current app state.
   */
  get settings() {
    return this.state.settings;
  }
  /**
   * The current app state.
   */
  get appState() {
    return this.state.appState;
  }
  /**
   * The current page id.
   */
  get currentPageId() {
    return this.state.appState.currentPageId;
  }
  /**
   * The current page.
   */
  get page() {
    return this.state.document.pages[this.currentPageId];
  }
  /**
   * The current page's shapes (as an array).
   */
  get shapes() {
    return Object.values(this.page.shapes);
  }
  /**
   * The current page's bindings.
   */
  get bindings() {
    return Object.values(this.page.bindings);
  }
  /**
   * The document's assets (as an array).
   */
  get assets() {
    return Object.values(this.document.assets);
  }
  /**
   * The current page's state.
   */
  get pageState() {
    return this.state.document.pageStates[this.currentPageId];
  }
  get camera() {
    return this.pageState.camera;
  }
  get zoom() {
    return this.pageState.camera.zoom;
  }
  /**
   * The page's current selected ids.
   */
  get selectedIds() {
    return this.pageState.selectedIds;
  }
  /* -------------------------------------------------- */
  /*                        Pages                       */
  /* -------------------------------------------------- */
  /**
   * Create a new page.
   * @param pageId (optional) The new page's id.
   */
  createPage = (id, name) => {
    if (this.readOnly)
      return this;
    const { width, height } = this.rendererBounds;
    return this.setState(createPage(this, [-width / 2, -height / 2], id, name));
  };
  /**
   * Change the current page.
   * @param pageId The new current page's id.
   */
  changePage = (pageId) => {
    return this.setState(changePage(this, pageId));
  };
  /**
   * Move a page above another.
   * @param pageId The page to move.
   * @param index The page above which to move.
   */
  movePage = (pageId, index2) => {
    if (this.readOnly)
      return this;
    return this.setState(movePage(this, pageId, index2));
  };
  /**
   * Rename a page.
   * @param pageId The id of the page to rename.
   * @param name The page's new name
   */
  renamePage = (pageId, name) => {
    if (this.readOnly)
      return this;
    return this.setState(renamePage(this, pageId, name));
  };
  /**
   * Duplicate a page.
   * @param pageId The id of the page to duplicate.
   */
  duplicatePage = (pageId) => {
    if (this.readOnly)
      return this;
    return this.setState(duplicatePage(this, pageId));
  };
  /**
   * Delete a page.
   * @param pageId The id of the page to delete.
   */
  deletePage = (pageId) => {
    if (this.readOnly)
      return this;
    if (Object.values(this.document.pages).length <= 1)
      return this;
    return this.setState(deletePage(this, pageId || this.currentPageId));
  };
  /* -------------------------------------------------- */
  /*                      Clipboard                     */
  /* -------------------------------------------------- */
  /**
   * Cut (copy and delete) one or more shapes to the clipboard.
   * @param ids The ids of the shapes to cut.
   */
  cut = (ids = this.selectedIds, event) => {
    event?.preventDefault();
    this.copy(ids, event);
    if (!this.readOnly) {
      this.delete(ids);
    }
    return this;
  };
  /**
   * Copy one or more shapes to the clipboard.
   * @param ids The ids of the shapes to copy.
   */
  copy = (ids = this.selectedIds, event) => {
    event?.preventDefault();
    event?.stopPropagation();
    this.clipboard = this.getContent(ids);
    const jsonString = JSON.stringify({
      type: "tldr/clipboard",
      ...this.clipboard
    });
    const tldrawString = `<tldraw>${jsonString}</tldraw>`;
    if (event) {
      event.clipboardData?.setData("text/html", tldrawString);
    }
    if (navigator.clipboard && window.ClipboardItem) {
      void navigator.clipboard.write([
        new ClipboardItem({
          "text/html": new Blob([tldrawString], { type: "text/html" })
        })
      ]);
    }
    return this;
  };
  /**
   * Paste shapes (or text) from clipboard to a certain point.
   * @param point
   */
  paste = async (point, event) => {
    event?.preventDefault();
    event?.stopPropagation();
    if (this.readOnly)
      return;
    const filesToPaste = [];
    const shapesToCreate = [];
    let clipboardData;
    const getSvgFromText = async (text) => {
      const div = document.createElement("div");
      div.innerHTML = text;
      const svg = div.firstChild;
      svg.style.setProperty("background-color", "transparent");
      const imageBlob = await TLDR.getImageForSvg(svg, "svg" /* SVG */, {
        scale: 1,
        quality: 1
      });
      if (imageBlob) {
        const file = new File([imageBlob], "image.svg");
        filesToPaste.push(file);
      } else {
        getShapeFromText(text);
      }
    };
    const getShapeFromText = (text) => {
      const pagePoint = this.getPagePoint(point ?? this.centerPoint, this.currentPageId);
      const isMultiline = text.includes("\n");
      shapesToCreate.push(
        TLDR.getShapeUtil("text" /* Text */).getShape({
          id: C3.uniqueId(),
          type: "text" /* Text */,
          parentId: this.appState.currentPageId,
          text: TLDR.normalizeText(text.trim()),
          point: pagePoint,
          style: {
            ...this.appState.currentStyle,
            textAlign: isMultiline ? "start" /* Start */ : this.appState.currentStyle.textAlign
          }
        })
      );
    };
    const getShapeFromHtml = (html) => {
      try {
        const maybeJson = html.match(/<tldraw>(.*)<\/tldraw>/)?.[1];
        if (!maybeJson)
          return;
        const json = JSON.parse(maybeJson);
        if (json.type === "tldr/clipboard") {
          clipboardData = json;
          return;
        } else {
          throw new Error("Not tldraw data!");
        }
      } catch {
        getShapeFromText(html);
      }
    };
    if (event !== void 0) {
      const items = [...event.clipboardData?.items ?? []];
      await Promise.all(
        items.map(async (item) => {
          const { type, kind } = item;
          switch (kind) {
            case "string": {
              const str = await new Promise((resolve) => item.getAsString(resolve));
              switch (type) {
                case "text/html": {
                  if (str.match(/<tldraw>(.*)<\/tldraw>/)?.[1]) {
                    getShapeFromHtml(str);
                  }
                  break;
                }
                case "text/plain": {
                  if (str.startsWith("<svg")) {
                    await getSvgFromText(str);
                  } else {
                    getShapeFromText(str);
                  }
                  break;
                }
              }
              break;
            }
            case "file": {
              const file = item.getAsFile();
              if (file)
                filesToPaste.push(file);
              break;
            }
          }
        })
      );
    }
    if (clipboardData) {
      this.insertContent(clipboardData, { point, select: true });
      return this;
    }
    if (filesToPaste.length > 0) {
      this.addMediaFromFiles(filesToPaste, point);
      return this;
    }
    if (shapesToCreate.length > 0) {
      const pagePoint = this.getPagePoint(point ?? this.centerPoint, this.currentPageId);
      const currentPoint = e.add(pagePoint, [0, 0]);
      shapesToCreate.forEach((shape, i4) => {
        const bounds = TLDR.getBounds(shape);
        if (i4 === 0) {
          currentPoint[0] -= bounds.width / 2;
          currentPoint[1] -= bounds.height / 2;
        }
        shape.point = [...currentPoint];
        currentPoint[0] += bounds.width;
      });
      this.createShapes(...shapesToCreate);
      return this;
    }
    if (this.clipboard) {
      this.insertContent(this.clipboard);
    }
    return this;
  };
  getSvg = async (ids = this.selectedIds.length > 0 ? this.selectedIds : Object.keys(this.page.shapes)) => {
    if (ids.length === 0)
      return;
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    const style = document.createElementNS("http://www.w3.org/2000/svg", "style");
    if (typeof window !== "undefined") {
      window.focus();
    }
    defs.append(style);
    svg.append(defs);
    const shapes = ids.map((id) => this.getShape(id, this.currentPageId)).sort((a7, b6) => a7.childIndex - b6.childIndex);
    const commonBounds = C3.getCommonBounds(shapes.map(TLDR.getRotatedBounds));
    const getSvgElementForShape = (shape) => {
      const util = TLDR.getShapeUtil(shape);
      const bounds = util.getBounds(shape);
      const elm = util.getSvgElement(shape);
      if (!elm)
        return;
      if (shape.type === "image" /* Image */) {
        elm.setAttribute("xlink:href", this.document.assets[shape.assetId].src);
      }
      elm.setAttribute(
        "transform",
        `translate(${(SVG_EXPORT_PADDING + shape.point[0] - commonBounds.minX).toFixed(2)}, ${(SVG_EXPORT_PADDING + shape.point[1] - commonBounds.minY).toFixed(
          2
        )}) rotate(${((shape.rotation || 0) * 180 / Math.PI).toFixed(2)}, ${(bounds.width / 2).toFixed(2)}, ${(bounds.height / 2).toFixed(2)})`
      );
      return elm;
    };
    shapes.forEach((shape) => {
      if (shape.children?.length) {
        const g6 = document.createElementNS("http://www.w3.org/2000/svg", "g");
        shape.children.forEach((childId) => {
          const shape2 = this.getShape(childId, this.currentPageId);
          const elm2 = getSvgElementForShape(shape2);
          if (elm2) {
            g6.append(elm2);
          }
        });
        svg.append(g6);
        return;
      }
      const elm = getSvgElementForShape(shape);
      if (elm) {
        svg.append(elm);
      }
    });
    svg.setAttribute("viewBox", [0, 0, commonBounds.width + SVG_EXPORT_PADDING * 2, commonBounds.height + SVG_EXPORT_PADDING * 2].join(" "));
    svg.setAttribute("width", (commonBounds.width + SVG_EXPORT_PADDING * 2).toString());
    svg.setAttribute("height", (commonBounds.height + SVG_EXPORT_PADDING * 2).toString());
    const exportBackground = this.settings.exportBackground;
    const darkBackground = "#212529";
    const lightBackground = "rgb(248, 249, 250)";
    switch (exportBackground) {
      case "dark" /* Dark */: {
        svg.style.setProperty("background-color", darkBackground);
        break;
      }
      case "auto" /* Auto */:
      case "light" /* Light */: {
        svg.style.setProperty("background-color", lightBackground);
        break;
      }
      case "transparent" /* Transparent */:
      default: {
        svg.style.setProperty("background-color", "transparent");
        break;
      }
    }
    svg.querySelectorAll(".tl-fill-hitarea, .tl-stroke-hitarea, .tl-binding-indicator").forEach((elm) => elm.remove());
    return svg;
  };
  /**
   * Copy one or more shapes as SVG.
   * @param ids The ids of the shapes to copy.
   * @returns A string containing the JSON.
   */
  copySvg = async (ids = this.selectedIds.length > 0 ? this.selectedIds : Object.keys(this.page.shapes)) => {
    if (ids.length === 0)
      return;
    const svg = await this.getSvg(ids);
    if (!svg)
      return;
    const svgString = TLDR.getSvgString(svg, 1);
    this.clipboard = this.getContent(ids);
    const tldrawString = JSON.stringify({
      type: "tldr/clipboard",
      ...this.clipboard
    });
    if (navigator.clipboard && window.ClipboardItem) {
      navigator.clipboard.write([
        new ClipboardItem({
          "text/html": new Blob([tldrawString], { type: "text/html" }),
          "text/plain": new Blob([svgString], { type: "text/plain" })
        })
      ]);
    }
    return svgString;
  };
  /**
   * Get the shapes and bindings for the current selection, if any, or else the current page.
   *
   * @param ids The ids of the shapes to get content for.
   */
  getContent = (ids) => {
    const page = this.getPage(this.currentPageId);
    if (ids && ids.length === 0)
      return;
    if (!ids)
      ids = this.selectedIds;
    if (ids.length === 0)
      ids = Object.keys(page.shapes);
    if (ids.length === 0)
      return;
    const shapes = ids.map((id) => page.shapes[id]).flatMap((shape) => [shape, ...(shape.children ?? []).map((childId) => page.shapes[childId])]).map(deepCopy);
    const idsSet = new Set(shapes.map((s5) => s5.id));
    shapes.forEach((shape) => {
      if (shape.parentId === this.currentPageId) {
        shape.parentId = "currentPageId";
      }
    });
    const bindings = Object.values(page.bindings).filter((binding) => {
      if (idsSet.has(binding.fromId) || idsSet.has(binding.toId)) {
        return true;
      }
      if (idsSet.has(binding.fromId)) {
        const shape = shapes.find((s5) => s5.id === binding.fromId);
        const handles = shape.handles;
        if (handles) {
          Object.values(handles).forEach((handle) => {
            if (handle.bindingId === binding.id) {
              handle.bindingId = void 0;
            }
          });
        }
      }
      if (idsSet.has(binding.toId)) {
        const shape = shapes.find((s5) => s5.id === binding.toId);
        const handles = shape.handles;
        if (handles) {
          Object.values(handles).forEach((handle) => {
            if (handle.bindingId === binding.id) {
              handle.bindingId = void 0;
            }
          });
        }
      }
      return false;
    }).map(deepCopy);
    const assets = [
      ...new Set(
        shapes.map((shape) => {
          if (!shape.assetId)
            return;
          return this.document.assets[shape.assetId];
        }).filter(Boolean).map(deepCopy)
      )
    ];
    return { shapes, bindings, assets };
  };
  /**
   * Copy one or more shapes as JSON.
   * @param ids The ids of the shapes to copy.
   * @returns A string containing the JSON.
   */
  copyJson = (ids = this.selectedIds) => {
    const content = this.getContent(ids);
    if (content) {
      TLDR.copyStringToClipboard(JSON.stringify(content));
    }
    return this;
  };
  /**
   * Export one or more shapes as JSON.
   * @param ids The ids of the shapes to copy from the current page.
   * @returns A string containing the JSON.
   */
  exportJson = (ids = this.selectedIds) => {
    const content = this.getContent(ids);
    if (content) {
      const blob = new Blob([JSON.stringify(content)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `export.json`;
      link.click();
    }
    return this;
  };
  /**
   * Insert content.
   *
   * @param content The content to insert.
   * @param content.shapes An array of TDShape objects.
   * @param content.bindings (optional) An array of TDBinding objects.
   * @param content.assets (optional) An array of TDAsset objects.
   * @param opts (optional) An options object
   * @param opts.point (optional) A point at which to paste the content.
   * @param opts.select (optional) When true, the inserted shapes will be selected. Defaults to false.
   * @param opts.overwrite (optional) When true, the inserted shapes and bindings will overwrite any existing shapes and bindings. Defaults to false.
   */
  insertContent = (content, opts = {}) => {
    return this.setState(insertContent(this, content, opts), "insert_content");
  };
  /**
   * Get an image of the selected shapes.
   *
   * @param format The format to export the image as.
   * @param opts (optional) An object containing options for the image.
   * @param opts.ids (optional) The ids of the shapes (on the current page) to get an image for.
   * @param opts.scale (optional) The id of the page from which to get an image.
   * @param opts.quality (optional) The quality (between 0 and 1) for the image if lossy format.
   */
  getImage = async (format = "png" /* PNG */, opts = {}) => {
    const { ids = this.selectedIds.length > 0 ? this.selectedIds : Object.keys(this.page.shapes) } = opts;
    const svg = await this.getSvg(ids);
    if (!svg)
      return;
    if (format === "svg" /* SVG */) {
      const svgString = TLDR.getSvgString(svg, 1);
      const blob = new Blob([svgString], { type: "image/svg+xml" });
      return blob;
    }
    const imageBlob = await TLDR.getImageForSvg(svg, format, opts);
    if (!imageBlob)
      return;
    return imageBlob;
  };
  /**
   * Copy an image of the selected shapes.
   *
   * @param format The format to export the image as.
   * @param opts (optional) An object containing options for the image.
   * @param opts.ids (optional) The ids of the shapes (on the current page) to get an image for.
   * @param opts.scale (optional) The id of the page from which to get an image.
   * @param opts.quality (optional) The quality (between 0 and 1) for the image if lossy format.
   */
  copyImage = async (format = "png" /* PNG */, opts = {}) => {
    if (format === "svg" /* SVG */) {
      await this.copySvg(opts.ids);
      return;
    }
    if (!(navigator.clipboard && window.ClipboardItem)) {
      console.warn("Sorry, your browser does not support copying images.");
      return;
    }
    const blob = await this.getImage(format, opts);
    if (!blob)
      return;
    await navigator.clipboard.write([
      new ClipboardItem({
        [blob.type]: blob
      })
    ]);
  };
  exportImage = async (format = "png" /* PNG */, opts = {}) => {
    const { pageId = this.currentPageId } = opts;
    const blob = await this.getImage(format, opts);
    if (!blob)
      return;
    const name = this.document.pages[pageId].name ?? "export";
    if (this.callbacks.onExport) {
      await this.callbacks.onExport(this, {
        name,
        type: format,
        blob
      });
    } else {
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `${name}.${format}`;
      link.click();
    }
  };
  /* -------------------------------------------------- */
  /*                       Camera                       */
  /* -------------------------------------------------- */
  /**
   * Set the camera to a specific point and zoom.
   * @param point The camera point (top left of the viewport).
   * @param zoom The zoom level.
   * @param reason Why did the camera change?
   */
  setCamera = (point, zoom, reason) => {
    this.updateViewport(point, zoom);
    this.patchState(
      {
        document: {
          pageStates: {
            [this.currentPageId]: { camera: { point, zoom } }
          }
        }
      },
      reason
    );
    return this;
  };
  /**
   * Reset the camera to the default position
   */
  resetCamera = () => {
    return this.setCamera(this.centerPoint, 1, `reset_camera`);
  };
  /**
   * Pan the camera
   * @param delta
   */
  pan = (delta) => {
    const { camera } = this.pageState;
    return this.setCamera(e.toFixed(e.sub(camera.point, delta)), camera.zoom, `panned`);
  };
  /**
   * Pinch to a new zoom level, possibly together with a pan.
   * @param point The current point under the cursor.
   * @param delta The movement delta.
   * @param zoomDelta The zoom detal
   */
  pinchZoom = (point, delta, zoom) => {
    const { camera } = this.pageState;
    const nextPoint = e.sub(camera.point, e.div(delta, camera.zoom));
    const nextZoom = zoom;
    const p0 = e.sub(e.div(point, camera.zoom), nextPoint);
    const p1 = e.sub(e.div(point, nextZoom), nextPoint);
    return this.setCamera(e.toFixed(e.add(nextPoint, e.sub(p1, p0))), nextZoom, `pinch_zoomed`);
  };
  /**
   * Zoom to a new zoom level, keeping the point under the cursor in the same position
   * @param next The new zoom level.
   * @param center The point to zoom towards (defaults to screen center).
   */
  zoomTo = (next, center = this.centerPoint) => {
    const { zoom, point } = this.camera;
    const p0 = e.sub(e.div(center, zoom), point);
    const p1 = e.sub(e.div(center, next), point);
    return this.setCamera(e.toFixed(e.add(point, e.sub(p1, p0))), next, `zoomed_camera`);
  };
  /**
   * Zoom out by 25%
   */
  zoomIn = () => {
    const i4 = Math.round(this.camera.zoom * 100 / 25);
    const nextZoom = TLDR.getCameraZoom((i4 + 1) * 0.25);
    return this.zoomTo(nextZoom);
  };
  /**
   * Zoom in by 25%.
   */
  zoomOut = () => {
    const i4 = Math.round(this.camera.zoom * 100 / 25);
    const nextZoom = TLDR.getCameraZoom((i4 - 1) * 0.25);
    return this.zoomTo(nextZoom);
  };
  /**
   * Zoom to fit the page's shapes.
   */
  zoomToFit = () => {
    const {
      shapes,
      pageState: { camera }
    } = this;
    if (shapes.length === 0)
      return this;
    const { rendererBounds } = this;
    const commonBounds = C3.getCommonBounds(shapes.map(TLDR.getBounds));
    let zoom = TLDR.getCameraZoom(
      Math.min((rendererBounds.width - FIT_TO_SCREEN_PADDING) / commonBounds.width, (rendererBounds.height - FIT_TO_SCREEN_PADDING) / commonBounds.height)
    );
    zoom = camera.zoom === zoom || camera.zoom < 1 ? Math.min(1, zoom) : zoom;
    const mx = (rendererBounds.width - commonBounds.width * zoom) / 2 / zoom;
    const my = (rendererBounds.height - commonBounds.height * zoom) / 2 / zoom;
    return this.setCamera(e.toFixed(e.sub([mx, my], [commonBounds.minX, commonBounds.minY])), zoom, `zoomed_to_fit`);
  };
  /**
   * Zoom to the selected shapes.
   */
  zoomToSelection = () => {
    if (this.selectedIds.length === 0)
      return this;
    const { rendererBounds } = this;
    const selectedBounds = TLDR.getSelectedBounds(this.state);
    let zoom = TLDR.getCameraZoom(
      Math.min((rendererBounds.width - FIT_TO_SCREEN_PADDING) / selectedBounds.width, (rendererBounds.height - FIT_TO_SCREEN_PADDING) / selectedBounds.height)
    );
    zoom = this.camera.zoom === zoom || this.camera.zoom < 1 ? Math.min(1, zoom) : zoom;
    const mx = (rendererBounds.width - selectedBounds.width * zoom) / 2 / zoom;
    const my = (rendererBounds.height - selectedBounds.height * zoom) / 2 / zoom;
    return this.setCamera(e.toFixed(e.sub([mx, my], [selectedBounds.minX, selectedBounds.minY])), zoom, `zoomed_to_selection`);
  };
  /**
   * Zoom back to content when the canvas is empty.
   */
  zoomToContent = () => {
    const shapes = this.shapes;
    const pageState = this.pageState;
    if (shapes.length === 0)
      return this;
    const { rendererBounds } = this;
    const { zoom } = pageState.camera;
    const commonBounds = C3.getCommonBounds(shapes.map(TLDR.getBounds));
    const mx = (rendererBounds.width - commonBounds.width * zoom) / 2 / zoom;
    const my = (rendererBounds.height - commonBounds.height * zoom) / 2 / zoom;
    return this.setCamera(e.toFixed(e.sub([mx, my], [commonBounds.minX, commonBounds.minY])), this.camera.zoom, `zoomed_to_content`);
  };
  /**
   * Zoom the camera to 100%.
   */
  resetZoom = () => {
    return this.zoomTo(1);
  };
  /**
   * Zoom the camera by a certain delta.
   * @param delta The zoom delta.
   * @param center The point to zoom toward.
   */
  zoomBy = C3.throttle((delta, center) => {
    const { zoom } = this.camera;
    const nextZoom = TLDR.getCameraZoom(zoom - delta * zoom);
    return this.zoomTo(nextZoom, center);
  }, 16);
  /* -------------------------------------------------- */
  /*                      Selection                     */
  /* -------------------------------------------------- */
  /**
   * Clear the selection history (undo/redo stack for selection).
   */
  clearSelectHistory = () => {
    this.selectHistory.pointer = 0;
    this.selectHistory.stack = [this.selectedIds];
    return this;
  };
  /**
   * Adds a selection to the selection history (undo/redo stack for selection).
   */
  addToSelectHistory = (ids) => {
    if (this.selectHistory.pointer < this.selectHistory.stack.length) {
      this.selectHistory.stack = this.selectHistory.stack.slice(0, this.selectHistory.pointer + 1);
    }
    this.selectHistory.pointer++;
    this.selectHistory.stack.push(ids);
    return this;
  };
  /**
   * Set the current selection.
   * @param ids The ids to select
   * @param push Whether to add the ids to the current selection instead.
   */
  setSelectedIds = (ids, push = false) => {
    const nextIds = push ? [...this.pageState.selectedIds, ...ids] : [...ids];
    return this.patchState(
      {
        appState: {
          activeTool: "select"
        },
        document: {
          pageStates: {
            [this.currentPageId]: {
              selectedIds: nextIds
            }
          }
        }
      },
      `selected`
    );
  };
  /**
   * Undo the most recent selection.
   */
  undoSelect = () => {
    if (this.selectHistory.pointer > 0) {
      this.selectHistory.pointer--;
      this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer]);
    }
    return this;
  };
  /**
   * Redo the previous selection.
   */
  redoSelect = () => {
    if (this.selectHistory.pointer < this.selectHistory.stack.length - 1) {
      this.selectHistory.pointer++;
      this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer]);
    }
    return this;
  };
  /**
   * Select one or more shapes.
   * @param ids The shape ids to select.
   */
  select = (...ids) => {
    ids.forEach((id) => {
      if (!this.page.shapes[id]) {
        throw new Error(`That shape does not exist on page ${this.currentPageId}`);
      }
    });
    this.setSelectedIds(ids);
    this.addToSelectHistory(ids);
    return this;
  };
  /**
   * Select all shapes on the page.
   */
  selectAll = (pageId = this.currentPageId) => {
    if (this.session)
      return this;
    this.setSelectedIds(
      Object.values(this.document.pages[pageId].shapes).filter((shape) => shape.parentId === pageId).map((shape) => shape.id)
    );
    this.addToSelectHistory(this.selectedIds);
    this.selectTool("select");
    return this;
  };
  /**
   * Deselect any selected shapes.
   */
  selectNone = () => {
    this.setSelectedIds([]);
    this.addToSelectHistory(this.selectedIds);
    return this;
  };
  /* -------------------------------------------------- */
  /*                      Sessions                 p      */
  /* -------------------------------------------------- */
  /**
   * Start a new session.
   * @param type The session type
   * @param args arguments of the session's start method.
   */
  startSession = (type, ...args) => {
    if (this.readOnly && type !== "brush" /* Brush */)
      return this;
    if (this.session) {
      TLDR.warn(`Already in a session! (${this.session.constructor.name})`);
      this.cancelSession();
    }
    const Session = getSession(type);
    this.session = new Session(this, ...args);
    const result = this.session.start();
    if (result) {
      this.patchState(result, `session:start_${this.session.constructor.name}`);
    }
    this.callbacks.onSessionStart?.(this, this.session.constructor.name);
    return this;
  };
  /**
   * updateSession.
   * @param args The arguments of the current session's update method.
   */
  updateSession = () => {
    const { session } = this;
    if (!session)
      return this;
    const patch = session.update();
    if (!patch)
      return this;
    return this.patchState(patch, `session:${session?.constructor.name}`);
  };
  /**
   * Cancel the current session.
   * @param args The arguments of the current session's cancel method.
   */
  cancelSession = () => {
    const { session } = this;
    if (!session)
      return this;
    this.session = void 0;
    const result = session.cancel();
    if (result) {
      this.patchState(result, `session:cancel:${session.constructor.name}`);
    }
    this.setEditingId();
    this.callbacks.onSessionEnd?.(this, session.constructor.name);
    return this;
  };
  /**
   * Complete the current session.
   * @param args The arguments of the current session's complete method.
   */
  completeSession = () => {
    const { session } = this;
    if (!session)
      return this;
    this.session = void 0;
    const result = session.complete();
    if (result === void 0) {
      this.isCreating = false;
      this.patchState(
        {
          appState: {
            status: "idle" /* Idle */
          },
          document: {
            pageStates: {
              [this.currentPageId]: {
                editingId: void 0,
                bindingId: void 0,
                hoveredId: void 0
              }
            }
          }
        },
        `session:complete:${session.constructor.name}`
      );
    } else if ("after" in result) {
      if (this.isCreating) {
        result.before = {
          appState: {
            ...result.before.appState,
            status: "idle" /* Idle */
          },
          document: {
            pages: {
              [this.currentPageId]: {
                shapes: Object.fromEntries(this.selectedIds.map((id) => [id, void 0]))
              }
            },
            pageStates: {
              [this.currentPageId]: {
                selectedIds: [],
                editingId: null,
                bindingId: null,
                hoveredId: null
              }
            }
          }
        };
        if (this.appState.isToolLocked) {
          const pageState = result.after?.document?.pageStates?.[this.currentPageId] || {};
          pageState.selectedIds = [];
        }
        this.isCreating = false;
      }
      result.after.appState = {
        ...result.after.appState,
        status: "idle" /* Idle */
      };
      result.after.document = {
        ...result.after.document,
        pageStates: {
          ...result.after.document?.pageStates,
          [this.currentPageId]: {
            ...(result.after.document?.pageStates || {})[this.currentPageId],
            editingId: null
          }
        }
      };
      this.setState(result, `session:complete:${session.constructor.name}`);
    } else {
      this.patchState(
        {
          ...result,
          appState: {
            ...result.appState,
            status: "idle" /* Idle */
          },
          document: {
            ...result.document,
            pageStates: {
              [this.currentPageId]: {
                ...result.document?.pageStates?.[this.currentPageId],
                editingId: null
              }
            }
          }
        },
        `session:complete:${session.constructor.name}`
      );
    }
    this.callbacks.onSessionEnd?.(this, session.constructor.name);
    return this;
  };
  /* -------------------------------------------------- */
  /*                   Shape Functions                  */
  /* -------------------------------------------------- */
  /**
   * Manually create shapes on the page.
   * @param shapes An array of shape partials, containing the initial props for the shapes.
   * @command
   */
  createShapes = (...shapes) => {
    if (shapes.length === 0)
      return this;
    return this.create(
      shapes.map((shape) => {
        return TLDR.getShapeUtil(shape.type).create({
          parentId: this.currentPageId,
          ...shape
        });
      })
    );
  };
  /**
   * Manually update a set of shapes.
   * @param shapes An array of shape partials, containing the changes to be made to each shape.
   * @command
   */
  updateShapes = (...shapes) => {
    const pageShapes = this.document.pages[this.currentPageId].shapes;
    const shapesToUpdate = shapes.filter((shape) => pageShapes[shape.id]);
    if (shapesToUpdate.length === 0)
      return this;
    return this.setState(updateShapes(this, shapesToUpdate, this.currentPageId), "updated_shapes");
  };
  createTextShapeAtPoint(point, id, patch) {
    const {
      shapes,
      appState: { currentPageId, currentStyle }
    } = this;
    const childIndex = shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === currentPageId).sort((a7, b6) => b6.childIndex - a7.childIndex)[0].childIndex + 1;
    const Text2 = shapeUtils["text" /* Text */];
    const newShape = Text2.create({
      id: id || C3.uniqueId(),
      parentId: currentPageId,
      childIndex,
      point,
      style: { ...currentStyle }
    });
    const bounds = Text2.getBounds(newShape);
    newShape.point = e.sub(newShape.point, [bounds.width / 2, bounds.height / 2]);
    if (patch) {
      this.patchCreate([TLDR.getShapeUtil(newShape.type).create(newShape)]);
    } else {
      this.createShapes(newShape);
    }
    this.setEditingId(newShape.id, true);
    return this;
  }
  getImageShapeAtPoint(id, type, point, size, assetId) {
    const {
      shapes,
      appState: { currentPageId, currentStyle }
    } = this;
    const childIndex = shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === currentPageId).sort((a7, b6) => b6.childIndex - a7.childIndex)[0].childIndex + 1;
    const Shape = shapeUtils[type];
    if (size[0] > this.viewport.width) {
      const r5 = size[1] / size[0];
      size[0] = this.viewport.width - FIT_TO_SCREEN_PADDING / this.camera.zoom * 2;
      size[1] = size[0] * r5;
      if (size[1] < 32 || size[1] < 32) {
        size[1] = 32;
        size[0] = size[1] / r5;
      }
    } else if (size[1] > this.viewport.height) {
      const r5 = size[0] / size[1];
      size[1] = this.viewport.height - FIT_TO_SCREEN_PADDING / this.camera.zoom * 2;
      size[0] = size[1] * r5;
      if (size[1] < 32 || size[1] < 32) {
        size[0] = 32;
        size[1] = size[0] / r5;
      }
    }
    const newShape = Shape.create({
      id,
      parentId: currentPageId,
      childIndex,
      point,
      size,
      style: { ...currentStyle },
      assetId
    });
    return newShape;
  }
  /**
   * Create one or more shapes.
   * @param shapes An array of shapes.
   * @command
   */
  create = (shapes = [], bindings = []) => {
    if (shapes.length === 0)
      return this;
    return this.setState(createShapes(this, shapes, bindings));
  };
  /**
   * Patch in a new set of shapes
   * @param shapes
   * @param bindings
   */
  patchCreate = (shapes = [], bindings = []) => {
    if (shapes.length === 0)
      return this;
    return this.patchState(createShapes(this, shapes, bindings).after);
  };
  /**
   * Delete one or more shapes.
   * @param ids The ids of the shapes to delete.
   * @command
   */
  delete = (ids = this.selectedIds) => {
    if (ids.length === 0)
      return this;
    if (this.session)
      return this;
    const drawCommand = deleteShapes(this, ids);
    if (this.callbacks.onAssetDelete && drawCommand.before.document?.assets && drawCommand.after.document?.assets) {
      const beforeAssetIds = Object.keys(drawCommand.before.document.assets).filter((k7) => !!drawCommand.before.document.assets[k7]);
      const afterAssetIds = new Set(Object.keys(drawCommand.after.document.assets).filter((k7) => !!drawCommand.after.document.assets[k7]));
      const intersection = beforeAssetIds.filter((x5) => !afterAssetIds.has(x5));
      intersection.forEach((id) => this.callbacks.onAssetDelete(this, id));
    }
    return this.setState(drawCommand);
  };
  /**
   * Delete all shapes on the page.
   */
  deleteAll = () => {
    this.selectAll();
    this.delete();
    return this;
  };
  /**
   * Change the style for one or more shapes.
   * @param style A style partial to apply to the shapes.
   * @param ids The ids of the shapes to change (defaults to selection).
   */
  style = (style, ids = this.selectedIds) => {
    return this.setState(styleShapes(this, ids, style));
  };
  /**
   * Align one or more shapes.
   * @param direction Whether to align horizontally or vertically.
   * @param ids The ids of the shapes to change (defaults to selection).
   */
  align = (type, ids = this.selectedIds) => {
    if (ids.length < 2)
      return this;
    return this.setState(alignShapes(this, ids, type));
  };
  /**
   * Distribute one or more shapes.
   * @param direction Whether to distribute horizontally or vertically..
   * @param ids The ids of the shapes to change (defaults to selection).
   */
  distribute = (direction, ids = this.selectedIds) => {
    if (ids.length < 3)
      return this;
    return this.setState(distributeShapes(this, ids, direction));
  };
  /**
   * Stretch one or more shapes to their common bounds.
   * @param direction Whether to stretch horizontally or vertically.
   * @param ids The ids of the shapes to change (defaults to selection).
   */
  stretch = (direction, ids = this.selectedIds) => {
    if (ids.length < 2)
      return this;
    return this.setState(stretchShapes(this, ids, direction));
  };
  /**
   * Flip one or more shapes horizontally.
   * @param ids The ids of the shapes to change (defaults to selection).
   */
  flipHorizontal = (ids = this.selectedIds) => {
    if (ids.length === 0)
      return this;
    return this.setState(flipShapes(this, ids, "horizontal" /* Horizontal */));
  };
  /**
   * Flip one or more shapes vertically.
   * @param ids The ids of the shapes to change (defaults to selection).
   */
  flipVertical = (ids = this.selectedIds) => {
    if (ids.length === 0)
      return this;
    return this.setState(flipShapes(this, ids, "vertical" /* Vertical */));
  };
  /**
   * Move one or more shapes to a new page. Will also break or move bindings.
   * @param toPageId The id of the page to move the shapes to.
   * @param fromPageId The id of the page to move the shapes from (defaults to current page).
   * @param ids The ids of the shapes to move (defaults to selection).
   */
  moveToPage = (toPageId, fromPageId = this.currentPageId, ids = this.selectedIds) => {
    if (ids.length === 0)
      return this;
    const { rendererBounds } = this;
    this.setState(moveShapesToPage(this, ids, rendererBounds, fromPageId, toPageId));
    return this;
  };
  /**
   * Move one or more shapes to the back of the page.
   * @param ids The ids of the shapes to change (defaults to selection).
   */
  moveToBack = (ids = this.selectedIds) => {
    if (ids.length === 0)
      return this;
    return this.setState(reorderShapes(this, ids, "toBack" /* ToBack */));
  };
  /**
   * Move one or more shapes backward on of the page.
   * @param ids The ids of the shapes to change (defaults to selection).
   */
  moveBackward = (ids = this.selectedIds) => {
    if (ids.length === 0)
      return this;
    return this.setState(reorderShapes(this, ids, "backward" /* Backward */));
  };
  /**
   * Move one or more shapes forward on the page.
   * @param ids The ids of the shapes to change (defaults to selection).
   */
  moveForward = (ids = this.selectedIds) => {
    if (ids.length === 0)
      return this;
    return this.setState(reorderShapes(this, ids, "forward" /* Forward */));
  };
  /**
   * Move one or more shapes to the front of the page.
   * @param ids The ids of the shapes to change (defaults to selection).
   */
  moveToFront = (ids = this.selectedIds) => {
    if (ids.length === 0)
      return this;
    return this.setState(reorderShapes(this, ids, "toFront" /* ToFront */));
  };
  /**
   * Nudge one or more shapes in a direction.
   * @param delta The direction to nudge the shapes.
   * @param isMajor Whether this is a major (i.e. shift) nudge.
   * @param ids The ids to change (defaults to selection).
   */
  nudge = (delta, isMajor = false, ids = this.selectedIds) => {
    if (ids.length === 0)
      return this;
    const size = isMajor ? this.settings.showGrid ? this.currentGrid * 4 : 10 : this.settings.showGrid ? this.currentGrid : 1;
    return this.setState(translateShapes(this, ids, e.mul(delta, size)));
  };
  /**
   * Duplicate one or more shapes.
   * @param ids The ids to duplicate (defaults to selection).
   */
  duplicate = (ids = this.selectedIds, point) => {
    if (this.readOnly)
      return this;
    if (ids.length === 0)
      return this;
    return this.setState(duplicateShapes(this, ids, point));
  };
  /**
   * Reset the bounds for one or more shapes. Usually when the
   * bounding box of a shape is double-clicked. Different shapes may
   * handle this differently.
   * @param ids The ids to change (defaults to selection).
   */
  resetBounds = (ids = this.selectedIds) => {
    const command = resetBounds(this, ids, this.currentPageId);
    return this.setState(resetBounds(this, ids, this.currentPageId), command.id);
  };
  /**
   * Toggle the hidden property of one or more shapes.
   * @param ids The ids to change (defaults to selection).
   */
  toggleHidden = (ids = this.selectedIds) => {
    if (ids.length === 0)
      return this;
    return this.setState(toggleShapeProp(this, ids, "isHidden"));
  };
  /**
   * Toggle the locked property of one or more shapes.
   * @param ids The ids to change (defaults to selection).
   */
  toggleLocked = (ids = this.selectedIds) => {
    if (ids.length === 0)
      return this;
    return this.setState(toggleShapeProp(this, ids, "isLocked"));
  };
  /**
   * Toggle the fixed-aspect-ratio property of one or more shapes.
   * @param ids The ids to change (defaults to selection).
   */
  toggleAspectRatioLocked = (ids = this.selectedIds) => {
    if (ids.length === 0)
      return this;
    return this.setState(toggleShapeProp(this, ids, "isAspectRatioLocked"));
  };
  /**
   * Toggle the decoration at a handle of one or more shapes.
   * @param handleId The handle to toggle.
   * @param ids The ids of the shapes to toggle the decoration on.
   */
  toggleDecoration = (handleId, ids = this.selectedIds) => {
    if (ids.length === 0 || !(handleId === "start" || handleId === "end"))
      return this;
    return this.setState(toggleShapesDecoration(this, ids, handleId));
  };
  /**
   * Set the props of one or more shapes
   * @param props The props to set on the shapes.
   * @param ids The ids of the shapes to set props on.
   */
  setShapeProps = (props, ids = this.selectedIds) => {
    return this.setState(setShapesProps(this, ids, props));
  };
  /**
   * Rotate one or more shapes by a delta.
   * @param delta The delta in radians.
   * @param ids The ids to rotate (defaults to selection).
   */
  rotate = (delta = Math.PI * -0.5, ids = this.selectedIds) => {
    if (ids.length === 0)
      return this;
    const change = rotateShapes(this, ids, delta);
    if (!change)
      return this;
    return this.setState(change);
  };
  /**
   * Group the selected shapes.
   * @param ids The ids to group (defaults to selection).
   * @param groupId The new group's id.
   */
  group = (ids = this.selectedIds, groupId = C3.uniqueId(), pageId = this.currentPageId) => {
    if (this.readOnly)
      return this;
    if (ids.length === 1 && this.getShape(ids[0], pageId).type === "group" /* Group */) {
      return this.ungroup(ids, pageId);
    }
    if (ids.length < 2)
      return this;
    const command = groupShapes(this, ids, groupId, pageId);
    if (!command)
      return this;
    return this.setState(command);
  };
  /**
   * Ungroup the selected groups.
   * @todo
   */
  ungroup = (ids = this.selectedIds, pageId = this.currentPageId) => {
    if (this.readOnly)
      return this;
    const groups = ids.map((id) => this.getShape(id, pageId)).filter((shape) => shape.type === "group" /* Group */);
    if (groups.length === 0)
      return this;
    const command = ungroupShapes(this, ids, groups, pageId);
    if (!command) {
      return this;
    }
    return this.setState(command);
  };
  /**
   * Cancel the current session.
   */
  cancel = () => {
    this.currentTool.onCancel?.();
    return this;
  };
  addMediaFromFiles = async (files, point = this.centerPoint) => {
    this.setIsLoading(true);
    const shapesToCreate = [];
    const pagePoint = this.getPagePoint(point);
    for (const file of files) {
      const id = C3.uniqueId();
      const extension = file.name.match(/\.[\da-z]+$/i);
      if (!extension)
        throw new Error("No extension");
      const isImage = IMAGE_EXTENSIONS.includes(extension[0].toLowerCase());
      if (!isImage)
        throw new Error("Wrong extension");
      const shapeType = "image" /* Image */;
      const assetType = "image" /* Image */;
      let src;
      try {
        if (this.callbacks.onAssetCreate) {
          const result = await this.callbacks.onAssetCreate(this, file, id);
          if (!result)
            throw new Error("Asset creation callback returned false");
          src = result;
        } else {
          src = await fileToBase64(file);
        }
        if (typeof src === "string") {
          let size = [0, 0];
          if (isImage) {
            if (extension[0] == ".svg") {
              let viewBox;
              const svgString = await fileToText(file);
              const viewBoxAttribute = this.getViewboxFromSVG(svgString);
              if (viewBoxAttribute) {
                viewBox = viewBoxAttribute.split(" ");
                size[0] = Number.parseFloat(viewBox[2]);
                size[1] = Number.parseFloat(viewBox[3]);
              }
            }
            if (e.isEqual(size, [0, 0])) {
              size = await getImageSizeFromSrc(src);
            }
          }
          const match = Object.values(this.document.assets).find((asset) => asset.type === assetType && asset.src === src);
          let assetId;
          if (match) {
            assetId = match.id;
          } else {
            assetId = id;
            const asset = {
              id: assetId,
              type: assetType,
              name: file.name,
              src,
              size
            };
            this.patchState({
              document: {
                assets: {
                  [assetId]: asset
                }
              }
            });
          }
          shapesToCreate.push(this.getImageShapeAtPoint(id, shapeType, point, size, assetId));
        }
      } catch (error) {
        console.warn(error);
      }
    }
    if (shapesToCreate.length > 0) {
      const currentPoint = e.add(pagePoint, [0, 0]);
      shapesToCreate.forEach((shape, i4) => {
        const bounds = TLDR.getBounds(shape);
        if (i4 === 0) {
          currentPoint[0] -= bounds.width / 2;
          currentPoint[1] -= bounds.height / 2;
        }
        shape.point = [...currentPoint];
        currentPoint[0] += bounds.width;
      });
      const commonBounds = C3.getCommonBounds(shapesToCreate.map(TLDR.getBounds));
      this.createShapes(...shapesToCreate);
      if (!C3.boundsContain(this.viewport, commonBounds)) {
        this.zoomToSelection();
        if (this.zoom > 1) {
          this.resetZoom();
        }
      }
    }
    this.setIsLoading(false);
    return this;
  };
  getViewboxFromSVG = (svgStr) => {
    const viewBoxRegex = /.*?viewBox=["'](-?[\d.]+[ ,]+-?(?:[\d.]+[ ,]){2}[\d.]+)["']/;
    if (typeof svgStr === "string") {
      const matches = svgStr.match(viewBoxRegex);
      return matches && matches.length >= 2 ? matches[1] : null;
    }
    this.setIsLoading(false);
    return null;
  };
  /* -------------------------------------------------- */
  /*                   Event Handlers                   */
  /* -------------------------------------------------- */
  /* ----------------- Keyboard Events ---------------- */
  onKeyDown = (key, info, e5) => {
    switch (e5.key) {
      case "/": {
        if (this.status === "idle" && !this.pageState.editingId) {
          const { shiftKey, metaKey, altKey, ctrlKey, spaceKey } = this;
          this.onPointerDown(
            {
              target: "canvas",
              pointerId: 0,
              origin: info.point,
              point: info.point,
              delta: [0, 0],
              pressure: 0.5,
              shiftKey,
              ctrlKey,
              metaKey,
              altKey,
              spaceKey
            },
            {
              shiftKey,
              altKey,
              ctrlKey,
              pointerId: 0,
              clientX: info.point[0],
              clientY: info.point[1]
            }
          );
        }
        break;
      }
      case "Escape": {
        this.cancel();
        break;
      }
      case "Meta": {
        this.metaKey = true;
        break;
      }
      case "Alt": {
        this.altKey = true;
        break;
      }
      case "Control": {
        this.ctrlKey = true;
        break;
      }
      case " ": {
        this.isForcePanning = true;
        this.spaceKey = true;
        break;
      }
    }
    this.currentTool.onKeyDown?.(key, info, e5);
    return this;
  };
  onKeyUp = (key, info, e5) => {
    if (!info)
      return;
    switch (e5.key) {
      case "/": {
        const { currentPoint, shiftKey, metaKey, altKey, ctrlKey, spaceKey } = this;
        this.onPointerUp(
          {
            target: "canvas",
            pointerId: 0,
            origin: currentPoint,
            point: currentPoint,
            delta: [0, 0],
            pressure: 0.5,
            shiftKey,
            ctrlKey,
            metaKey,
            altKey,
            spaceKey
          },
          {
            shiftKey,
            altKey,
            ctrlKey,
            pointerId: 0,
            clientX: currentPoint[0],
            clientY: currentPoint[1]
          }
        );
        break;
      }
      case "Meta": {
        this.metaKey = false;
        break;
      }
      case "Alt": {
        this.altKey = false;
        break;
      }
      case "Control": {
        this.ctrlKey = false;
        break;
      }
      case " ": {
        this.isForcePanning = false;
        this.spaceKey = false;
        break;
      }
    }
    this.currentTool.onKeyUp?.(key, info, e5);
  };
  /** Force bounding boxes to reset when the document loads. */
  refreshBoundingBoxes = () => {
    const force = this.shapes.map((shape) => {
      return [
        shape.id,
        {
          point: [...shape.point],
          ..."label" in shape && { label: "" }
        }
      ];
    });
    const restore = this.shapes.map((shape) => {
      return [
        shape.id,
        {
          point: [...shape.point],
          ..."label" in shape && { label: shape.label }
        }
      ];
    });
    clearPrevSize();
    this.patchState({
      document: {
        pages: {
          [this.currentPageId]: {
            shapes: Object.fromEntries(force)
          }
        }
      }
    });
    this.patchState({
      document: {
        pages: {
          [this.currentPageId]: {
            shapes: Object.fromEntries(restore)
          }
        }
      }
    });
  };
  /* ------------- Renderer Event Handlers ------------ */
  onDragOver = (e5) => {
    e5.preventDefault();
  };
  onDrop = async (e5) => {
    e5.preventDefault();
    if (this.disableAssets)
      return this;
    if (e5.dataTransfer.files?.length) {
      this.addMediaFromFiles(Object.values(e5.dataTransfer.files), [e5.clientX, e5.clientY]);
    }
    return this;
  };
  onPinchStart = (info, e5) => {
    this.currentTool.onPinchStart?.(info, e5);
  };
  onPinchEnd = (info, e5) => this.currentTool.onPinchEnd?.(info, e5);
  onPinch = (info, e5) => this.currentTool.onPinch?.(info, e5);
  onPan = (info, e5) => {
    if (this.appState.status === "pinching")
      return;
    const delta = e.div(info.delta, this.camera.zoom);
    const prev = this.camera.point;
    const next = e.sub(prev, delta);
    if (e.isEqual(next, prev))
      return;
    this.pan(delta);
    if (!this.isForcePanning)
      this.onPointerMove(info, e5);
    if (isLinux && this.isForcePanning)
      this.preventPaste();
  };
  onZoom = (info, e5) => {
    if (this.state.appState.status !== "idle" /* Idle */)
      return;
    const delta = info.delta[2] / 50;
    this.zoomBy(delta, info.point);
    this.onPointerMove(info, e5);
  };
  /* ----------------- Pointer Events ----------------- */
  updateInputs = (info) => {
    this.currentPoint = this.getPagePoint(info.point).concat(info.pressure);
    this.shiftKey = info.shiftKey;
    this.altKey = info.altKey;
    this.ctrlKey = info.ctrlKey;
    this.metaKey = info.metaKey;
  };
  onPointerMove = (info, e5) => {
    this.previousPoint = this.currentPoint;
    this.updateInputs(info, e5);
    if (this.isForcePanning && this.isPointing) {
      this.onPan?.({ ...info, delta: e.neg(info.delta) }, e5);
      return;
    }
    this.currentTool.onPointerMove?.(info, e5);
  };
  onPointerDown = (info, e5) => {
    if (e5.buttons === 4) {
      this.isForcePanning = true;
    } else if (this.isPointing) {
      return;
    }
    this.isPointing = true;
    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
    this.updateInputs(info, e5);
    if (this.isForcePanning)
      return;
    if (this.currentTool.type === "draw" /* Draw */ && e5.pointerType === "pen" && e5.button === 5) {
      this.selectTool("erase");
      this.isErasingWithPen = true;
    }
    this.currentTool.onPointerDown?.(info, e5);
  };
  onPointerUp = (info, e5) => {
    this.isPointing = false;
    if (!this.shiftKey)
      this.isForcePanning = false;
    this.updateInputs(info, e5);
    this.currentTool.onPointerUp?.(info, e5);
    if (this.isErasingWithPen && e5.pointerType === "pen" && e5.button === 5) {
      this.selectTool("draw" /* Draw */);
      this.isErasingWithPen = false;
    }
  };
  // Canvas (background)
  onPointCanvas = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onPointCanvas?.(info, e5);
  };
  onDoubleClickCanvas = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onDoubleClickCanvas?.(info, e5);
  };
  onRightPointCanvas = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onRightPointCanvas?.(info, e5);
  };
  onDragCanvas = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onDragCanvas?.(info, e5);
  };
  onReleaseCanvas = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onReleaseCanvas?.(info, e5);
  };
  // Shape
  onPointShape = (info, e5) => {
    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
    this.updateInputs(info, e5);
    this.currentTool.onPointShape?.(info, e5);
  };
  onReleaseShape = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onReleaseShape?.(info, e5);
  };
  onDoubleClickShape = (info, e5) => {
    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
    this.updateInputs(info, e5);
    this.currentTool.onDoubleClickShape?.(info, e5);
  };
  onRightPointShape = (info, e5) => {
    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
    this.updateInputs(info, e5);
    this.currentTool.onRightPointShape?.(info, e5);
  };
  onDragShape = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onDragShape?.(info, e5);
  };
  onHoverShape = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onHoverShape?.(info, e5);
  };
  onUnhoverShape = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onUnhoverShape?.(info, e5);
  };
  // Bounds (bounding box background)
  onPointBounds = (info, e5) => {
    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
    this.updateInputs(info, e5);
    this.currentTool.onPointBounds?.(info, e5);
  };
  onDoubleClickBounds = (info, e5) => {
    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
    this.updateInputs(info, e5);
    this.currentTool.onDoubleClickBounds?.(info, e5);
  };
  onRightPointBounds = (info, e5) => {
    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
    this.updateInputs(info, e5);
    this.currentTool.onRightPointBounds?.(info, e5);
  };
  onDragBounds = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onDragBounds?.(info, e5);
  };
  onHoverBounds = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onHoverBounds?.(info, e5);
  };
  onUnhoverBounds = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onUnhoverBounds?.(info, e5);
  };
  onReleaseBounds = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onReleaseBounds?.(info, e5);
  };
  // Bounds handles (corners, edges)
  onPointBoundsHandle = (info, e5) => {
    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
    this.updateInputs(info, e5);
    this.currentTool.onPointBoundsHandle?.(info, e5);
  };
  onDoubleClickBoundsHandle = (info, e5) => {
    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
    this.updateInputs(info, e5);
    this.currentTool.onDoubleClickBoundsHandle?.(info, e5);
    if (this.selectedIds.length !== 1)
      return;
    const shape = this.getShape(this.selectedIds[0]);
    if (shape.type === "image" /* Image */) {
      const asset = this.document.assets[shape.assetId];
      const util = TLDR.getShapeUtil(shape);
      const centerA = util.getCenter(shape);
      const centerB = util.getCenter({ ...shape, size: asset.size });
      const delta = e.sub(centerB, centerA);
      this.updateShapes({
        id: shape.id,
        point: e.sub(shape.point, delta),
        size: asset.size
      });
    }
  };
  onRightPointBoundsHandle = (info, e5) => {
    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
    this.updateInputs(info, e5);
    this.currentTool.onRightPointBoundsHandle?.(info, e5);
  };
  onDragBoundsHandle = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onDragBoundsHandle?.(info, e5);
  };
  onHoverBoundsHandle = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onHoverBoundsHandle?.(info, e5);
  };
  onUnhoverBoundsHandle = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onUnhoverBoundsHandle?.(info, e5);
  };
  onReleaseBoundsHandle = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onReleaseBoundsHandle?.(info, e5);
  };
  // Handles (ie the handles of a selected arrow)
  onPointHandle = (info, e5) => {
    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
    this.updateInputs(info, e5);
    this.currentTool.onPointHandle?.(info, e5);
  };
  onDoubleClickHandle = (info, e5) => {
    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
    this.updateInputs(info, e5);
    this.currentTool.onDoubleClickHandle?.(info, e5);
  };
  onRightPointHandle = (info, e5) => {
    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
    this.updateInputs(info, e5);
    this.currentTool.onRightPointHandle?.(info, e5);
  };
  onDragHandle = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onDragHandle?.(info, e5);
  };
  onHoverHandle = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onHoverHandle?.(info, e5);
  };
  onUnhoverHandle = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onUnhoverHandle?.(info, e5);
  };
  onReleaseHandle = (info, e5) => {
    this.updateInputs(info, e5);
    this.currentTool.onReleaseHandle?.(info, e5);
  };
  onShapeChange = (shape) => {
    const pageShapes = this.document.pages[this.currentPageId].shapes;
    const shapeToUpdate = { ...pageShapes[shape.id], ...shape };
    const patch = updateShapes(this, [shapeToUpdate], this.currentPageId).after;
    return this.patchState(patch, "patched_shapes");
  };
  onShapeBlur = () => {
    if (performance.now() - this.editingStartTime < 50)
      return;
    const { editingId } = this.pageState;
    const { isToolLocked } = this.getAppState();
    if (editingId) {
      const shape = this.getShape(editingId);
      this.setEditingId();
      if (shape.type === "text" /* Text */) {
        if (shape.text.trim().length <= 0) {
          this.patchState(deleteShapes(this, [editingId]).after, "delete_empty_text");
        } else if (!isToolLocked) {
          this.select(editingId);
        }
      }
    }
    this.currentTool.onShapeBlur?.();
  };
  onShapeClone = (info, e5) => {
    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
    this.updateInputs(info, e5);
    this.currentTool.onShapeClone?.(info, e5);
  };
  onRenderCountChange = (ids) => {
    const appState = this.getAppState();
    if (appState.isEmptyCanvas && ids.length > 0) {
      this.patchState(
        {
          appState: {
            isEmptyCanvas: false
          }
        },
        "empty_canvas:false"
      );
    } else if (!appState.isEmptyCanvas && ids.length <= 0) {
      this.patchState(
        {
          appState: {
            isEmptyCanvas: true
          }
        },
        "empty_canvas:true"
      );
    }
  };
  onError = () => {
  };
  isSelected(id) {
    return this.selectedIds.includes(id);
  }
  /* ----------------- Export ----------------- */
  /**
   * Get a snapshot of a image (e.g. a GIF) as base64 encoded image
   * @param id ID of image shape
   * @returns base64 encoded frame
   * @throws Error if image shape with given ID does not exist
   */
  serializeImage(id) {
    const image = document.getElementById(id + "_image");
    if (image) {
      const canvas = document.createElement("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      canvas.getContext("2d").drawImage(image, 0, 0);
      return canvas.toDataURL("image/png");
    } else
      throw new Error("Image with id " + id + " not found");
  }
  patchAssets(assets) {
    this.document.assets = {
      ...this.document.assets,
      ...assets
    };
  }
  get status() {
    return this.appState.status;
  }
  // The center of the component (in screen space)
  get centerPoint() {
    const { width, height } = this.rendererBounds;
    return e.toFixed([width / 2, height / 2]);
  }
  get currentGrid() {
    const { zoom } = this.camera;
    if (zoom < 0.15) {
      return GRID_SIZE * 16;
    } else if (zoom < 1) {
      return GRID_SIZE * 4;
    } else {
      return GRID_SIZE * 1;
    }
  }
  getShapeUtil = TLDR.getShapeUtil;
};
var TldrawApp = _TldrawApp;
__publicField(TldrawApp, "version", 15.5);
__publicField(TldrawApp, "defaultDocument", {
  id: "doc",
  name: "New Document",
  version: _TldrawApp.version,
  pages: {
    page: {
      id: "page",
      name: "Page 1",
      childIndex: 1,
      shapes: {},
      bindings: {}
    }
  },
  pageStates: {
    page: {
      id: "page",
      selectedIds: [],
      camera: {
        point: [0, 0],
        zoom: 1
      }
    }
  },
  assets: {}
});
__publicField(TldrawApp, "defaultState", {
  settings: {
    isCadSelectMode: false,
    isPenMode: false,
    isZoomSnap: false,
    isFocusMode: false,
    isSnapping: false,
    isDebugMode: false,
    isReadonlyMode: false,
    keepStyleMenuOpen: false,
    nudgeDistanceLarge: 16,
    nudgeDistanceSmall: 1,
    showRotateHandles: true,
    showBindingHandles: true,
    showCloneHandles: false,
    showGrid: false,
    language: "en",
    dockPosition: "bottom",
    exportBackground: "transparent" /* Transparent */
  },
  appState: {
    activeTool: "select",
    currentPageId: "page",
    currentStyle: defaultStyle,
    disableAssets: false,
    eraseLine: [],
    hoveredId: void 0,
    isEmptyCanvas: false,
    isLoading: false,
    isMenuOpen: false,
    isToolLocked: false,
    mouseInBound: false,
    snapLines: [],
    status: "idle" /* Idle */
  },
  document: _TldrawApp.defaultDocument
});
__publicField(TldrawApp, "assetSrc", "tldraw-assets.json");

// src/components/Tldraw/state/tools/index.ts
var tools = {
  select: SelectTool,
  erase: EraseTool,
  ["text" /* Text */]: TextTool,
  ["draw" /* Draw */]: DrawTool,
  ["ellipse" /* Ellipse */]: EllipseTool,
  ["rectangle" /* Rectangle */]: RectangleTool,
  ["triangle" /* Triangle */]: TriangleTool,
  ["line" /* Line */]: LineTool,
  ["arrow" /* Arrow */]: ArrowTool,
  ["sticky" /* Sticky */]: StickyTool
};

// src/components/Tldraw/Tldraw.tsx
var import_jsx_runtime67 = require("react/jsx-runtime");
function Tldraw({
  id,
  document: document2,
  currentPageId,
  autofocus = true,
  showMenu = true,
  showPages = true,
  showTools = true,
  showZoom = true,
  showStyles = true,
  showUI = true,
  readOnly = false,
  disableAssets = false,
  components,
  onMount,
  onChange,
  onOpenMedia,
  onUndo,
  onRedo,
  onPersist,
  onPatch,
  onCommand,
  onChangePage,
  onAssetCreate,
  onAssetDelete,
  onAssetUpload,
  onSessionStart,
  onSessionEnd,
  onExport,
  hideCursors,
  onLoaded
}) {
  const [sId, setSId] = React49.useState(id);
  const [app, setApp] = React49.useState(() => {
    const app2 = new TldrawApp(id, {
      onMount,
      onChange,
      onOpenMedia,
      onUndo,
      onRedo,
      onPersist,
      onPatch,
      onCommand,
      onChangePage,
      onAssetDelete,
      onAssetCreate,
      onAssetUpload,
      onSessionStart,
      onSessionEnd
    });
    return app2;
  });
  const [onCancel, setOnCancel] = React49.useState(null);
  const [onYes, setOnYes] = React49.useState(null);
  const [onNo, setOnNo] = React49.useState(null);
  const [dialogState, setDialogState] = React49.useState(null);
  const openDialog = React49.useCallback((dialogState2, onYes2, onNo2, onCancel2) => {
    setDialogState(() => dialogState2);
    setOnCancel(() => onCancel2);
    setOnYes(() => onYes2);
    setOnNo(() => onNo2);
  }, []);
  React49.useLayoutEffect(() => {
    if (id === sId)
      return;
    const newApp = new TldrawApp(id, {
      onMount,
      onChange,
      onOpenMedia,
      onUndo,
      onRedo,
      onPersist,
      onPatch,
      onCommand,
      onChangePage,
      onAssetDelete,
      onAssetCreate,
      onAssetUpload,
      onExport,
      onSessionStart,
      onSessionEnd
    });
    setSId(id);
    setApp(newApp);
  }, [sId, id]);
  React49.useEffect(() => {
    if (document2 == void 0)
      return;
    if (document2.id === app.document.id) {
      app.updateDocument(document2);
    } else {
      app.loadDocument(document2);
    }
  }, [document2, app]);
  React49.useEffect(() => {
    app.setDisableAssets(disableAssets);
  }, [app, disableAssets]);
  React49.useEffect(() => {
    if (!currentPageId)
      return;
    app.changePage(currentPageId);
  }, [currentPageId, app]);
  React49.useEffect(() => {
    app.readOnly = readOnly;
    if (!readOnly) {
      app.selectNone();
      app.cancelSession();
      app.setEditingId();
    }
  }, [app, readOnly]);
  React49.useEffect(() => {
    app.callbacks = {
      onMount,
      onChange,
      onOpenMedia,
      onUndo,
      onRedo,
      onPersist,
      onPatch,
      onCommand,
      onChangePage,
      onAssetDelete,
      onAssetCreate,
      onAssetUpload,
      onExport,
      onSessionStart,
      onSessionEnd
    };
  }, [
    onMount,
    onChange,
    onOpenMedia,
    onUndo,
    onRedo,
    onPersist,
    onPatch,
    onCommand,
    onChangePage,
    onAssetDelete,
    onAssetCreate,
    onAssetUpload,
    onExport,
    onSessionStart,
    onSessionEnd
  ]);
  React49.useLayoutEffect(() => {
    if (typeof window === "undefined")
      return;
    if (!window.document?.fonts)
      return;
    function refreshBoundingBoxes() {
      app.refreshBoundingBoxes();
    }
    window.document.fonts.addEventListener("loadingdone", refreshBoundingBoxes);
    return () => {
      window.document.fonts.removeEventListener("loadingdone", refreshBoundingBoxes);
    };
  }, [app]);
  React49.useEffect(() => {
    onLoaded?.(app);
  }, [app, onLoaded]);
  return /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(TldrawContext.Provider, { value: app, children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(AlertDialogContext.Provider, { value: { onYes, onCancel, onNo, dialogState, setDialogState, openDialog }, children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
    InnerTldraw,
    {
      id: sId,
      autofocus,
      showPages,
      showMenu,
      showStyles,
      showZoom,
      showTools,
      showUI,
      readOnly,
      components,
      hideCursors
    },
    sId || "Tldraw"
  ) }) });
}
var InnerTldraw = React49.memo(function InnerTldraw2({
  id,
  autofocus,
  showPages,
  showMenu,
  showZoom,
  showStyles,
  showTools,
  readOnly,
  showUI,
  components,
  hideCursors
}) {
  const app = useTldrawApp();
  const [dialogContainer, setDialogContainer] = React49.useState(null);
  const rWrapper = React49.useRef(null);
  const state = app.useStore();
  const { document: document2, settings, appState } = state;
  const isSelecting = state.appState.activeTool === "select";
  const page = document2.pages[appState.currentPageId];
  const pageState = document2.pageStates[page.id];
  const assets = document2.assets;
  const { selectedIds } = pageState;
  const isHideBoundsShape = selectedIds.length === 1 && page.shapes[selectedIds[0]] && TLDR.getShapeUtil(page.shapes[selectedIds[0]].type).hideBounds;
  const isHideResizeHandlesShape = selectedIds.length === 1 && page.shapes[selectedIds[0]] && TLDR.getShapeUtil(page.shapes[selectedIds[0]].type).hideResizeHandles;
  const showDashedBrush = settings.isCadSelectMode ? !appState.selectByContain : appState.selectByContain;
  const theme = React49.useMemo(() => {
    const { selectByContain } = appState;
    const { isCadSelectMode } = settings;
    const brushBase = isCadSelectMode ? selectByContain ? "0, 89, 242" : "51, 163, 23" : "0,0,0";
    return {
      brushFill: `rgba(${brushBase}, ${isCadSelectMode ? 0.08 : 0.05})`,
      brushStroke: `rgba(${brushBase}, ${isCadSelectMode ? 0.4 : 0.25})`,
      brushDashStroke: `rgba(${brushBase}, .6)`
    };
  }, [settings.isCadSelectMode, appState.selectByContain]);
  const isInSession = app.session !== void 0;
  const hideBounds = isInSession && app.session?.constructor.name !== "BrushSession" || !isSelecting || isHideBoundsShape || !!pageState.editingId;
  const hideHandles = isInSession || !isSelecting;
  const hideIndicators = isInSession && state.appState.status !== "brushing" /* Brushing */ || !isSelecting;
  const hideCloneHandles = isInSession || !isSelecting || pageState.camera.zoom < 0.2;
  useCursor(rWrapper);
  const onMouseEnter = React49.useCallback(() => {
    app.setMouseInBound(true);
  }, [app]);
  const onMouseLeave = React49.useCallback(() => {
    app.setMouseInBound(false);
  }, [app]);
  return /* @__PURE__ */ (0, import_jsx_runtime67.jsxs)(ContainerContext.Provider, { value: rWrapper, children: [
    /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(AlertDialog, { container: dialogContainer }),
    /* @__PURE__ */ (0, import_jsx_runtime67.jsxs)(StyledLayout, { ref: rWrapper, tabIndex: -1, onMouseEnter, onMouseLeave, children: [
      /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(Loading, {}),
      /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(OneOff, { focusableRef: rWrapper, autofocus }),
      /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(ContextMenu, { children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
        ks,
        {
          id,
          containerRef: rWrapper,
          shapeUtils,
          page,
          pageState,
          assets,
          snapLines: appState.snapLines,
          eraseLine: appState.eraseLine,
          grid: GRID_SIZE,
          theme,
          components,
          hideCursors,
          hideBounds,
          hideHandles,
          hideResizeHandles: isHideResizeHandlesShape,
          hideIndicators,
          hideBindingHandles: !settings.showBindingHandles,
          hideCloneHandles,
          hideRotateHandles: !settings.showRotateHandles,
          hideGrid: !settings.showGrid,
          showDashedBrush,
          performanceMode: app.session?.performanceMode,
          onPinchStart: app.onPinchStart,
          onPinchEnd: app.onPinchEnd,
          onPinch: app.onPinch,
          onPan: app.onPan,
          onZoom: app.onZoom,
          onPointerDown: app.onPointerDown,
          onPointerMove: app.onPointerMove,
          onPointerUp: app.onPointerUp,
          onPointCanvas: app.onPointCanvas,
          onDoubleClickCanvas: app.onDoubleClickCanvas,
          onRightPointCanvas: app.onRightPointCanvas,
          onDragCanvas: app.onDragCanvas,
          onReleaseCanvas: app.onReleaseCanvas,
          onPointShape: app.onPointShape,
          onDoubleClickShape: app.onDoubleClickShape,
          onRightPointShape: app.onRightPointShape,
          onDragShape: app.onDragShape,
          onHoverShape: app.onHoverShape,
          onUnhoverShape: app.onUnhoverShape,
          onReleaseShape: app.onReleaseShape,
          onPointBounds: app.onPointBounds,
          onDoubleClickBounds: app.onDoubleClickBounds,
          onRightPointBounds: app.onRightPointBounds,
          onDragBounds: app.onDragBounds,
          onHoverBounds: app.onHoverBounds,
          onUnhoverBounds: app.onUnhoverBounds,
          onReleaseBounds: app.onReleaseBounds,
          onPointBoundsHandle: app.onPointBoundsHandle,
          onDoubleClickBoundsHandle: app.onDoubleClickBoundsHandle,
          onRightPointBoundsHandle: app.onRightPointBoundsHandle,
          onDragBoundsHandle: app.onDragBoundsHandle,
          onHoverBoundsHandle: app.onHoverBoundsHandle,
          onUnhoverBoundsHandle: app.onUnhoverBoundsHandle,
          onReleaseBoundsHandle: app.onReleaseBoundsHandle,
          onPointHandle: app.onPointHandle,
          onDoubleClickHandle: app.onDoubleClickHandle,
          onRightPointHandle: app.onRightPointHandle,
          onDragHandle: app.onDragHandle,
          onHoverHandle: app.onHoverHandle,
          onUnhoverHandle: app.onUnhoverHandle,
          onReleaseHandle: app.onReleaseHandle,
          onError: app.onError,
          onRenderCountChange: app.onRenderCountChange,
          onShapeChange: app.onShapeChange,
          onShapeBlur: app.onShapeBlur,
          onShapeClone: app.onShapeClone,
          onBoundsChange: app.updateBounds,
          onKeyDown: app.onKeyDown,
          onKeyUp: app.onKeyUp,
          onDragOver: app.onDragOver,
          onDrop: app.onDrop
        }
      ) }),
      showUI && /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(StyledUI, { ref: setDialogContainer, children: settings.isFocusMode ? /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(FocusButton, { onSelect: app.toggleFocusMode }) : /* @__PURE__ */ (0, import_jsx_runtime67.jsxs)(import_jsx_runtime67.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(TopPanel, { readOnly, showPages, showMenu, showStyles, showZoom }),
        /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(StyledSpacer2, {}),
        showTools && !readOnly && /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(ToolsPanel, {})
      ] }) })
    ] })
  ] });
});
var OneOff = React49.memo(function OneOff2({ focusableRef, autofocus }) {
  useKeyboardShortcuts(focusableRef);
  React49.useEffect(() => {
    if (autofocus) {
      focusableRef.current?.focus();
    }
  }, [autofocus]);
  return null;
});
var StyledLayout = styled("div", {
  position: "absolute",
  height: "100%",
  width: "100%",
  minHeight: 0,
  minWidth: 0,
  maxHeight: "100%",
  maxWidth: "100%",
  overflow: "hidden",
  boxSizing: "border-box",
  outline: "none",
  "& .tl-container": {
    position: "absolute",
    top: 0,
    left: 0,
    height: "100%",
    width: "100%",
    zIndex: 1
  },
  "& input, textarea, button, select, label, button": {
    webkitTouchCallout: "none",
    webkitUserSelect: "none",
    "-webkit-tap-highlight-color": "transparent",
    "tap-highlight-color": "transparent"
  }
});
var StyledUI = styled("div", {
  position: "absolute",
  top: 0,
  left: 0,
  height: "100%",
  width: "100%",
  padding: "8px 8px 0 8px",
  display: "flex",
  alignItems: "flex-start",
  justifyContent: "flex-start",
  pointerEvents: "none",
  zIndex: 2,
  "& > *": {
    pointerEvents: "all"
  }
});
var StyledSpacer2 = styled("div", {
  flexGrow: 2
});

// src/components/App.tsx
var import_jsx_runtime68 = require("react/jsx-runtime");
var debounceSaveTime = 500;
function App(props) {
  const {
    height,
    width,
    currentTiddler,
    initialTiddlerText,
    isDraft,
    readonly,
    zoomToFit,
    zoom,
    saver: { onSave, lock },
    parentWidget
  } = props;
  const updatedCountReference = (0, import_react42.useRef)(0);
  const getTiddlerJSONContent = (0, import_react42.useCallback)(() => {
    if (initialTiddlerText) {
      try {
        const data = JSON.parse(initialTiddlerText);
        updatedCountReference.current = data.updatedCount ?? 0;
        return data.document;
      } catch (error) {
        console.error(`$:/plugins/linonetwo/tw-whiteboard load tiddler ${currentTiddler} failed, text:
${initialTiddlerText}
${error.message}`);
      }
    }
  }, [initialTiddlerText, currentTiddler]);
  const initialTiddlerJSONContent = (0, import_react42.useMemo)(getTiddlerJSONContent, []);
  (0, import_react42.useEffect)(() => {
    const latestUpdatedDocument = getTiddlerJSONContent();
    if (latestUpdatedDocument !== void 0) {
      tldrawDocumentSetter(latestUpdatedDocument);
    }
  }, [getTiddlerJSONContent]);
  const [tldrawDocument, tldrawDocumentSetterRaw] = (0, import_react42.useState)(initialTiddlerJSONContent);
  const tldrawDocumentReference = (0, import_react42.useRef)(tldrawDocument);
  const tldrawDocumentSetter = (newDocument) => {
    tldrawDocumentSetterRaw(newDocument);
    tldrawDocumentReference.current = newDocument;
  };
  const deferSave = (0, import_react42.useCallback)(
    (app) => {
      const saveCallback = () => {
        const exportedTldrJSON = { document: app.document, updatedCount: ++updatedCountReference.current };
        const newTiddlerText = JSON.stringify(exportedTldrJSON);
        lock();
        onSave(newTiddlerText);
      };
      if (typeof requestIdleCallback !== "undefined") {
        requestIdleCallback(saveCallback, { timeout: 60 });
      } else if (typeof requestAnimationFrame === "undefined") {
        setTimeout(saveCallback, 16.66);
      } else {
        requestAnimationFrame(saveCallback);
      }
    },
    [onSave, lock]
  );
  const debouncedSaveOnChange = useDebouncedCallback_default(
    (app) => {
      deferSave(app);
    },
    [deferSave],
    debounceSaveTime
  );
  const onChange = (app) => {
    app.document.name = currentTiddler;
    tldrawDocumentSetter(app.document);
    if (!isDraft && !readonly) {
      debouncedSaveOnChange(app);
    }
  };
  (0, import_react42.useEffect)(() => {
    return () => {
      if (readonly)
        return;
      const exportedTldrJSON = { document: tldrawDocumentReference.current, updatedCount: ++updatedCountReference.current };
      onSave(JSON.stringify(exportedTldrJSON));
    };
  }, []);
  const onMount = (0, import_react42.useCallback)((app) => {
    if (typeof zoom === "string") {
      app.zoomTo(Number(zoom));
    } else if (zoomToFit === true) {
      app.zoomToFit();
    }
  }, [zoom, zoomToFit]);
  return /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(import_tw_react2.ParentWidgetContext.Provider, { value: parentWidget, children: /* @__PURE__ */ (0, import_jsx_runtime68.jsx)("div", { className: "tw-whiteboard-tldraw-container", style: { height, width }, children: /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(Tldraw, { onPersist: onChange, onLoaded: onMount, document: tldrawDocument, autofocus: false, readOnly: readonly }) }) });
}

// src/widget.ts
var Widget = require("$:/plugins/linonetwo/tw-react/widget.js").widget;
var SAVE_DEBOUNCE_INTERVAL = 1e3;
var TldrawWhiteBoardWidget = class extends Widget {
  reactComponent = App;
  getProps = () => {
    return {
      currentTiddler: this.editTitle ?? this.getVariable("currentTiddler"),
      initialTiddlerText: this.editTitle === void 0 ? "" : $tw.wiki.getTiddlerText(this.editTitle),
      height: this.getAttribute("height"),
      width: this.getAttribute("width"),
      readonly: this.getAttribute("readonly") === "yes" || this.getAttribute("readonly") === "true",
      zoomToFit: this.getAttribute("zoomToFit") === "yes" || this.getAttribute("zoomToFit") === "true",
      zoom: this.getAttribute("zoom"),
      isDraft: this.editTitle === void 0 ? false : Boolean(this.getAttribute("draftTitle")),
      saver: {
        lock: this.lock,
        onSave: this.onSave,
        interval: SAVE_DEBOUNCE_INTERVAL
      }
    };
  };
  refresh(changedTiddlers) {
    if (this.editTitle === void 0)
      return false;
    if (changedTiddlers[this.editTitle]?.deleted === true) {
      this.lock();
      return false;
    }
    if (this.isUpdatingByUserInput) {
      return false;
    }
    const changedAttributes = this.computeAttributes();
    if ($tw.utils.count(changedAttributes) > 0 || changedTiddlers[this.editTitle]?.modified === true) {
      this.refreshSelf();
      return true;
    }
    return false;
  }
  editorOperations = {};
  editTitle;
  execute() {
    this.editTitle = this.getAttribute("tiddler");
    this.makeChildWidgets();
  }
  onSave = (newText) => {
    if (this.editTitle === "" || this.editTitle === void 0) {
      return;
    }
    const previousText = $tw.wiki.getTiddlerText(this.editTitle, "{}") || "{}";
    if (previousText !== newText) {
      let isSavingNewVersion = false;
      try {
        const newTextVersion = JSON.parse(newText).updatedCount ?? 0;
        const previousTextVersion = JSON.parse(previousText).updatedCount ?? 0;
        if (newTextVersion > previousTextVersion) {
          isSavingNewVersion = true;
        }
      } catch (error) {
        console.error(error);
      }
      if (isSavingNewVersion) {
        $tw.wiki.setText(this.editTitle, void 0, void 0, newText);
        $tw.wiki.setText(this.editTitle, "type", void 0, "application/tldr");
      }
    }
    window.requestIdleCallback(
      () => {
        this.parentWidget?.dispatchEvent({
          type: "tm-save-tiddler",
          // param: param,
          paramObject: { suppressNavigation: "yes" },
          // event: parameters.event,
          tiddlerTitle: this.editTitle
        });
        this.parentWidget?.dispatchEvent({ type: "tm-auto-save-wiki" });
      },
      { timeout: 2e3 }
    );
    this.unlock();
  };
  /** a lock to prevent update from tiddler to slate, when update of tiddler is trigger by slate. */
  isUpdatingByUserInput = false;
  updatingLockTimeoutHandle;
  get editIconElement() {
    const element = this.parentDomNode.closest(".tc-tiddler-exists")?.querySelector(".tc-image-wysiwyg-edit-button");
    return element;
  }
  lock = () => {
    this.isUpdatingByUserInput = true;
    if (this.updatingLockTimeoutHandle !== void 0) {
      clearTimeout(this.updatingLockTimeoutHandle);
    }
  };
  unlock = () => {
    this.updatingLockTimeoutHandle = setTimeout(() => {
      this.isUpdatingByUserInput = false;
    }, SAVE_DEBOUNCE_INTERVAL);
  };
};
exports.whiteboard = TldrawWhiteBoardWidget;
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tldraw/core/dist/index.mjs:
  (**
   * String.prototype.replaceAll() polyfill
   * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/
   * @author Chris Ferdinandi
   * @license MIT
   *)
*/
